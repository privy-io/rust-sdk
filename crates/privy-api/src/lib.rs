mod progenitor_client;

#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[doc = r" Types used as operation parameters and responses."]
#[allow(clippy::all)]
pub mod types {
    #[doc = r" Error types."]
    pub mod error {
        #[doc = r" Error from a `TryFrom` or `FromStr` implementation."]
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    #[doc = "`AuthenticateBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"encryption_type\": \"HPKE\","]
    #[doc = "      \"recipient_public_key\": \"DAQcDQgAEx4aoeD72yykviK+fckqE2CItVIGn1rCnvCXZ1HgpOcMEMialRmTrqIK4oZlYd1\","]
    #[doc = "      \"user_jwt\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"user_jwt\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"description\": \"The encryption type for the authentication response. Currently only supports HPKE.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"HPKE\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"recipient_public_key\": {"]
    #[doc = "      \"description\": \"The public key of your ECDH keypair, in base64-encoded, SPKI-format, whose private key will be able to decrypt the session key.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"user_jwt\": {"]
    #[doc = "      \"description\": \"The user's JWT, to be used to authenticate the user.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthenticateBody {
        #[doc = "The encryption type for the authentication response. Currently only supports HPKE."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub encryption_type: ::std::option::Option<AuthenticateBodyEncryptionType>,
        #[doc = "The public key of your ECDH keypair, in base64-encoded, SPKI-format, whose private key will be able to decrypt the session key."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recipient_public_key: ::std::option::Option<::std::string::String>,
        #[doc = "The user's JWT, to be used to authenticate the user."]
        pub user_jwt: ::std::string::String,
    }
    impl ::std::convert::From<&AuthenticateBody> for AuthenticateBody {
        fn from(value: &AuthenticateBody) -> Self {
            value.clone()
        }
    }
    impl AuthenticateBody {
        pub fn builder() -> builder::AuthenticateBody {
            Default::default()
        }
    }
    #[doc = "The encryption type for the authentication response. Currently only supports HPKE."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The encryption type for the authentication response. Currently only supports HPKE.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"HPKE\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AuthenticateBodyEncryptionType {
        #[serde(rename = "HPKE")]
        Hpke,
    }
    impl ::std::convert::From<&Self> for AuthenticateBodyEncryptionType {
        fn from(value: &AuthenticateBodyEncryptionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for AuthenticateBodyEncryptionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hpke => f.write_str("HPKE"),
            }
        }
    }
    impl ::std::str::FromStr for AuthenticateBodyEncryptionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "HPKE" => Ok(Self::Hpke),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for AuthenticateBodyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticateBodyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for AuthenticateBodyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`AuthenticateResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"title\": \"With encryption\","]
    #[doc = "      \"examples\": ["]
    #[doc = "        {"]
    #[doc = "          \"encrypted_authorization_key\": {"]
    #[doc = "            \"ciphertext\": \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgsqM8IKMlpFxVypBUa/Q2QvB1AmS/g5WHPp3SKq9A75uhRANCAATeX6BDghwclKAH8+/7IjvS1tCpvIfZ570IR44acX93pUGz5iEvpkg+HGaalHAXubuoUMq9CUWRm4wo+3090Nus\","]
    #[doc = "            \"encapsulated_key\": \"BECqbgIAcs3TpP5GadS6F8mXkSktR2DR8WNtd3e0Qcy7PpoRHEygpzjFWttntS+SEM3VSr4Thewh18ZP9chseLE=\","]
    #[doc = "            \"encryption_type\": \"HPKE\""]
    #[doc = "          },"]
    #[doc = "          \"expires_at\": 1697059200000,"]
    #[doc = "          \"wallets\": ["]
    #[doc = "            {"]
    #[doc = "              \"additional_signers\": ["]
    #[doc = "                {"]
    #[doc = "                  \"override_policy_ids\": [],"]
    #[doc = "                  \"signer_id\": \"p3cyj3n8mt9f9u2htfize511\""]
    #[doc = "                }"]
    #[doc = "              ],"]
    #[doc = "              \"address\": \"0x3DE69Fd93873d40459f27Ce5B74B42536f8d6149\","]
    #[doc = "              \"chain_type\": \"ethereum\","]
    #[doc = "              \"created_at\": 1744300912643,"]
    #[doc = "              \"exported_at\": null,"]
    #[doc = "              \"id\": \"ubul5xhljqorce73sf82u0p3\","]
    #[doc = "              \"imported_at\": null,"]
    #[doc = "              \"owner_id\": \"lzjb3xnjk2ntod3w1hgwa358\","]
    #[doc = "              \"policy_ids\": []"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"additional_signers\": ["]
    #[doc = "                {"]
    #[doc = "                  \"override_policy_ids\": [],"]
    #[doc = "                  \"signer_id\": \"p3cyj3n8mt9f9u2htfize511\""]
    #[doc = "                }"]
    #[doc = "              ],"]
    #[doc = "              \"address\": \"9wtGmqMamnKfz49XBwnJASbjcVnnKnT78qKopCL54TAk\","]
    #[doc = "              \"chain_type\": \"solana\","]
    #[doc = "              \"created_at\": 1744300912644,"]
    #[doc = "              \"exported_at\": null,"]
    #[doc = "              \"id\": \"sb4y18l68xze8gfszafmyv3q\","]
    #[doc = "              \"imported_at\": null,"]
    #[doc = "              \"owner_id\": \"lzjb3xnjk2ntod3w1hgwa358\","]
    #[doc = "              \"policy_ids\": []"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      ],"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encrypted_authorization_key\","]
    #[doc = "        \"expires_at\","]
    #[doc = "        \"wallets\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encrypted_authorization_key\": {"]
    #[doc = "          \"description\": \"The encrypted authorization key data.\","]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"ciphertext\","]
    #[doc = "            \"encapsulated_key\","]
    #[doc = "            \"encryption_type\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"ciphertext\": {"]
    #[doc = "              \"description\": \"The encrypted authorization key corresponding to the user's current authentication session.\","]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"encapsulated_key\": {"]
    #[doc = "              \"description\": \"Base64-encoded ephemeral public key used in the HPKE encryption process. Required for decryption.\","]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"encryption_type\": {"]
    #[doc = "              \"description\": \"The encryption type used. Currently only supports HPKE.\","]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"HPKE\""]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"expires_at\": {"]
    #[doc = "          \"description\": \"The expiration time of the authorization key in seconds since the epoch.\","]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        },"]
    #[doc = "        \"wallets\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"$ref\": \"#/components/schemas/Wallet\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"title\": \"Without encryption\","]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"authorization_key\","]
    #[doc = "        \"expires_at\","]
    #[doc = "        \"wallets\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"authorization_key\": {"]
    #[doc = "          \"description\": \"The raw authorization key data.\","]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"expires_at\": {"]
    #[doc = "          \"description\": \"The expiration time of the authorization key in seconds since the epoch.\","]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        },"]
    #[doc = "        \"wallets\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"$ref\": \"#/components/schemas/Wallet\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum AuthenticateResponse {
        WithEncryption {
            encrypted_authorization_key: WithEncryptionEncryptedAuthorizationKey,
            expires_at: f64,
            wallets: ::std::vec::Vec<Wallet>,
        },
        WithoutEncryption {
            #[doc = "The raw authorization key data."]
            authorization_key: ::std::string::String,
            expires_at: f64,
            wallets: ::std::vec::Vec<Wallet>,
        },
    }
    impl ::std::convert::From<&Self> for AuthenticateResponse {
        fn from(value: &AuthenticateResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "A condition that must be true for the rule action to be applied."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Condition\","]
    #[doc = "  \"description\": \"A condition that must be true for the rule action to be applied.\","]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumTransactionCondition\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumCalldataCondition\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumTypedDataDomainCondition\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumTypedDataMessageCondition\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/Ethereum7702AuthorizationCondition\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaProgramInstructionCondition\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaSystemProgramInstructionCondition\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaTokenProgramInstructionCondition\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum Condition {
        EthereumTransactionCondition(EthereumTransactionCondition),
        EthereumCalldataCondition(EthereumCalldataCondition),
        EthereumTypedDataDomainCondition(EthereumTypedDataDomainCondition),
        EthereumTypedDataMessageCondition(EthereumTypedDataMessageCondition),
        Ethereum7702AuthorizationCondition(Ethereum7702AuthorizationCondition),
        SolanaProgramInstructionCondition(SolanaProgramInstructionCondition),
        SolanaSystemProgramInstructionCondition(SolanaSystemProgramInstructionCondition),
        SolanaTokenProgramInstructionCondition(SolanaTokenProgramInstructionCondition),
    }
    impl ::std::convert::From<&Self> for Condition {
        fn from(value: &Condition) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EthereumTransactionCondition> for Condition {
        fn from(value: EthereumTransactionCondition) -> Self {
            Self::EthereumTransactionCondition(value)
        }
    }
    impl ::std::convert::From<EthereumCalldataCondition> for Condition {
        fn from(value: EthereumCalldataCondition) -> Self {
            Self::EthereumCalldataCondition(value)
        }
    }
    impl ::std::convert::From<EthereumTypedDataDomainCondition> for Condition {
        fn from(value: EthereumTypedDataDomainCondition) -> Self {
            Self::EthereumTypedDataDomainCondition(value)
        }
    }
    impl ::std::convert::From<EthereumTypedDataMessageCondition> for Condition {
        fn from(value: EthereumTypedDataMessageCondition) -> Self {
            Self::EthereumTypedDataMessageCondition(value)
        }
    }
    impl ::std::convert::From<Ethereum7702AuthorizationCondition> for Condition {
        fn from(value: Ethereum7702AuthorizationCondition) -> Self {
            Self::Ethereum7702AuthorizationCondition(value)
        }
    }
    impl ::std::convert::From<SolanaProgramInstructionCondition> for Condition {
        fn from(value: SolanaProgramInstructionCondition) -> Self {
            Self::SolanaProgramInstructionCondition(value)
        }
    }
    impl ::std::convert::From<SolanaSystemProgramInstructionCondition> for Condition {
        fn from(value: SolanaSystemProgramInstructionCondition) -> Self {
            Self::SolanaSystemProgramInstructionCondition(value)
        }
    }
    impl ::std::convert::From<SolanaTokenProgramInstructionCondition> for Condition {
        fn from(value: SolanaTokenProgramInstructionCondition) -> Self {
            Self::SolanaTokenProgramInstructionCondition(value)
        }
    }
    #[doc = "`ConditionOperator`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eq\","]
    #[doc = "    \"gt\","]
    #[doc = "    \"gte\","]
    #[doc = "    \"lt\","]
    #[doc = "    \"lte\","]
    #[doc = "    \"in\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ConditionOperator {
        #[serde(rename = "eq")]
        Eq,
        #[serde(rename = "gt")]
        Gt,
        #[serde(rename = "gte")]
        Gte,
        #[serde(rename = "lt")]
        Lt,
        #[serde(rename = "lte")]
        Lte,
        #[serde(rename = "in")]
        In,
    }
    impl ::std::convert::From<&Self> for ConditionOperator {
        fn from(value: &ConditionOperator) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for ConditionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eq => f.write_str("eq"),
                Self::Gt => f.write_str("gt"),
                Self::Gte => f.write_str("gte"),
                Self::Lt => f.write_str("lt"),
                Self::Lte => f.write_str("lte"),
                Self::In => f.write_str("in"),
            }
        }
    }
    impl ::std::str::FromStr for ConditionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eq" => Ok(Self::Eq),
                "gt" => Ok(Self::Gt),
                "gte" => Ok(Self::Gte),
                "lt" => Ok(Self::Lt),
                "lte" => Ok(Self::Lte),
                "in" => Ok(Self::In),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for ConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for ConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for ConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`ConditionValue`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ConditionValue {
        Variant0(::std::string::String),
        Variant1(::std::vec::Vec<::std::string::String>),
    }
    impl ::std::convert::From<&Self> for ConditionValue {
        fn from(value: &ConditionValue) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for ConditionValue {
        fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`CreateUserBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"linked_accounts\": ["]
    #[doc = "        {"]
    #[doc = "          \"address\": \"tom.bombadill@privy.io\","]
    #[doc = "          \"type\": \"email\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"linked_accounts\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"custom_metadata\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CustomMetadata\""]
    #[doc = "    },"]
    #[doc = "    \"linked_accounts\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/LinkedAccountInput\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"wallets\": {"]
    #[doc = "      \"description\": \"Wallets to create for the user.\","]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"chain_type\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"additional_signers\": {"]
    #[doc = "            \"description\": \"Additional signers for the wallet.\","]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"required\": ["]
    #[doc = "                \"signer_id\""]
    #[doc = "              ],"]
    #[doc = "              \"properties\": {"]
    #[doc = "                \"override_policy_ids\": {"]
    #[doc = "                  \"description\": \"The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet. Currently, only one policy is supported per signer.\","]
    #[doc = "                  \"type\": \"array\","]
    #[doc = "                  \"items\": {"]
    #[doc = "                    \"type\": \"string\","]
    #[doc = "                    \"maxLength\": 24,"]
    #[doc = "                    \"minLength\": 24"]
    #[doc = "                  }"]
    #[doc = "                },"]
    #[doc = "                \"signer_id\": {"]
    #[doc = "                  \"description\": \"The key quorum ID for the signer.\","]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                }"]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"chain_type\": {"]
    #[doc = "            \"$ref\": \"#/components/schemas/WalletChainType\""]
    #[doc = "          },"]
    #[doc = "          \"create_smart_wallet\": {"]
    #[doc = "            \"description\": \"Create a smart wallet with this wallet as the signer. Only supported for wallets with `chain_type: \\\"ethereum\\\"`.\","]
    #[doc = "            \"type\": \"boolean\""]
    #[doc = "          },"]
    #[doc = "          \"policy_ids\": {"]
    #[doc = "            \"description\": \"Policy IDs to enforce on the wallet. Currently, only one policy is supported per wallet.\","]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"maxLength\": 24,"]
    #[doc = "              \"minLength\": 24"]
    #[doc = "            },"]
    #[doc = "            \"maxItems\": 1"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub custom_metadata: ::std::option::Option<CustomMetadata>,
        pub linked_accounts: ::std::vec::Vec<LinkedAccountInput>,
        #[doc = "Wallets to create for the user."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub wallets: ::std::vec::Vec<CreateUserBodyWalletsItem>,
    }
    impl ::std::convert::From<&CreateUserBody> for CreateUserBody {
        fn from(value: &CreateUserBody) -> Self {
            value.clone()
        }
    }
    impl CreateUserBody {
        pub fn builder() -> builder::CreateUserBody {
            Default::default()
        }
    }
    #[doc = "`CreateUserBodyWalletsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chain_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"additional_signers\": {"]
    #[doc = "      \"description\": \"Additional signers for the wallet.\","]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"signer_id\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"override_policy_ids\": {"]
    #[doc = "            \"description\": \"The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet. Currently, only one policy is supported per signer.\","]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"maxLength\": 24,"]
    #[doc = "              \"minLength\": 24"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"signer_id\": {"]
    #[doc = "            \"description\": \"The key quorum ID for the signer.\","]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletChainType\""]
    #[doc = "    },"]
    #[doc = "    \"create_smart_wallet\": {"]
    #[doc = "      \"description\": \"Create a smart wallet with this wallet as the signer. Only supported for wallets with `chain_type: \\\"ethereum\\\"`.\","]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"policy_ids\": {"]
    #[doc = "      \"description\": \"Policy IDs to enforce on the wallet. Currently, only one policy is supported per wallet.\","]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"maxLength\": 24,"]
    #[doc = "        \"minLength\": 24"]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 1"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserBodyWalletsItem {
        #[doc = "Additional signers for the wallet."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub additional_signers: ::std::vec::Vec<CreateUserBodyWalletsItemAdditionalSignersItem>,
        pub chain_type: WalletChainType,
        #[doc = "Create a smart wallet with this wallet as the signer. Only supported for wallets with `chain_type: \"ethereum\"`."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub create_smart_wallet: ::std::option::Option<bool>,
        #[doc = "Policy IDs to enforce on the wallet. Currently, only one policy is supported per wallet."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<CreateUserBodyWalletsItemPolicyIdsItem>,
    }
    impl ::std::convert::From<&CreateUserBodyWalletsItem> for CreateUserBodyWalletsItem {
        fn from(value: &CreateUserBodyWalletsItem) -> Self {
            value.clone()
        }
    }
    impl CreateUserBodyWalletsItem {
        pub fn builder() -> builder::CreateUserBodyWalletsItem {
            Default::default()
        }
    }
    #[doc = "`CreateUserBodyWalletsItemAdditionalSignersItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"signer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"override_policy_ids\": {"]
    #[doc = "      \"description\": \"The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet. Currently, only one policy is supported per signer.\","]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"maxLength\": 24,"]
    #[doc = "        \"minLength\": 24"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"signer_id\": {"]
    #[doc = "      \"description\": \"The key quorum ID for the signer.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserBodyWalletsItemAdditionalSignersItem {
        #[doc = "The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet. Currently, only one policy is supported per signer."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub override_policy_ids:
            ::std::vec::Vec<CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem>,
        #[doc = "The key quorum ID for the signer."]
        pub signer_id: ::std::string::String,
    }
    impl ::std::convert::From<&CreateUserBodyWalletsItemAdditionalSignersItem>
        for CreateUserBodyWalletsItemAdditionalSignersItem
    {
        fn from(value: &CreateUserBodyWalletsItemAdditionalSignersItem) -> Self {
            value.clone()
        }
    }
    impl CreateUserBodyWalletsItemAdditionalSignersItem {
        pub fn builder() -> builder::CreateUserBodyWalletsItemAdditionalSignersItem {
            Default::default()
        }
    }
    #[doc = "`CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 24,"]
    #[doc = "  \"minLength\": 24"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem(
        ::std::string::String,
    );
    impl ::std::ops::Deref for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem>
        for ::std::string::String
    {
        fn from(
            value: CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem,
        ) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        fn from(
            value: &CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`CreateUserBodyWalletsItemPolicyIdsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 24,"]
    #[doc = "  \"minLength\": 24"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserBodyWalletsItemPolicyIdsItem(::std::string::String);
    impl ::std::ops::Deref for CreateUserBodyWalletsItemPolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateUserBodyWalletsItemPolicyIdsItem> for ::std::string::String {
        fn from(value: CreateUserBodyWalletsItemPolicyIdsItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateUserBodyWalletsItemPolicyIdsItem>
        for CreateUserBodyWalletsItemPolicyIdsItem
    {
        fn from(value: &CreateUserBodyWalletsItemPolicyIdsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateUserBodyWalletsItemPolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserBodyWalletsItemPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserBodyWalletsItemPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateUserBodyWalletsItemPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateUserBodyWalletsItemPolicyIdsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`CreateUserWalletBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"wallets\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"wallets\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"chain_type\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"additional_signers\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"required\": ["]
    #[doc = "                \"signer_id\""]
    #[doc = "              ],"]
    #[doc = "              \"properties\": {"]
    #[doc = "                \"override_policy_ids\": {"]
    #[doc = "                  \"type\": \"array\","]
    #[doc = "                  \"items\": {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  \"maxItems\": 1"]
    #[doc = "                },"]
    #[doc = "                \"signer_id\": {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                }"]
    #[doc = "              },"]
    #[doc = "              \"additionalProperties\": false"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"chain_type\": {"]
    #[doc = "            \"anyOf\": ["]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"cosmos\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"stellar\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"sui\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"tron\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"bitcoin-segwit\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"near\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"ton\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"starknet\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"spark\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"solana\""]
    #[doc = "                ]"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\","]
    #[doc = "                \"enum\": ["]
    #[doc = "                  \"ethereum\""]
    #[doc = "                ]"]
    #[doc = "              }"]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"create_smart_wallet\": {"]
    #[doc = "            \"type\": \"boolean\""]
    #[doc = "          },"]
    #[doc = "          \"policy_ids\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"maxItems\": 1"]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"additionalProperties\": false"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserWalletBody {
        pub wallets: ::std::vec::Vec<CreateUserWalletBodyWalletsItem>,
    }
    impl ::std::convert::From<&CreateUserWalletBody> for CreateUserWalletBody {
        fn from(value: &CreateUserWalletBody) -> Self {
            value.clone()
        }
    }
    impl CreateUserWalletBody {
        pub fn builder() -> builder::CreateUserWalletBody {
            Default::default()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chain_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"additional_signers\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"signer_id\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"override_policy_ids\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"maxItems\": 1"]
    #[doc = "          },"]
    #[doc = "          \"signer_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"additionalProperties\": false"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"cosmos\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"stellar\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"sui\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"tron\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"bitcoin-segwit\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"near\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"ton\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"starknet\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"spark\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"solana\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"ethereum\""]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"create_smart_wallet\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"policy_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 1"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreateUserWalletBodyWalletsItem {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub additional_signers:
            ::std::vec::Vec<CreateUserWalletBodyWalletsItemAdditionalSignersItem>,
        pub chain_type: CreateUserWalletBodyWalletsItemChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub create_smart_wallet: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<::std::string::String>,
    }
    impl ::std::convert::From<&CreateUserWalletBodyWalletsItem> for CreateUserWalletBodyWalletsItem {
        fn from(value: &CreateUserWalletBodyWalletsItem) -> Self {
            value.clone()
        }
    }
    impl CreateUserWalletBodyWalletsItem {
        pub fn builder() -> builder::CreateUserWalletBodyWalletsItem {
            Default::default()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemAdditionalSignersItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"signer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"override_policy_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 1"]
    #[doc = "    },"]
    #[doc = "    \"signer_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct CreateUserWalletBodyWalletsItemAdditionalSignersItem {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub override_policy_ids: ::std::vec::Vec<::std::string::String>,
        pub signer_id: ::std::string::String,
    }
    impl ::std::convert::From<&CreateUserWalletBodyWalletsItemAdditionalSignersItem>
        for CreateUserWalletBodyWalletsItemAdditionalSignersItem
    {
        fn from(value: &CreateUserWalletBodyWalletsItemAdditionalSignersItem) -> Self {
            value.clone()
        }
    }
    impl CreateUserWalletBodyWalletsItemAdditionalSignersItem {
        pub fn builder() -> builder::CreateUserWalletBodyWalletsItemAdditionalSignersItem {
            Default::default()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"cosmos\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"stellar\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"sui\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"tron\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"bitcoin-segwit\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"near\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ton\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"starknet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"spark\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserWalletBodyWalletsItemChainType {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype1>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_2: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype2>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_3: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype3>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_4: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype4>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_5: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype5>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_6: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype6>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_7: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype7>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_8: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype8>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_9: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype9>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_10: ::std::option::Option<CreateUserWalletBodyWalletsItemChainTypeSubtype10>,
    }
    impl ::std::convert::From<&CreateUserWalletBodyWalletsItemChainType>
        for CreateUserWalletBodyWalletsItemChainType
    {
        fn from(value: &CreateUserWalletBodyWalletsItemChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for CreateUserWalletBodyWalletsItemChainType {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
                subtype_2: Default::default(),
                subtype_3: Default::default(),
                subtype_4: Default::default(),
                subtype_5: Default::default(),
                subtype_6: Default::default(),
                subtype_7: Default::default(),
                subtype_8: Default::default(),
                subtype_9: Default::default(),
                subtype_10: Default::default(),
            }
        }
    }
    impl CreateUserWalletBodyWalletsItemChainType {
        pub fn builder() -> builder::CreateUserWalletBodyWalletsItemChainType {
            Default::default()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"cosmos\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype0 {
        #[serde(rename = "cosmos")]
        Cosmos,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype0 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype0) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Cosmos => f.write_str("cosmos"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "cosmos" => Ok(Self::Cosmos),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype0
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype0
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype1`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"stellar\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype1 {
        #[serde(rename = "stellar")]
        Stellar,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype1 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype1) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Stellar => f.write_str("stellar"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "stellar" => Ok(Self::Stellar),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype10`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype10 {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype10 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype10) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype10 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype10 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype10 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype10
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype10
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"sui\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype2 {
        #[serde(rename = "sui")]
        Sui,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype2 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype2) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype2 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sui => f.write_str("sui"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sui" => Ok(Self::Sui),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype3`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"tron\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype3 {
        #[serde(rename = "tron")]
        Tron,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype3 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype3) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype3 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Tron => f.write_str("tron"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype3 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "tron" => Ok(Self::Tron),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype3 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype3
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype3
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype4`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"bitcoin-segwit\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype4 {
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype4 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype4) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype4 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype4 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype4 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype4
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype4
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype5`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"near\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype5 {
        #[serde(rename = "near")]
        Near,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype5 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype5) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype5 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Near => f.write_str("near"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype5 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "near" => Ok(Self::Near),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype5 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype5
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype5
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype6`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ton\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype6 {
        #[serde(rename = "ton")]
        Ton,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype6 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype6) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype6 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ton => f.write_str("ton"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype6 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ton" => Ok(Self::Ton),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype6 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype6
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype6
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype7`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"starknet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype7 {
        #[serde(rename = "starknet")]
        Starknet,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype7 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype7) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype7 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Starknet => f.write_str("starknet"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype7 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "starknet" => Ok(Self::Starknet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype7 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype7
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype7
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype8`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"spark\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype8 {
        #[serde(rename = "spark")]
        Spark,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype8 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype8) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype8 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Spark => f.write_str("spark"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype8 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "spark" => Ok(Self::Spark),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype8 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype8
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype8
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateUserWalletBodyWalletsItemChainTypeSubtype9`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainTypeSubtype9 {
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainTypeSubtype9 {
        fn from(value: &CreateUserWalletBodyWalletsItemChainTypeSubtype9) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainTypeSubtype9 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainTypeSubtype9 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainTypeSubtype9 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype9
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserWalletBodyWalletsItemChainTypeSubtype9
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`CreateWalletBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"chain_type\": \"ethereum\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chain_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"additional_signers\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletAdditionalSigner\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletChainType\""]
    #[doc = "    },"]
    #[doc = "    \"owner\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/OwnerInput\""]
    #[doc = "    },"]
    #[doc = "    \"owner_id\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/OwnerIdInput\""]
    #[doc = "    },"]
    #[doc = "    \"policy_ids\": {"]
    #[doc = "      \"description\": \"List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet.\","]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"maxLength\": 24,"]
    #[doc = "        \"minLength\": 24"]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 1"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateWalletBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub additional_signers: ::std::option::Option<WalletAdditionalSigner>,
        pub chain_type: WalletChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<OwnerInput>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<OwnerIdInput>,
        #[doc = "List of policy IDs for policies that should be enforced on the wallet. Currently, only one policy is supported per wallet."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<CreateWalletBodyPolicyIdsItem>,
    }
    impl ::std::convert::From<&CreateWalletBody> for CreateWalletBody {
        fn from(value: &CreateWalletBody) -> Self {
            value.clone()
        }
    }
    impl CreateWalletBody {
        pub fn builder() -> builder::CreateWalletBody {
            Default::default()
        }
    }
    #[doc = "`CreateWalletBodyPolicyIdsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 24,"]
    #[doc = "  \"minLength\": 24"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateWalletBodyPolicyIdsItem(::std::string::String);
    impl ::std::ops::Deref for CreateWalletBodyPolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<CreateWalletBodyPolicyIdsItem> for ::std::string::String {
        fn from(value: CreateWalletBodyPolicyIdsItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CreateWalletBodyPolicyIdsItem> for CreateWalletBodyPolicyIdsItem {
        fn from(value: &CreateWalletBodyPolicyIdsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for CreateWalletBodyPolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for CreateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for CreateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for CreateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for CreateWalletBodyPolicyIdsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "Custom metadata associated with the user."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Custom metadata associated with the user.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"additionalProperties\": {"]
    #[doc = "    \"anyOf\": ["]
    #[doc = "      {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      },"]
    #[doc = "      {"]
    #[doc = "        \"type\": \"number\""]
    #[doc = "      },"]
    #[doc = "      {"]
    #[doc = "        \"type\": \"boolean\""]
    #[doc = "      }"]
    #[doc = "    ]"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct CustomMetadata(
        pub ::std::collections::HashMap<::std::string::String, CustomMetadataValue>,
    );
    impl ::std::ops::Deref for CustomMetadata {
        type Target = ::std::collections::HashMap<::std::string::String, CustomMetadataValue>;
        fn deref(
            &self,
        ) -> &::std::collections::HashMap<::std::string::String, CustomMetadataValue> {
            &self.0
        }
    }
    impl ::std::convert::From<CustomMetadata>
        for ::std::collections::HashMap<::std::string::String, CustomMetadataValue>
    {
        fn from(value: CustomMetadata) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&CustomMetadata> for CustomMetadata {
        fn from(value: &CustomMetadata) -> Self {
            value.clone()
        }
    }
    impl
        ::std::convert::From<
            ::std::collections::HashMap<::std::string::String, CustomMetadataValue>,
        > for CustomMetadata
    {
        fn from(
            value: ::std::collections::HashMap<::std::string::String, CustomMetadataValue>,
        ) -> Self {
            Self(value)
        }
    }
    #[doc = "`CustomMetadataValue`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum CustomMetadataValue {
        Variant0(::std::string::String),
        Variant1(f64),
        Variant2(bool),
    }
    impl ::std::convert::From<&Self> for CustomMetadataValue {
        fn from(value: &CustomMetadataValue) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for CustomMetadataValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
                Self::Variant2(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<f64> for CustomMetadataValue {
        fn from(value: f64) -> Self {
            Self::Variant1(value)
        }
    }
    impl ::std::convert::From<bool> for CustomMetadataValue {
        fn from(value: bool) -> Self {
            Self::Variant2(value)
        }
    }
    #[doc = "Allowed contract addresses for eth_signAuthorization requests."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"ethereum_7702_authorization\","]
    #[doc = "  \"description\": \"Allowed contract addresses for eth_signAuthorization requests.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"Ethereum7702AuthorizationConditionField\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"contract\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum_7702_authorization\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ethereum7702AuthorizationCondition {
        pub field: Ethereum7702AuthorizationConditionField,
        pub field_source: Ethereum7702AuthorizationConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&Ethereum7702AuthorizationCondition>
        for Ethereum7702AuthorizationCondition
    {
        fn from(value: &Ethereum7702AuthorizationCondition) -> Self {
            value.clone()
        }
    }
    impl Ethereum7702AuthorizationCondition {
        pub fn builder() -> builder::Ethereum7702AuthorizationCondition {
            Default::default()
        }
    }
    #[doc = "`Ethereum7702AuthorizationConditionField`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Ethereum7702AuthorizationConditionField\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"contract\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Ethereum7702AuthorizationConditionField {
        #[serde(rename = "contract")]
        Contract,
    }
    impl ::std::convert::From<&Self> for Ethereum7702AuthorizationConditionField {
        fn from(value: &Ethereum7702AuthorizationConditionField) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for Ethereum7702AuthorizationConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Contract => f.write_str("contract"),
            }
        }
    }
    impl ::std::str::FromStr for Ethereum7702AuthorizationConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "contract" => Ok(Self::Contract),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for Ethereum7702AuthorizationConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for Ethereum7702AuthorizationConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for Ethereum7702AuthorizationConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`Ethereum7702AuthorizationConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum_7702_authorization\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Ethereum7702AuthorizationConditionFieldSource {
        #[serde(rename = "ethereum_7702_authorization")]
        Ethereum7702Authorization,
    }
    impl ::std::convert::From<&Self> for Ethereum7702AuthorizationConditionFieldSource {
        fn from(value: &Ethereum7702AuthorizationConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for Ethereum7702AuthorizationConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum7702Authorization => f.write_str("ethereum_7702_authorization"),
            }
        }
    }
    impl ::std::str::FromStr for Ethereum7702AuthorizationConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_7702_authorization" => Ok(Self::Ethereum7702Authorization),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for Ethereum7702AuthorizationConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for Ethereum7702AuthorizationConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for Ethereum7702AuthorizationConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The decoded calldata in a smart contract interaction as the smart contract method's parameters. Note that that 'ethereum_calldata' conditions must contain an abi parameter with the JSON ABI of the smart contract."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"ethereum_calldata\","]
    #[doc = "  \"description\": \"The decoded calldata in a smart contract interaction as the smart contract method's parameters. Note that that 'ethereum_calldata' conditions must contain an abi parameter with the JSON ABI of the smart contract.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"abi\","]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"abi\": {"]
    #[doc = "      \"type\": \"object\""]
    #[doc = "    },"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"EthereumCalldataConditionField\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum_calldata\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumCalldataCondition {
        pub abi: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub field: ::std::string::String,
        pub field_source: EthereumCalldataConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&EthereumCalldataCondition> for EthereumCalldataCondition {
        fn from(value: &EthereumCalldataCondition) -> Self {
            value.clone()
        }
    }
    impl EthereumCalldataCondition {
        pub fn builder() -> builder::EthereumCalldataCondition {
            Default::default()
        }
    }
    #[doc = "`EthereumCalldataConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum_calldata\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumCalldataConditionFieldSource {
        #[serde(rename = "ethereum_calldata")]
        EthereumCalldata,
    }
    impl ::std::convert::From<&Self> for EthereumCalldataConditionFieldSource {
        fn from(value: &EthereumCalldataConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumCalldataConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumCalldata => f.write_str("ethereum_calldata"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumCalldataConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_calldata" => Ok(Self::EthereumCalldata),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumCalldataConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumCalldataConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumCalldataConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumPersonalSignRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"personal_sign\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"message\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"utf-8\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"hex\""]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumPersonalSignRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumPersonalSignRpcInputChainType>,
        pub method: EthereumPersonalSignRpcInputMethod,
        pub params: EthereumPersonalSignRpcInputParams,
    }
    impl ::std::convert::From<&EthereumPersonalSignRpcInput> for EthereumPersonalSignRpcInput {
        fn from(value: &EthereumPersonalSignRpcInput) -> Self {
            value.clone()
        }
    }
    impl EthereumPersonalSignRpcInput {
        pub fn builder() -> builder::EthereumPersonalSignRpcInput {
            Default::default()
        }
    }
    #[doc = "`EthereumPersonalSignRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcInputChainType {
        fn from(value: &EthereumPersonalSignRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumPersonalSignRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumPersonalSignRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumPersonalSignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumPersonalSignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumPersonalSignRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"personal_sign\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcInputMethod {
        #[serde(rename = "personal_sign")]
        PersonalSign,
    }
    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcInputMethod {
        fn from(value: &EthereumPersonalSignRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumPersonalSignRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PersonalSign => f.write_str("personal_sign"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumPersonalSignRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "personal_sign" => Ok(Self::PersonalSign),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumPersonalSignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumPersonalSignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumPersonalSignRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"utf-8\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"hex\""]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumPersonalSignRpcInputParams {
        pub encoding: EthereumPersonalSignRpcInputParamsEncoding,
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumPersonalSignRpcInputParams>
        for EthereumPersonalSignRpcInputParams
    {
        fn from(value: &EthereumPersonalSignRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl EthereumPersonalSignRpcInputParams {
        pub fn builder() -> builder::EthereumPersonalSignRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`EthereumPersonalSignRpcInputParamsEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"utf-8\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"hex\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumPersonalSignRpcInputParamsEncoding {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<EthereumPersonalSignRpcInputParamsEncodingSubtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<EthereumPersonalSignRpcInputParamsEncodingSubtype1>,
    }
    impl ::std::convert::From<&EthereumPersonalSignRpcInputParamsEncoding>
        for EthereumPersonalSignRpcInputParamsEncoding
    {
        fn from(value: &EthereumPersonalSignRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for EthereumPersonalSignRpcInputParamsEncoding {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
            }
        }
    }
    impl EthereumPersonalSignRpcInputParamsEncoding {
        pub fn builder() -> builder::EthereumPersonalSignRpcInputParamsEncoding {
            Default::default()
        }
    }
    #[doc = "`EthereumPersonalSignRpcInputParamsEncodingSubtype0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"utf-8\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcInputParamsEncodingSubtype0 {
        #[serde(rename = "utf-8")]
        Utf8,
    }
    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcInputParamsEncodingSubtype0 {
        fn from(value: &EthereumPersonalSignRpcInputParamsEncodingSubtype0) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumPersonalSignRpcInputParamsEncodingSubtype0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Utf8 => f.write_str("utf-8"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumPersonalSignRpcInputParamsEncodingSubtype0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "utf-8" => Ok(Self::Utf8),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcInputParamsEncodingSubtype0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumPersonalSignRpcInputParamsEncodingSubtype0
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumPersonalSignRpcInputParamsEncodingSubtype0
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumPersonalSignRpcInputParamsEncodingSubtype1`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"hex\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcInputParamsEncodingSubtype1 {
        #[serde(rename = "hex")]
        Hex,
    }
    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcInputParamsEncodingSubtype1 {
        fn from(value: &EthereumPersonalSignRpcInputParamsEncodingSubtype1) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumPersonalSignRpcInputParamsEncodingSubtype1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumPersonalSignRpcInputParamsEncodingSubtype1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcInputParamsEncodingSubtype1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumPersonalSignRpcInputParamsEncodingSubtype1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumPersonalSignRpcInputParamsEncodingSubtype1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumPersonalSignRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\","]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"signature\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"hex\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"signature\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"personal_sign\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumPersonalSignRpcResponse {
        pub data: EthereumPersonalSignRpcResponseData,
        pub method: EthereumPersonalSignRpcResponseMethod,
    }
    impl ::std::convert::From<&EthereumPersonalSignRpcResponse> for EthereumPersonalSignRpcResponse {
        fn from(value: &EthereumPersonalSignRpcResponse) -> Self {
            value.clone()
        }
    }
    impl EthereumPersonalSignRpcResponse {
        pub fn builder() -> builder::EthereumPersonalSignRpcResponse {
            Default::default()
        }
    }
    #[doc = "`EthereumPersonalSignRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"signature\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"hex\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumPersonalSignRpcResponseData {
        pub encoding: EthereumPersonalSignRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumPersonalSignRpcResponseData>
        for EthereumPersonalSignRpcResponseData
    {
        fn from(value: &EthereumPersonalSignRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl EthereumPersonalSignRpcResponseData {
        pub fn builder() -> builder::EthereumPersonalSignRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`EthereumPersonalSignRpcResponseDataEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"hex\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }
    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcResponseDataEncoding {
        fn from(value: &EthereumPersonalSignRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumPersonalSignRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumPersonalSignRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumPersonalSignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumPersonalSignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumPersonalSignRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"personal_sign\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcResponseMethod {
        #[serde(rename = "personal_sign")]
        PersonalSign,
    }
    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcResponseMethod {
        fn from(value: &EthereumPersonalSignRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumPersonalSignRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PersonalSign => f.write_str("personal_sign"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumPersonalSignRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "personal_sign" => Ok(Self::PersonalSign),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumPersonalSignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumPersonalSignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"secp256k1_sign\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"hash\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"hash\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSecp256k1SignRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSecp256k1SignRpcInputChainType>,
        pub method: EthereumSecp256k1SignRpcInputMethod,
        pub params: EthereumSecp256k1SignRpcInputParams,
    }
    impl ::std::convert::From<&EthereumSecp256k1SignRpcInput> for EthereumSecp256k1SignRpcInput {
        fn from(value: &EthereumSecp256k1SignRpcInput) -> Self {
            value.clone()
        }
    }
    impl EthereumSecp256k1SignRpcInput {
        pub fn builder() -> builder::EthereumSecp256k1SignRpcInput {
            Default::default()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcInputChainType {
        fn from(value: &EthereumSecp256k1SignRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSecp256k1SignRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSecp256k1SignRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSecp256k1SignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSecp256k1SignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"secp256k1_sign\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcInputMethod {
        #[serde(rename = "secp256k1_sign")]
        Secp256k1Sign,
    }
    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcInputMethod {
        fn from(value: &EthereumSecp256k1SignRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSecp256k1SignRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Secp256k1Sign => f.write_str("secp256k1_sign"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSecp256k1SignRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "secp256k1_sign" => Ok(Self::Secp256k1Sign),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSecp256k1SignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSecp256k1SignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"hash\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"hash\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSecp256k1SignRpcInputParams {
        pub hash: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumSecp256k1SignRpcInputParams>
        for EthereumSecp256k1SignRpcInputParams
    {
        fn from(value: &EthereumSecp256k1SignRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl EthereumSecp256k1SignRpcInputParams {
        pub fn builder() -> builder::EthereumSecp256k1SignRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\","]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"signature\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"hex\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"signature\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"secp256k1_sign\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSecp256k1SignRpcResponse {
        pub data: EthereumSecp256k1SignRpcResponseData,
        pub method: EthereumSecp256k1SignRpcResponseMethod,
    }
    impl ::std::convert::From<&EthereumSecp256k1SignRpcResponse> for EthereumSecp256k1SignRpcResponse {
        fn from(value: &EthereumSecp256k1SignRpcResponse) -> Self {
            value.clone()
        }
    }
    impl EthereumSecp256k1SignRpcResponse {
        pub fn builder() -> builder::EthereumSecp256k1SignRpcResponse {
            Default::default()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"signature\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"hex\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSecp256k1SignRpcResponseData {
        pub encoding: EthereumSecp256k1SignRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumSecp256k1SignRpcResponseData>
        for EthereumSecp256k1SignRpcResponseData
    {
        fn from(value: &EthereumSecp256k1SignRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl EthereumSecp256k1SignRpcResponseData {
        pub fn builder() -> builder::EthereumSecp256k1SignRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcResponseDataEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"hex\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }
    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcResponseDataEncoding {
        fn from(value: &EthereumSecp256k1SignRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSecp256k1SignRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSecp256k1SignRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSecp256k1SignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSecp256k1SignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSecp256k1SignRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"secp256k1_sign\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcResponseMethod {
        #[serde(rename = "secp256k1_sign")]
        Secp256k1Sign,
    }
    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcResponseMethod {
        fn from(value: &EthereumSecp256k1SignRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSecp256k1SignRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Secp256k1Sign => f.write_str("secp256k1_sign"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSecp256k1SignRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "secp256k1_sign" => Ok(Self::Secp256k1Sign),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSecp256k1SignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSecp256k1SignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSendTransactionRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"caip2\","]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"caip2\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_sendTransaction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"transaction\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"transaction\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"chain_id\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"data\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"from\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"gas_limit\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"gas_price\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"max_fee_per_gas\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"max_priority_fee_per_gas\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"nonce\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"to\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"type\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    0.0"]
    #[doc = "                  ]"]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    1.0"]
    #[doc = "                  ]"]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    2.0"]
    #[doc = "                  ]"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"value\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"additionalProperties\": false"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    },"]
    #[doc = "    \"sponsor\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSendTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        pub caip2: EthereumSendTransactionRpcInputCaip2,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSendTransactionRpcInputChainType>,
        pub method: EthereumSendTransactionRpcInputMethod,
        pub params: EthereumSendTransactionRpcInputParams,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsor: ::std::option::Option<bool>,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInput> for EthereumSendTransactionRpcInput {
        fn from(value: &EthereumSendTransactionRpcInput) -> Self {
            value.clone()
        }
    }
    impl EthereumSendTransactionRpcInput {
        pub fn builder() -> builder::EthereumSendTransactionRpcInput {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputCaip2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputCaip2(::std::string::String);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcInputCaip2> for ::std::string::String {
        fn from(value: EthereumSendTransactionRpcInputCaip2) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInputCaip2>
        for EthereumSendTransactionRpcInputCaip2
    {
        fn from(value: &EthereumSendTransactionRpcInputCaip2) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EthereumSendTransactionRpcInputCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EthereumSendTransactionRpcInputCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSendTransactionRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputChainType {
        fn from(value: &EthereumSendTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSendTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_sendTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSendTransactionRpcInputMethod {
        #[serde(rename = "eth_sendTransaction")]
        EthSendTransaction,
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputMethod {
        fn from(value: &EthereumSendTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSendTransaction => f.write_str("eth_sendTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSendTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sendTransaction" => Ok(Self::EthSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"transaction\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"transaction\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"chain_id\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"data\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"from\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"gas_limit\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"gas_price\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"max_fee_per_gas\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"max_priority_fee_per_gas\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"nonce\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"to\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"type\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                0.0"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                1.0"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                2.0"]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"value\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSendTransactionRpcInputParams {
        pub transaction: EthereumSendTransactionRpcInputParamsTransaction,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInputParams>
        for EthereumSendTransactionRpcInputParams
    {
        fn from(value: &EthereumSendTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl EthereumSendTransactionRpcInputParams {
        pub fn builder() -> builder::EthereumSendTransactionRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransaction`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"from\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"gas_limit\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"gas_price\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_fee_per_gas\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_priority_fee_per_gas\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"nonce\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"to\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            0.0"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            1.0"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            2.0"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSendTransactionRpcInputParamsTransaction {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionChainId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_limit:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionGasLimit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_price:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionGasPrice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_fee_per_gas:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_priority_fee_per_gas: ::std::option::Option<
            EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce: ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionNonce>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub to: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionValue>,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransaction>
        for EthereumSendTransactionRpcInputParamsTransaction
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransaction) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for EthereumSendTransactionRpcInputParamsTransaction {
        fn default() -> Self {
            Self {
                chain_id: Default::default(),
                data: Default::default(),
                from: Default::default(),
                gas_limit: Default::default(),
                gas_price: Default::default(),
                max_fee_per_gas: Default::default(),
                max_priority_fee_per_gas: Default::default(),
                nonce: Default::default(),
                to: Default::default(),
                type_: Default::default(),
                value: Default::default(),
            }
        }
    }
    impl EthereumSendTransactionRpcInputParamsTransaction {
        pub fn builder() -> builder::EthereumSendTransactionRpcInputParamsTransaction {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionChainId`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionChainId {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionChainId {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionChainId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionChainId {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionGasLimit`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionGasLimit) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionGasPrice`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionGasPrice) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(
            value: &EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionNonce`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionNonce {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionNonce {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionNonce) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionNonce {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        0.0"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        1.0"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        2.0"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcInputParamsTransactionType {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_2:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2>,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransactionType>
        for EthereumSendTransactionRpcInputParamsTransactionType
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionType) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for EthereumSendTransactionRpcInputParamsTransactionType {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
                subtype_2: Default::default(),
            }
        }
    }
    impl EthereumSendTransactionRpcInputParamsTransactionType {
        pub fn builder() -> builder::EthereumSendTransactionRpcInputParamsTransactionType {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    0.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0> for f64 {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0>
        for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64> for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![0.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    1.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1> for f64 {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1>
        for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64> for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![1.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    2.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2> for f64 {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2>
        for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64> for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![2.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSendTransactionRpcInputParamsTransactionValue`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionValue {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionValue {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionValue) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionValue {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"caip2\","]
    #[doc = "        \"hash\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"caip2\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "        },"]
    #[doc = "        \"hash\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"transaction_id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"transaction_request\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"chain_id\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"data\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"from\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"gas_limit\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"gas_price\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"max_fee_per_gas\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"max_priority_fee_per_gas\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"nonce\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"to\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"type\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    0.0"]
    #[doc = "                  ]"]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    1.0"]
    #[doc = "                  ]"]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    2.0"]
    #[doc = "                  ]"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"value\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"additionalProperties\": false"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"code\","]
    #[doc = "        \"message\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"code\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_sendTransaction\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<EthereumSendTransactionRpcResponseData>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<EthereumSendTransactionRpcResponseError>,
        pub method: EthereumSendTransactionRpcResponseMethod,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponse>
        for EthereumSendTransactionRpcResponse
    {
        fn from(value: &EthereumSendTransactionRpcResponse) -> Self {
            value.clone()
        }
    }
    impl EthereumSendTransactionRpcResponse {
        pub fn builder() -> builder::EthereumSendTransactionRpcResponse {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"caip2\","]
    #[doc = "    \"hash\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"caip2\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "    },"]
    #[doc = "    \"hash\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"transaction_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"transaction_request\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"chain_id\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"data\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"from\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"gas_limit\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"gas_price\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"max_fee_per_gas\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"max_priority_fee_per_gas\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"nonce\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"to\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"type\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                0.0"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                1.0"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                2.0"]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"value\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcResponseData {
        pub caip2: EthereumSendTransactionRpcResponseDataCaip2,
        pub hash: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_request:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequest>,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseData>
        for EthereumSendTransactionRpcResponseData
    {
        fn from(value: &EthereumSendTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl EthereumSendTransactionRpcResponseData {
        pub fn builder() -> builder::EthereumSendTransactionRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataCaip2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataCaip2(::std::string::String);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataCaip2> for ::std::string::String {
        fn from(value: EthereumSendTransactionRpcResponseDataCaip2) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataCaip2>
        for EthereumSendTransactionRpcResponseDataCaip2
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataCaip2) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for EthereumSendTransactionRpcResponseDataCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcResponseDataCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for EthereumSendTransactionRpcResponseDataCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"from\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"gas_limit\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"gas_price\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_fee_per_gas\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_priority_fee_per_gas\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"nonce\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"to\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            0.0"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            1.0"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            2.0"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestChainId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_limit:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_price:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_fee_per_gas: ::std::option::Option<
            EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_priority_fee_per_gas: ::std::option::Option<
            EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestNonce>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub to: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestValue>,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequest>
        for EthereumSendTransactionRpcResponseDataTransactionRequest
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequest) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for EthereumSendTransactionRpcResponseDataTransactionRequest {
        fn default() -> Self {
            Self {
                chain_id: Default::default(),
                data: Default::default(),
                from: Default::default(),
                gas_limit: Default::default(),
                gas_price: Default::default(),
                max_fee_per_gas: Default::default(),
                max_priority_fee_per_gas: Default::default(),
                nonce: Default::default(),
                to: Default::default(),
                type_: Default::default(),
                value: Default::default(),
            }
        }
    }
    impl EthereumSendTransactionRpcResponseDataTransactionRequest {
        pub fn builder() -> builder::EthereumSendTransactionRpcResponseDataTransactionRequest {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestChainId`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestChainId {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestChainId
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestChainId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcResponseDataTransactionRequestChainId {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit
    {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice
    {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestNonce`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestNonce) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        0.0"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        1.0"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        2.0"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequestType {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<
            EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0,
        >,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<
            EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1,
        >,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_2: ::std::option::Option<
            EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2,
        >,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequestType>
        for EthereumSendTransactionRpcResponseDataTransactionRequestType
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestType) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for EthereumSendTransactionRpcResponseDataTransactionRequestType {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
                subtype_2: Default::default(),
            }
        }
    }
    impl EthereumSendTransactionRpcResponseDataTransactionRequestType {
        pub fn builder() -> builder::EthereumSendTransactionRpcResponseDataTransactionRequestType {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    0.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0>
        for f64
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0,
        ) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0
    {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![0.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    1.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1>
        for f64
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1,
        ) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![1.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    2.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2>
        for f64
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2,
        ) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![2.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseDataTransactionRequestValue`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestValue) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseError`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcResponseError {
        pub code: ::std::string::String,
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumSendTransactionRpcResponseError>
        for EthereumSendTransactionRpcResponseError
    {
        fn from(value: &EthereumSendTransactionRpcResponseError) -> Self {
            value.clone()
        }
    }
    impl EthereumSendTransactionRpcResponseError {
        pub fn builder() -> builder::EthereumSendTransactionRpcResponseError {
            Default::default()
        }
    }
    #[doc = "`EthereumSendTransactionRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_sendTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSendTransactionRpcResponseMethod {
        #[serde(rename = "eth_sendTransaction")]
        EthSendTransaction,
    }
    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcResponseMethod {
        fn from(value: &EthereumSendTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSendTransaction => f.write_str("eth_sendTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSendTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sendTransaction" => Ok(Self::EthSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_sign7702Authorization\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"chain_id\","]
    #[doc = "        \"contract\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"chain_id\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"contract\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"nonce\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSign7702AuthorizationRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSign7702AuthorizationRpcInputChainType>,
        pub method: EthereumSign7702AuthorizationRpcInputMethod,
        pub params: EthereumSign7702AuthorizationRpcInputParams,
    }
    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcInput>
        for EthereumSign7702AuthorizationRpcInput
    {
        fn from(value: &EthereumSign7702AuthorizationRpcInput) -> Self {
            value.clone()
        }
    }
    impl EthereumSign7702AuthorizationRpcInput {
        pub fn builder() -> builder::EthereumSign7702AuthorizationRpcInput {
            Default::default()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSign7702AuthorizationRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputChainType {
        fn from(value: &EthereumSign7702AuthorizationRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSign7702AuthorizationRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSign7702AuthorizationRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSign7702AuthorizationRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSign7702AuthorizationRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_sign7702Authorization\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSign7702AuthorizationRpcInputMethod {
        #[serde(rename = "eth_sign7702Authorization")]
        EthSign7702Authorization,
    }
    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputMethod {
        fn from(value: &EthereumSign7702AuthorizationRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSign7702Authorization => f.write_str("eth_sign7702Authorization"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSign7702AuthorizationRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sign7702Authorization" => Ok(Self::EthSign7702Authorization),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSign7702AuthorizationRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSign7702AuthorizationRpcInputMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSign7702AuthorizationRpcInputMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chain_id\","]
    #[doc = "    \"contract\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"contract\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"nonce\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSign7702AuthorizationRpcInputParams {
        pub chain_id: EthereumSign7702AuthorizationRpcInputParamsChainId,
        pub contract: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce: ::std::option::Option<EthereumSign7702AuthorizationRpcInputParamsNonce>,
    }
    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcInputParams>
        for EthereumSign7702AuthorizationRpcInputParams
    {
        fn from(value: &EthereumSign7702AuthorizationRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl EthereumSign7702AuthorizationRpcInputParams {
        pub fn builder() -> builder::EthereumSign7702AuthorizationRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcInputParamsChainId`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcInputParamsChainId {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputParamsChainId {
        fn from(value: &EthereumSign7702AuthorizationRpcInputParamsChainId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputParamsChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSign7702AuthorizationRpcInputParamsChainId {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcInputParamsNonce`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcInputParamsNonce {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputParamsNonce {
        fn from(value: &EthereumSign7702AuthorizationRpcInputParamsNonce) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputParamsNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSign7702AuthorizationRpcInputParamsNonce {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"authorization\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"authorization\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"chain_id\","]
    #[doc = "            \"contract\","]
    #[doc = "            \"nonce\","]
    #[doc = "            \"r\","]
    #[doc = "            \"s\","]
    #[doc = "            \"y_parity\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"chain_id\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"contract\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"nonce\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"r\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"s\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"y_parity\": {"]
    #[doc = "              \"type\": \"number\""]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"code\","]
    #[doc = "        \"message\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"code\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_sign7702Authorization\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<EthereumSign7702AuthorizationRpcResponseData>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<EthereumSign7702AuthorizationRpcResponseError>,
        pub method: EthereumSign7702AuthorizationRpcResponseMethod,
    }
    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcResponse>
        for EthereumSign7702AuthorizationRpcResponse
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponse) -> Self {
            value.clone()
        }
    }
    impl EthereumSign7702AuthorizationRpcResponse {
        pub fn builder() -> builder::EthereumSign7702AuthorizationRpcResponse {
            Default::default()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"authorization\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"authorization\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"chain_id\","]
    #[doc = "        \"contract\","]
    #[doc = "        \"nonce\","]
    #[doc = "        \"r\","]
    #[doc = "        \"s\","]
    #[doc = "        \"y_parity\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"chain_id\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"contract\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"nonce\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"r\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"s\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"y_parity\": {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcResponseData {
        pub authorization: EthereumSign7702AuthorizationRpcResponseDataAuthorization,
    }
    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcResponseData>
        for EthereumSign7702AuthorizationRpcResponseData
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl EthereumSign7702AuthorizationRpcResponseData {
        pub fn builder() -> builder::EthereumSign7702AuthorizationRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcResponseDataAuthorization`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chain_id\","]
    #[doc = "    \"contract\","]
    #[doc = "    \"nonce\","]
    #[doc = "    \"r\","]
    #[doc = "    \"s\","]
    #[doc = "    \"y_parity\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"contract\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"nonce\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"r\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"s\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"y_parity\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcResponseDataAuthorization {
        pub chain_id: EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId,
        pub contract: ::std::string::String,
        pub nonce: EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce,
        pub r: ::std::string::String,
        pub s: ::std::string::String,
        pub y_parity: f64,
    }
    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcResponseDataAuthorization>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorization
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseDataAuthorization) -> Self {
            value.clone()
        }
    }
    impl EthereumSign7702AuthorizationRpcResponseDataAuthorization {
        pub fn builder() -> builder::EthereumSign7702AuthorizationRpcResponseDataAuthorization {
            Default::default()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId
    {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcResponseError`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcResponseError {
        pub code: ::std::string::String,
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcResponseError>
        for EthereumSign7702AuthorizationRpcResponseError
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseError) -> Self {
            value.clone()
        }
    }
    impl EthereumSign7702AuthorizationRpcResponseError {
        pub fn builder() -> builder::EthereumSign7702AuthorizationRpcResponseError {
            Default::default()
        }
    }
    #[doc = "`EthereumSign7702AuthorizationRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_sign7702Authorization\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSign7702AuthorizationRpcResponseMethod {
        #[serde(rename = "eth_sign7702Authorization")]
        EthSign7702Authorization,
    }
    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcResponseMethod {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSign7702Authorization => f.write_str("eth_sign7702Authorization"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSign7702AuthorizationRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sign7702Authorization" => Ok(Self::EthSign7702Authorization),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSign7702AuthorizationRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSign7702AuthorizationRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSign7702AuthorizationRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTransactionRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_signTransaction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"transaction\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"transaction\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"chain_id\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"data\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"from\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"gas_limit\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"gas_price\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"max_fee_per_gas\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"max_priority_fee_per_gas\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"nonce\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"to\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"type\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    0.0"]
    #[doc = "                  ]"]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    1.0"]
    #[doc = "                  ]"]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"number\","]
    #[doc = "                  \"enum\": ["]
    #[doc = "                    2.0"]
    #[doc = "                  ]"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"value\": {"]
    #[doc = "              \"anyOf\": ["]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                {"]
    #[doc = "                  \"type\": \"integer\","]
    #[doc = "                  \"maximum\": 9007199254740991.0,"]
    #[doc = "                  \"minimum\": -9007199254740991.0"]
    #[doc = "                }"]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"additionalProperties\": false"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSignTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSignTransactionRpcInputChainType>,
        pub method: EthereumSignTransactionRpcInputMethod,
        pub params: EthereumSignTransactionRpcInputParams,
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcInput> for EthereumSignTransactionRpcInput {
        fn from(value: &EthereumSignTransactionRpcInput) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTransactionRpcInput {
        pub fn builder() -> builder::EthereumSignTransactionRpcInput {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputChainType {
        fn from(value: &EthereumSignTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_signTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcInputMethod {
        #[serde(rename = "eth_signTransaction")]
        EthSignTransaction,
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputMethod {
        fn from(value: &EthereumSignTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTransaction => f.write_str("eth_signTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTransaction" => Ok(Self::EthSignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"transaction\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"transaction\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"chain_id\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"data\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"from\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"gas_limit\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"gas_price\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"max_fee_per_gas\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"max_priority_fee_per_gas\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"nonce\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"to\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"type\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                0.0"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                1.0"]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"number\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                2.0"]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"value\": {"]
    #[doc = "          \"anyOf\": ["]
    #[doc = "            {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            {"]
    #[doc = "              \"type\": \"integer\","]
    #[doc = "              \"maximum\": 9007199254740991.0,"]
    #[doc = "              \"minimum\": -9007199254740991.0"]
    #[doc = "            }"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSignTransactionRpcInputParams {
        pub transaction: EthereumSignTransactionRpcInputParamsTransaction,
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcInputParams>
        for EthereumSignTransactionRpcInputParams
    {
        fn from(value: &EthereumSignTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTransactionRpcInputParams {
        pub fn builder() -> builder::EthereumSignTransactionRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransaction`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"from\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"gas_limit\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"gas_price\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_fee_per_gas\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"max_priority_fee_per_gas\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"nonce\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"to\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            0.0"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            1.0"]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"number\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            2.0"]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"integer\","]
    #[doc = "          \"maximum\": 9007199254740991.0,"]
    #[doc = "          \"minimum\": -9007199254740991.0"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSignTransactionRpcInputParamsTransaction {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionChainId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_limit:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionGasLimit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_price:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionGasPrice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_fee_per_gas:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_priority_fee_per_gas: ::std::option::Option<
            EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce: ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionNonce>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub to: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionValue>,
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransaction>
        for EthereumSignTransactionRpcInputParamsTransaction
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransaction) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for EthereumSignTransactionRpcInputParamsTransaction {
        fn default() -> Self {
            Self {
                chain_id: Default::default(),
                data: Default::default(),
                from: Default::default(),
                gas_limit: Default::default(),
                gas_price: Default::default(),
                max_fee_per_gas: Default::default(),
                max_priority_fee_per_gas: Default::default(),
                nonce: Default::default(),
                to: Default::default(),
                type_: Default::default(),
                value: Default::default(),
            }
        }
    }
    impl EthereumSignTransactionRpcInputParamsTransaction {
        pub fn builder() -> builder::EthereumSignTransactionRpcInputParamsTransaction {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionChainId`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionChainId {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionChainId {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionChainId) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionChainId {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionGasLimit`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionGasLimit) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionGasPrice`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionGasPrice) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self>
        for EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(
            value: &EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        ) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64>
        for EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionNonce`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionNonce {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionNonce {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionNonce) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionNonce {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        0.0"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        1.0"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        2.0"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcInputParamsTransactionType {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_2:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2>,
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransactionType>
        for EthereumSignTransactionRpcInputParamsTransactionType
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionType) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for EthereumSignTransactionRpcInputParamsTransactionType {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
                subtype_2: Default::default(),
            }
        }
    }
    impl EthereumSignTransactionRpcInputParamsTransactionType {
        pub fn builder() -> builder::EthereumSignTransactionRpcInputParamsTransactionType {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    0.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0(f64);
    impl ::std::ops::Deref for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0> for f64 {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0>
        for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64> for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![0.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    1.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1(f64);
    impl ::std::ops::Deref for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1> for f64 {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1>
        for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64> for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![1.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"number\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    2.0"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2(f64);
    impl ::std::ops::Deref for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }
    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2> for f64 {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2>
        for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::TryFrom<f64> for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![2.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }
    impl<'de> ::serde::Deserialize<'de>
        for EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }
    #[doc = "`EthereumSignTransactionRpcInputParamsTransactionValue`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"maximum\": 9007199254740991.0,"]
    #[doc = "      \"minimum\": -9007199254740991.0"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionValue {
        Variant0(::std::string::String),
        Variant1(i64),
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionValue {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionValue) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }
    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionValue {
        fn from(value: i64) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`EthereumSignTransactionRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\","]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"signed_transaction\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"rlp\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"signed_transaction\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_signTransaction\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcResponse {
        pub data: EthereumSignTransactionRpcResponseData,
        pub method: EthereumSignTransactionRpcResponseMethod,
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcResponse>
        for EthereumSignTransactionRpcResponse
    {
        fn from(value: &EthereumSignTransactionRpcResponse) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTransactionRpcResponse {
        pub fn builder() -> builder::EthereumSignTransactionRpcResponse {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTransactionRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"signed_transaction\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"rlp\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signed_transaction\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcResponseData {
        pub encoding: EthereumSignTransactionRpcResponseDataEncoding,
        pub signed_transaction: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumSignTransactionRpcResponseData>
        for EthereumSignTransactionRpcResponseData
    {
        fn from(value: &EthereumSignTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTransactionRpcResponseData {
        pub fn builder() -> builder::EthereumSignTransactionRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTransactionRpcResponseDataEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"rlp\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcResponseDataEncoding {
        #[serde(rename = "rlp")]
        Rlp,
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcResponseDataEncoding {
        fn from(value: &EthereumSignTransactionRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Rlp => f.write_str("rlp"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTransactionRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "rlp" => Ok(Self::Rlp),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTransactionRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_signTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcResponseMethod {
        #[serde(rename = "eth_signTransaction")]
        EthSignTransaction,
    }
    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcResponseMethod {
        fn from(value: &EthereumSignTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTransaction => f.write_str("eth_signTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTransaction" => Ok(Self::EthSignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_signTypedData_v4\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"typed_data\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"typed_data\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"domain\","]
    #[doc = "            \"message\","]
    #[doc = "            \"primary_type\","]
    #[doc = "            \"types\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"domain\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"additionalProperties\": {}"]
    #[doc = "            },"]
    #[doc = "            \"message\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"additionalProperties\": {}"]
    #[doc = "            },"]
    #[doc = "            \"primary_type\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"types\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"additionalProperties\": {"]
    #[doc = "                \"type\": \"array\","]
    #[doc = "                \"items\": {"]
    #[doc = "                  \"type\": \"object\","]
    #[doc = "                  \"required\": ["]
    #[doc = "                    \"name\","]
    #[doc = "                    \"type\""]
    #[doc = "                  ],"]
    #[doc = "                  \"properties\": {"]
    #[doc = "                    \"name\": {"]
    #[doc = "                      \"type\": \"string\""]
    #[doc = "                    },"]
    #[doc = "                    \"type\": {"]
    #[doc = "                      \"type\": \"string\""]
    #[doc = "                    }"]
    #[doc = "                  }"]
    #[doc = "                }"]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"additionalProperties\": false"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSignTypedDataRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSignTypedDataRpcInputChainType>,
        pub method: EthereumSignTypedDataRpcInputMethod,
        pub params: EthereumSignTypedDataRpcInputParams,
    }
    impl ::std::convert::From<&EthereumSignTypedDataRpcInput> for EthereumSignTypedDataRpcInput {
        fn from(value: &EthereumSignTypedDataRpcInput) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTypedDataRpcInput {
        pub fn builder() -> builder::EthereumSignTypedDataRpcInput {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcInputChainType {
        fn from(value: &EthereumSignTypedDataRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTypedDataRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTypedDataRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTypedDataRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTypedDataRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_signTypedData_v4\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcInputMethod {
        #[serde(rename = "eth_signTypedData_v4")]
        EthSignTypedDataV4,
    }
    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcInputMethod {
        fn from(value: &EthereumSignTypedDataRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTypedDataRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTypedDataV4 => f.write_str("eth_signTypedData_v4"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTypedDataRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTypedData_v4" => Ok(Self::EthSignTypedDataV4),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTypedDataRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTypedDataRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"typed_data\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"typed_data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"domain\","]
    #[doc = "        \"message\","]
    #[doc = "        \"primary_type\","]
    #[doc = "        \"types\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"domain\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"additionalProperties\": {}"]
    #[doc = "        },"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"additionalProperties\": {}"]
    #[doc = "        },"]
    #[doc = "        \"primary_type\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"types\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"additionalProperties\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"required\": ["]
    #[doc = "                \"name\","]
    #[doc = "                \"type\""]
    #[doc = "              ],"]
    #[doc = "              \"properties\": {"]
    #[doc = "                \"name\": {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                \"type\": {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                }"]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSignTypedDataRpcInputParams {
        pub typed_data: EthereumSignTypedDataRpcInputParamsTypedData,
    }
    impl ::std::convert::From<&EthereumSignTypedDataRpcInputParams>
        for EthereumSignTypedDataRpcInputParams
    {
        fn from(value: &EthereumSignTypedDataRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTypedDataRpcInputParams {
        pub fn builder() -> builder::EthereumSignTypedDataRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcInputParamsTypedData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"domain\","]
    #[doc = "    \"message\","]
    #[doc = "    \"primary_type\","]
    #[doc = "    \"types\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"domain\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"additionalProperties\": {}"]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"additionalProperties\": {}"]
    #[doc = "    },"]
    #[doc = "    \"primary_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"types\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"additionalProperties\": {"]
    #[doc = "        \"type\": \"array\","]
    #[doc = "        \"items\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"name\","]
    #[doc = "            \"type\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"name\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"type\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct EthereumSignTypedDataRpcInputParamsTypedData {
        pub domain: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub message: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub primary_type: ::std::string::String,
        pub types: ::std::collections::HashMap<
            ::std::string::String,
            ::std::vec::Vec<EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem>,
        >,
    }
    impl ::std::convert::From<&EthereumSignTypedDataRpcInputParamsTypedData>
        for EthereumSignTypedDataRpcInputParamsTypedData
    {
        fn from(value: &EthereumSignTypedDataRpcInputParamsTypedData) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTypedDataRpcInputParamsTypedData {
        pub fn builder() -> builder::EthereumSignTypedDataRpcInputParamsTypedData {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem {
        pub name: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem>
        for EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem
    {
        fn from(value: &EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem {
        pub fn builder() -> builder::EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\","]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"signature\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"hex\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"signature\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_signTypedData_v4\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcResponse {
        pub data: EthereumSignTypedDataRpcResponseData,
        pub method: EthereumSignTypedDataRpcResponseMethod,
    }
    impl ::std::convert::From<&EthereumSignTypedDataRpcResponse> for EthereumSignTypedDataRpcResponse {
        fn from(value: &EthereumSignTypedDataRpcResponse) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTypedDataRpcResponse {
        pub fn builder() -> builder::EthereumSignTypedDataRpcResponse {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"signature\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"hex\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcResponseData {
        pub encoding: EthereumSignTypedDataRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumSignTypedDataRpcResponseData>
        for EthereumSignTypedDataRpcResponseData
    {
        fn from(value: &EthereumSignTypedDataRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl EthereumSignTypedDataRpcResponseData {
        pub fn builder() -> builder::EthereumSignTypedDataRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcResponseDataEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"hex\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }
    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcResponseDataEncoding {
        fn from(value: &EthereumSignTypedDataRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTypedDataRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTypedDataRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSignTypedDataRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSignTypedDataRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumSignTypedDataRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_signTypedData_v4\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcResponseMethod {
        #[serde(rename = "eth_signTypedData_v4")]
        EthSignTypedDataV4,
    }
    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcResponseMethod {
        fn from(value: &EthereumSignTypedDataRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumSignTypedDataRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTypedDataV4 => f.write_str("eth_signTypedData_v4"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumSignTypedDataRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTypedData_v4" => Ok(Self::EthSignTypedDataV4),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTypedDataRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTypedDataRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The verbatim Ethereum transaction object in an eth_signTransaction or eth_sendTransaction request."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"ethereum_transaction\","]
    #[doc = "  \"description\": \"The verbatim Ethereum transaction object in an eth_signTransaction or eth_sendTransaction request.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"EthereumTransactionConditionField\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"to\","]
    #[doc = "        \"value\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum_transaction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTransactionCondition {
        pub field: EthereumTransactionConditionField,
        pub field_source: EthereumTransactionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&EthereumTransactionCondition> for EthereumTransactionCondition {
        fn from(value: &EthereumTransactionCondition) -> Self {
            value.clone()
        }
    }
    impl EthereumTransactionCondition {
        pub fn builder() -> builder::EthereumTransactionCondition {
            Default::default()
        }
    }
    #[doc = "`EthereumTransactionConditionField`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"EthereumTransactionConditionField\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"to\","]
    #[doc = "    \"value\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTransactionConditionField {
        #[serde(rename = "to")]
        To,
        #[serde(rename = "value")]
        Value,
    }
    impl ::std::convert::From<&Self> for EthereumTransactionConditionField {
        fn from(value: &EthereumTransactionConditionField) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumTransactionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::To => f.write_str("to"),
                Self::Value => f.write_str("value"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumTransactionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "to" => Ok(Self::To),
                "value" => Ok(Self::Value),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumTransactionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumTransactionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumTransactionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumTransactionConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum_transaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTransactionConditionFieldSource {
        #[serde(rename = "ethereum_transaction")]
        EthereumTransaction,
    }
    impl ::std::convert::From<&Self> for EthereumTransactionConditionFieldSource {
        fn from(value: &EthereumTransactionConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumTransactionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumTransaction => f.write_str("ethereum_transaction"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumTransactionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_transaction" => Ok(Self::EthereumTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumTransactionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumTransactionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumTransactionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Attributes from the signing domain that will verify the signature."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"ethereum_typed_data_domain\","]
    #[doc = "  \"description\": \"Attributes from the signing domain that will verify the signature.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"EthereumTypedDataDomainConditionField\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"chainId\","]
    #[doc = "        \"verifyingContract\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum_typed_data_domain\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataDomainCondition {
        pub field: EthereumTypedDataDomainConditionField,
        pub field_source: EthereumTypedDataDomainConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&EthereumTypedDataDomainCondition> for EthereumTypedDataDomainCondition {
        fn from(value: &EthereumTypedDataDomainCondition) -> Self {
            value.clone()
        }
    }
    impl EthereumTypedDataDomainCondition {
        pub fn builder() -> builder::EthereumTypedDataDomainCondition {
            Default::default()
        }
    }
    #[doc = "`EthereumTypedDataDomainConditionField`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"EthereumTypedDataDomainConditionField\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"chainId\","]
    #[doc = "    \"verifyingContract\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTypedDataDomainConditionField {
        #[serde(rename = "chainId")]
        ChainId,
        #[serde(rename = "verifyingContract")]
        VerifyingContract,
    }
    impl ::std::convert::From<&Self> for EthereumTypedDataDomainConditionField {
        fn from(value: &EthereumTypedDataDomainConditionField) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumTypedDataDomainConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ChainId => f.write_str("chainId"),
                Self::VerifyingContract => f.write_str("verifyingContract"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumTypedDataDomainConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "chainId" => Ok(Self::ChainId),
                "verifyingContract" => Ok(Self::VerifyingContract),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumTypedDataDomainConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for EthereumTypedDataDomainConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for EthereumTypedDataDomainConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumTypedDataDomainConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum_typed_data_domain\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTypedDataDomainConditionFieldSource {
        #[serde(rename = "ethereum_typed_data_domain")]
        EthereumTypedDataDomain,
    }
    impl ::std::convert::From<&Self> for EthereumTypedDataDomainConditionFieldSource {
        fn from(value: &EthereumTypedDataDomainConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumTypedDataDomainConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumTypedDataDomain => f.write_str("ethereum_typed_data_domain"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumTypedDataDomainConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_typed_data_domain" => Ok(Self::EthereumTypedDataDomain),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumTypedDataDomainConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumTypedDataDomainConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumTypedDataDomainConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "'types' and 'primary_type' attributes of the TypedData JSON object defined in EIP-712."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"ethereum_typed_data_message\","]
    #[doc = "  \"description\": \"'types' and 'primary_type' attributes of the TypedData JSON object defined in EIP-712.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"typed_data\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"EthereumTypedDataMessageConditionField\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum_typed_data_message\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"typed_data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"primary_type\","]
    #[doc = "        \"types\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"primary_type\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"types\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"additionalProperties\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"required\": ["]
    #[doc = "                \"name\","]
    #[doc = "                \"type\""]
    #[doc = "              ],"]
    #[doc = "              \"properties\": {"]
    #[doc = "                \"name\": {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                },"]
    #[doc = "                \"type\": {"]
    #[doc = "                  \"type\": \"string\""]
    #[doc = "                }"]
    #[doc = "              }"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataMessageCondition {
        pub field: ::std::string::String,
        pub field_source: EthereumTypedDataMessageConditionFieldSource,
        pub operator: ConditionOperator,
        pub typed_data: EthereumTypedDataMessageConditionTypedData,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&EthereumTypedDataMessageCondition>
        for EthereumTypedDataMessageCondition
    {
        fn from(value: &EthereumTypedDataMessageCondition) -> Self {
            value.clone()
        }
    }
    impl EthereumTypedDataMessageCondition {
        pub fn builder() -> builder::EthereumTypedDataMessageCondition {
            Default::default()
        }
    }
    #[doc = "`EthereumTypedDataMessageConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum_typed_data_message\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTypedDataMessageConditionFieldSource {
        #[serde(rename = "ethereum_typed_data_message")]
        EthereumTypedDataMessage,
    }
    impl ::std::convert::From<&Self> for EthereumTypedDataMessageConditionFieldSource {
        fn from(value: &EthereumTypedDataMessageConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for EthereumTypedDataMessageConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumTypedDataMessage => f.write_str("ethereum_typed_data_message"),
            }
        }
    }
    impl ::std::str::FromStr for EthereumTypedDataMessageConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_typed_data_message" => Ok(Self::EthereumTypedDataMessage),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for EthereumTypedDataMessageConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumTypedDataMessageConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumTypedDataMessageConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`EthereumTypedDataMessageConditionTypedData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"primary_type\","]
    #[doc = "    \"types\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"primary_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"types\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"additionalProperties\": {"]
    #[doc = "        \"type\": \"array\","]
    #[doc = "        \"items\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"name\","]
    #[doc = "            \"type\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"name\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"type\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataMessageConditionTypedData {
        pub primary_type: ::std::string::String,
        pub types: ::std::collections::HashMap<
            ::std::string::String,
            ::std::vec::Vec<EthereumTypedDataMessageConditionTypedDataTypesValueItem>,
        >,
    }
    impl ::std::convert::From<&EthereumTypedDataMessageConditionTypedData>
        for EthereumTypedDataMessageConditionTypedData
    {
        fn from(value: &EthereumTypedDataMessageConditionTypedData) -> Self {
            value.clone()
        }
    }
    impl EthereumTypedDataMessageConditionTypedData {
        pub fn builder() -> builder::EthereumTypedDataMessageConditionTypedData {
            Default::default()
        }
    }
    #[doc = "`EthereumTypedDataMessageConditionTypedDataTypesValueItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataMessageConditionTypedDataTypesValueItem {
        pub name: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }
    impl ::std::convert::From<&EthereumTypedDataMessageConditionTypedDataTypesValueItem>
        for EthereumTypedDataMessageConditionTypedDataTypesValueItem
    {
        fn from(value: &EthereumTypedDataMessageConditionTypedDataTypesValueItem) -> Self {
            value.clone()
        }
    }
    impl EthereumTypedDataMessageConditionTypedDataTypesValueItem {
        pub fn builder() -> builder::EthereumTypedDataMessageConditionTypedDataTypesValueItem {
            Default::default()
        }
    }
    #[doc = "`GetUsersCursor`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetUsersCursor(::std::string::String);
    impl ::std::ops::Deref for GetUsersCursor {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetUsersCursor> for ::std::string::String {
        fn from(value: GetUsersCursor) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetUsersCursor> for GetUsersCursor {
        fn from(value: &GetUsersCursor) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetUsersCursor {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetUsersCursor {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetUsersCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetUsersCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetUsersCursor {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`GetUsersResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/User\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"next_cursor\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUsersResponse {
        pub data: ::std::vec::Vec<User>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_cursor: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&GetUsersResponse> for GetUsersResponse {
        fn from(value: &GetUsersResponse) -> Self {
            value.clone()
        }
    }
    impl GetUsersResponse {
        pub fn builder() -> builder::GetUsersResponse {
            Default::default()
        }
    }
    #[doc = "`GetWalletBalanceAsset`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"usdc\","]
    #[doc = "        \"eth\","]
    #[doc = "        \"pol\","]
    #[doc = "        \"sol\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"enum\": ["]
    #[doc = "          \"usdc\","]
    #[doc = "          \"eth\","]
    #[doc = "          \"pol\","]
    #[doc = "          \"sol\""]
    #[doc = "        ]"]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 10"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetWalletBalanceAsset {
        Variant0(GetWalletBalanceAssetVariant0),
        Variant1(::std::vec::Vec<GetWalletBalanceAssetVariant1Item>),
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceAsset {
        fn from(value: &GetWalletBalanceAsset) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<GetWalletBalanceAssetVariant0> for GetWalletBalanceAsset {
        fn from(value: GetWalletBalanceAssetVariant0) -> Self {
            Self::Variant0(value)
        }
    }
    impl ::std::convert::From<::std::vec::Vec<GetWalletBalanceAssetVariant1Item>>
        for GetWalletBalanceAsset
    {
        fn from(value: ::std::vec::Vec<GetWalletBalanceAssetVariant1Item>) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`GetWalletBalanceAssetVariant0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\","]
    #[doc = "    \"eth\","]
    #[doc = "    \"pol\","]
    #[doc = "    \"sol\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceAssetVariant0 {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "sol")]
        Sol,
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceAssetVariant0 {
        fn from(value: &GetWalletBalanceAssetVariant0) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletBalanceAssetVariant0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletBalanceAssetVariant0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletBalanceAssetVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceAssetVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceAssetVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletBalanceAssetVariant1Item`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\","]
    #[doc = "    \"eth\","]
    #[doc = "    \"pol\","]
    #[doc = "    \"sol\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceAssetVariant1Item {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "sol")]
        Sol,
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceAssetVariant1Item {
        fn from(value: &GetWalletBalanceAssetVariant1Item) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletBalanceAssetVariant1Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletBalanceAssetVariant1Item {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletBalanceAssetVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceAssetVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceAssetVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletBalanceChain`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\","]
    #[doc = "        \"arbitrum\","]
    #[doc = "        \"base\","]
    #[doc = "        \"linea\","]
    #[doc = "        \"optimism\","]
    #[doc = "        \"polygon\","]
    #[doc = "        \"solana\","]
    #[doc = "        \"zksync_era\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"enum\": ["]
    #[doc = "          \"ethereum\","]
    #[doc = "          \"arbitrum\","]
    #[doc = "          \"base\","]
    #[doc = "          \"linea\","]
    #[doc = "          \"optimism\","]
    #[doc = "          \"polygon\","]
    #[doc = "          \"solana\","]
    #[doc = "          \"zksync_era\""]
    #[doc = "        ]"]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 10"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetWalletBalanceChain {
        Variant0(GetWalletBalanceChainVariant0),
        Variant1(::std::vec::Vec<GetWalletBalanceChainVariant1Item>),
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceChain {
        fn from(value: &GetWalletBalanceChain) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<GetWalletBalanceChainVariant0> for GetWalletBalanceChain {
        fn from(value: GetWalletBalanceChainVariant0) -> Self {
            Self::Variant0(value)
        }
    }
    impl ::std::convert::From<::std::vec::Vec<GetWalletBalanceChainVariant1Item>>
        for GetWalletBalanceChain
    {
        fn from(value: ::std::vec::Vec<GetWalletBalanceChainVariant1Item>) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`GetWalletBalanceChainVariant0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"arbitrum\","]
    #[doc = "    \"base\","]
    #[doc = "    \"linea\","]
    #[doc = "    \"optimism\","]
    #[doc = "    \"polygon\","]
    #[doc = "    \"solana\","]
    #[doc = "    \"zksync_era\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceChainVariant0 {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceChainVariant0 {
        fn from(value: &GetWalletBalanceChainVariant0) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletBalanceChainVariant0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletBalanceChainVariant0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletBalanceChainVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceChainVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceChainVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletBalanceChainVariant1Item`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"arbitrum\","]
    #[doc = "    \"base\","]
    #[doc = "    \"linea\","]
    #[doc = "    \"optimism\","]
    #[doc = "    \"polygon\","]
    #[doc = "    \"solana\","]
    #[doc = "    \"zksync_era\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceChainVariant1Item {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceChainVariant1Item {
        fn from(value: &GetWalletBalanceChainVariant1Item) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletBalanceChainVariant1Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletBalanceChainVariant1Item {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletBalanceChainVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceChainVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceChainVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletBalanceIncludeCurrency`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usd\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceIncludeCurrency {
        #[serde(rename = "usd")]
        Usd,
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceIncludeCurrency {
        fn from(value: &GetWalletBalanceIncludeCurrency) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletBalanceIncludeCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletBalanceIncludeCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletBalanceIncludeCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceIncludeCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceIncludeCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletBalanceResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"balances\": ["]
    #[doc = "        {"]
    #[doc = "          \"asset\": \"eth\","]
    #[doc = "          \"chain\": \"base\","]
    #[doc = "          \"display_values\": {"]
    #[doc = "            \"eth\": \"0.001\","]
    #[doc = "            \"usd\": \"2.56\""]
    #[doc = "          },"]
    #[doc = "          \"raw_value\": \"1000000000000000000\","]
    #[doc = "          \"raw_value_decimals\": 18"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"balances\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"balances\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"asset\","]
    #[doc = "          \"chain\","]
    #[doc = "          \"display_values\","]
    #[doc = "          \"raw_value\","]
    #[doc = "          \"raw_value_decimals\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"asset\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"enum\": ["]
    #[doc = "              \"usdc\","]
    #[doc = "              \"eth\","]
    #[doc = "              \"pol\","]
    #[doc = "              \"sol\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"chain\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"enum\": ["]
    #[doc = "              \"ethereum\","]
    #[doc = "              \"arbitrum\","]
    #[doc = "              \"base\","]
    #[doc = "              \"linea\","]
    #[doc = "              \"optimism\","]
    #[doc = "              \"polygon\","]
    #[doc = "              \"solana\","]
    #[doc = "              \"zksync_era\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"display_values\": {"]
    #[doc = "            \"type\": \"object\","]
    #[doc = "            \"additionalProperties\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"raw_value\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"raw_value_decimals\": {"]
    #[doc = "            \"type\": \"number\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWalletBalanceResponse {
        pub balances: ::std::vec::Vec<GetWalletBalanceResponseBalancesItem>,
    }
    impl ::std::convert::From<&GetWalletBalanceResponse> for GetWalletBalanceResponse {
        fn from(value: &GetWalletBalanceResponse) -> Self {
            value.clone()
        }
    }
    impl GetWalletBalanceResponse {
        pub fn builder() -> builder::GetWalletBalanceResponse {
            Default::default()
        }
    }
    #[doc = "`GetWalletBalanceResponseBalancesItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"asset\","]
    #[doc = "    \"chain\","]
    #[doc = "    \"display_values\","]
    #[doc = "    \"raw_value\","]
    #[doc = "    \"raw_value_decimals\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"asset\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"usdc\","]
    #[doc = "        \"eth\","]
    #[doc = "        \"pol\","]
    #[doc = "        \"sol\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"chain\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\","]
    #[doc = "        \"arbitrum\","]
    #[doc = "        \"base\","]
    #[doc = "        \"linea\","]
    #[doc = "        \"optimism\","]
    #[doc = "        \"polygon\","]
    #[doc = "        \"solana\","]
    #[doc = "        \"zksync_era\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"display_values\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"additionalProperties\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"raw_value\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"raw_value_decimals\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWalletBalanceResponseBalancesItem {
        pub asset: GetWalletBalanceResponseBalancesItemAsset,
        pub chain: GetWalletBalanceResponseBalancesItemChain,
        pub display_values:
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        pub raw_value: ::std::string::String,
        pub raw_value_decimals: f64,
    }
    impl ::std::convert::From<&GetWalletBalanceResponseBalancesItem>
        for GetWalletBalanceResponseBalancesItem
    {
        fn from(value: &GetWalletBalanceResponseBalancesItem) -> Self {
            value.clone()
        }
    }
    impl GetWalletBalanceResponseBalancesItem {
        pub fn builder() -> builder::GetWalletBalanceResponseBalancesItem {
            Default::default()
        }
    }
    #[doc = "`GetWalletBalanceResponseBalancesItemAsset`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\","]
    #[doc = "    \"eth\","]
    #[doc = "    \"pol\","]
    #[doc = "    \"sol\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceResponseBalancesItemAsset {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "sol")]
        Sol,
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceResponseBalancesItemAsset {
        fn from(value: &GetWalletBalanceResponseBalancesItemAsset) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletBalanceResponseBalancesItemAsset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletBalanceResponseBalancesItemAsset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletBalanceResponseBalancesItemAsset {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceResponseBalancesItemAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceResponseBalancesItemAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletBalanceResponseBalancesItemChain`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"arbitrum\","]
    #[doc = "    \"base\","]
    #[doc = "    \"linea\","]
    #[doc = "    \"optimism\","]
    #[doc = "    \"polygon\","]
    #[doc = "    \"solana\","]
    #[doc = "    \"zksync_era\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceResponseBalancesItemChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }
    impl ::std::convert::From<&Self> for GetWalletBalanceResponseBalancesItemChain {
        fn from(value: &GetWalletBalanceResponseBalancesItemChain) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletBalanceResponseBalancesItemChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletBalanceResponseBalancesItemChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletBalanceResponseBalancesItemChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceResponseBalancesItemChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceResponseBalancesItemChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"cosmos\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"stellar\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"sui\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"tron\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"bitcoin-segwit\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"near\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ton\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"starknet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"spark\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWalletsChainType {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<GetWalletsChainTypeSubtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<GetWalletsChainTypeSubtype1>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_2: ::std::option::Option<GetWalletsChainTypeSubtype2>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_3: ::std::option::Option<GetWalletsChainTypeSubtype3>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_4: ::std::option::Option<GetWalletsChainTypeSubtype4>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_5: ::std::option::Option<GetWalletsChainTypeSubtype5>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_6: ::std::option::Option<GetWalletsChainTypeSubtype6>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_7: ::std::option::Option<GetWalletsChainTypeSubtype7>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_8: ::std::option::Option<GetWalletsChainTypeSubtype8>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_9: ::std::option::Option<GetWalletsChainTypeSubtype9>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_10: ::std::option::Option<GetWalletsChainTypeSubtype10>,
    }
    impl ::std::convert::From<&GetWalletsChainType> for GetWalletsChainType {
        fn from(value: &GetWalletsChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for GetWalletsChainType {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
                subtype_2: Default::default(),
                subtype_3: Default::default(),
                subtype_4: Default::default(),
                subtype_5: Default::default(),
                subtype_6: Default::default(),
                subtype_7: Default::default(),
                subtype_8: Default::default(),
                subtype_9: Default::default(),
                subtype_10: Default::default(),
            }
        }
    }
    impl GetWalletsChainType {
        pub fn builder() -> builder::GetWalletsChainType {
            Default::default()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"cosmos\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype0 {
        #[serde(rename = "cosmos")]
        Cosmos,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype0 {
        fn from(value: &GetWalletsChainTypeSubtype0) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Cosmos => f.write_str("cosmos"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "cosmos" => Ok(Self::Cosmos),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype1`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"stellar\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype1 {
        #[serde(rename = "stellar")]
        Stellar,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype1 {
        fn from(value: &GetWalletsChainTypeSubtype1) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype1 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Stellar => f.write_str("stellar"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "stellar" => Ok(Self::Stellar),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype1 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype10`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype10 {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype10 {
        fn from(value: &GetWalletsChainTypeSubtype10) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype10 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype10 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype10 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype10 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype10 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"sui\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype2 {
        #[serde(rename = "sui")]
        Sui,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype2 {
        fn from(value: &GetWalletsChainTypeSubtype2) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype2 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sui => f.write_str("sui"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sui" => Ok(Self::Sui),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype3`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"tron\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype3 {
        #[serde(rename = "tron")]
        Tron,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype3 {
        fn from(value: &GetWalletsChainTypeSubtype3) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype3 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Tron => f.write_str("tron"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype3 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "tron" => Ok(Self::Tron),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype3 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype3 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype3 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype4`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"bitcoin-segwit\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype4 {
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype4 {
        fn from(value: &GetWalletsChainTypeSubtype4) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype4 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype4 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype4 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype4 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype4 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype5`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"near\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype5 {
        #[serde(rename = "near")]
        Near,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype5 {
        fn from(value: &GetWalletsChainTypeSubtype5) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype5 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Near => f.write_str("near"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype5 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "near" => Ok(Self::Near),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype5 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype5 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype5 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype6`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ton\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype6 {
        #[serde(rename = "ton")]
        Ton,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype6 {
        fn from(value: &GetWalletsChainTypeSubtype6) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype6 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ton => f.write_str("ton"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype6 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ton" => Ok(Self::Ton),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype6 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype6 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype6 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype7`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"starknet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype7 {
        #[serde(rename = "starknet")]
        Starknet,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype7 {
        fn from(value: &GetWalletsChainTypeSubtype7) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype7 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Starknet => f.write_str("starknet"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype7 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "starknet" => Ok(Self::Starknet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype7 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype7 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype7 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype8`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"spark\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype8 {
        #[serde(rename = "spark")]
        Spark,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype8 {
        fn from(value: &GetWalletsChainTypeSubtype8) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype8 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Spark => f.write_str("spark"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype8 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "spark" => Ok(Self::Spark),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype8 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype8 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype8 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsChainTypeSubtype9`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainTypeSubtype9 {
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for GetWalletsChainTypeSubtype9 {
        fn from(value: &GetWalletsChainTypeSubtype9) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for GetWalletsChainTypeSubtype9 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for GetWalletsChainTypeSubtype9 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsChainTypeSubtype9 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainTypeSubtype9 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainTypeSubtype9 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`GetWalletsCursor`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetWalletsCursor(::std::string::String);
    impl ::std::ops::Deref for GetWalletsCursor {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<GetWalletsCursor> for ::std::string::String {
        fn from(value: GetWalletsCursor) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&GetWalletsCursor> for GetWalletsCursor {
        fn from(value: &GetWalletsCursor) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for GetWalletsCursor {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for GetWalletsCursor {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for GetWalletsCursor {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`GetWalletsResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/Wallet\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"next_cursor\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWalletsResponse {
        pub data: ::std::vec::Vec<Wallet>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_cursor: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&GetWalletsResponse> for GetWalletsResponse {
        fn from(value: &GetWalletsResponse) -> Self {
            value.clone()
        }
    }
    impl GetWalletsResponse {
        pub fn builder() -> builder::GetWalletsResponse {
            Default::default()
        }
    }
    #[doc = "The input for HD wallets."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The input for HD wallets.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"encryption_type\","]
    #[doc = "    \"entropy_type\","]
    #[doc = "    \"index\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"description\": \"The address of the wallet to import.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletImportSupportedChains\""]
    #[doc = "    },"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HPKEEncryption\""]
    #[doc = "    },"]
    #[doc = "    \"entropy_type\": {"]
    #[doc = "      \"description\": \"The entropy type of the wallet to import.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"hd\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"index\": {"]
    #[doc = "      \"description\": \"The index of the wallet to import.\","]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HdInitInput {
        #[doc = "The address of the wallet to import."]
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        pub encryption_type: HpkeEncryption,
        #[doc = "The entropy type of the wallet to import."]
        pub entropy_type: HdInitInputEntropyType,
        #[doc = "The index of the wallet to import."]
        pub index: u64,
    }
    impl ::std::convert::From<&HdInitInput> for HdInitInput {
        fn from(value: &HdInitInput) -> Self {
            value.clone()
        }
    }
    impl HdInitInput {
        pub fn builder() -> builder::HdInitInput {
            Default::default()
        }
    }
    #[doc = "The entropy type of the wallet to import."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The entropy type of the wallet to import.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"hd\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum HdInitInputEntropyType {
        #[serde(rename = "hd")]
        Hd,
    }
    impl ::std::convert::From<&Self> for HdInitInputEntropyType {
        fn from(value: &HdInitInputEntropyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for HdInitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hd => f.write_str("hd"),
            }
        }
    }
    impl ::std::str::FromStr for HdInitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hd" => Ok(Self::Hd),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for HdInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for HdInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for HdInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`HdSubmitInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"ciphertext\","]
    #[doc = "    \"encapsulated_key\","]
    #[doc = "    \"encryption_type\","]
    #[doc = "    \"entropy_type\","]
    #[doc = "    \"index\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"description\": \"The address of the wallet to import.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletImportSupportedChains\""]
    #[doc = "    },"]
    #[doc = "    \"ciphertext\": {"]
    #[doc = "      \"description\": \"The encrypted entropy of the wallet to import.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encapsulated_key\": {"]
    #[doc = "      \"description\": \"The base64-encoded encapsulated key that was generated during encryption, for use during decryption inside the TEE.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HPKEEncryption\""]
    #[doc = "    },"]
    #[doc = "    \"entropy_type\": {"]
    #[doc = "      \"description\": \"The entropy type of the wallet to import.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"hd\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"index\": {"]
    #[doc = "      \"description\": \"The index of the wallet to import.\","]
    #[doc = "      \"type\": \"integer\","]
    #[doc = "      \"minimum\": 0.0"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HdSubmitInput {
        #[doc = "The address of the wallet to import."]
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        #[doc = "The encrypted entropy of the wallet to import."]
        pub ciphertext: ::std::string::String,
        #[doc = "The base64-encoded encapsulated key that was generated during encryption, for use during decryption inside the TEE."]
        pub encapsulated_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
        #[doc = "The entropy type of the wallet to import."]
        pub entropy_type: HdSubmitInputEntropyType,
        #[doc = "The index of the wallet to import."]
        pub index: u64,
    }
    impl ::std::convert::From<&HdSubmitInput> for HdSubmitInput {
        fn from(value: &HdSubmitInput) -> Self {
            value.clone()
        }
    }
    impl HdSubmitInput {
        pub fn builder() -> builder::HdSubmitInput {
            Default::default()
        }
    }
    #[doc = "The entropy type of the wallet to import."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The entropy type of the wallet to import.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"hd\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum HdSubmitInputEntropyType {
        #[serde(rename = "hd")]
        Hd,
    }
    impl ::std::convert::From<&Self> for HdSubmitInputEntropyType {
        fn from(value: &HdSubmitInputEntropyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for HdSubmitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hd => f.write_str("hd"),
            }
        }
    }
    impl ::std::str::FromStr for HdSubmitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hd" => Ok(Self::Hd),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for HdSubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for HdSubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for HdSubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The encryption type of the wallet to import. Currently only supports `HPKE`."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The encryption type of the wallet to import. Currently only supports `HPKE`.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"HPKE\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum HpkeEncryption {
        #[serde(rename = "HPKE")]
        Hpke,
    }
    impl ::std::convert::From<&Self> for HpkeEncryption {
        fn from(value: &HpkeEncryption) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for HpkeEncryption {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hpke => f.write_str("HPKE"),
            }
        }
    }
    impl ::std::str::FromStr for HpkeEncryption {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "HPKE" => Ok(Self::Hpke),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for HpkeEncryption {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for HpkeEncryption {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for HpkeEncryption {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`KeyQuorum`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"authorization_keys\": ["]
    #[doc = "        {"]
    #[doc = "          \"display_name\": null,"]
    #[doc = "          \"public_key\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/ckqE2CItVIG\\n1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/C9yjhboIuoPD3g==\\n-----END PUBLIC KEY-----\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"display_name\": null,"]
    #[doc = "          \"public_key\": \"-----BEGIN PUBLIC KEY-----\\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAErzZtQr/bMIh3Y8f9ZqseB9i/AfjQ\\nhu+agbNqXcJy/TfoNqvc/Y3Mh7gIZ8ZLXQEykycx4mYSpqrxp1lBKqsZDQ==\\n-----END PUBLIC KEY-----\\\",\""]
    #[doc = "        }"]
    #[doc = "      ],"]
    #[doc = "      \"authorization_threshold\": 1,"]
    #[doc = "      \"display_name\": \"Prod key quorum\","]
    #[doc = "      \"id\": \"tb54eps4z44ed0jepousxi4n\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"authorization_keys\","]
    #[doc = "    \"id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"authorization_keys\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"display_name\","]
    #[doc = "          \"public_key\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"display_name\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ],"]
    #[doc = "            \"maxLength\": 50"]
    #[doc = "          },"]
    #[doc = "          \"public_key\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"authorization_threshold\": {"]
    #[doc = "      \"type\": \"number\","]
    #[doc = "      \"minimum\": 1.0"]
    #[doc = "    },"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 50"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"user_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KeyQuorum {
        pub authorization_keys: ::std::vec::Vec<KeyQuorumAuthorizationKeysItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authorization_threshold: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<KeyQuorumDisplayName>,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub user_ids: ::std::vec::Vec<::std::string::String>,
    }
    impl ::std::convert::From<&KeyQuorum> for KeyQuorum {
        fn from(value: &KeyQuorum) -> Self {
            value.clone()
        }
    }
    impl KeyQuorum {
        pub fn builder() -> builder::KeyQuorum {
            Default::default()
        }
    }
    #[doc = "`KeyQuorumAuthorizationKeysItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"display_name\","]
    #[doc = "    \"public_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 50"]
    #[doc = "    },"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KeyQuorumAuthorizationKeysItem {
        pub display_name: ::std::option::Option<KeyQuorumAuthorizationKeysItemDisplayName>,
        pub public_key: ::std::string::String,
    }
    impl ::std::convert::From<&KeyQuorumAuthorizationKeysItem> for KeyQuorumAuthorizationKeysItem {
        fn from(value: &KeyQuorumAuthorizationKeysItem) -> Self {
            value.clone()
        }
    }
    impl KeyQuorumAuthorizationKeysItem {
        pub fn builder() -> builder::KeyQuorumAuthorizationKeysItem {
            Default::default()
        }
    }
    #[doc = "`KeyQuorumAuthorizationKeysItemDisplayName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 50"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct KeyQuorumAuthorizationKeysItemDisplayName(::std::string::String);
    impl ::std::ops::Deref for KeyQuorumAuthorizationKeysItemDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<KeyQuorumAuthorizationKeysItemDisplayName> for ::std::string::String {
        fn from(value: KeyQuorumAuthorizationKeysItemDisplayName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&KeyQuorumAuthorizationKeysItemDisplayName>
        for KeyQuorumAuthorizationKeysItemDisplayName
    {
        fn from(value: &KeyQuorumAuthorizationKeysItemDisplayName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for KeyQuorumAuthorizationKeysItemDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for KeyQuorumAuthorizationKeysItemDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for KeyQuorumAuthorizationKeysItemDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for KeyQuorumAuthorizationKeysItemDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for KeyQuorumAuthorizationKeysItemDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`KeyQuorumDisplayName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 50"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct KeyQuorumDisplayName(::std::string::String);
    impl ::std::ops::Deref for KeyQuorumDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<KeyQuorumDisplayName> for ::std::string::String {
        fn from(value: KeyQuorumDisplayName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&KeyQuorumDisplayName> for KeyQuorumDisplayName {
        fn from(value: &KeyQuorumDisplayName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for KeyQuorumDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for KeyQuorumDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for KeyQuorumDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for KeyQuorumDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for KeyQuorumDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`KycStatus`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"status\","]
    #[doc = "    \"user_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"provider_user_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"not_found\","]
    #[doc = "        \"active\","]
    #[doc = "        \"awaiting_questionnaire\","]
    #[doc = "        \"awaiting_ubo\","]
    #[doc = "        \"incomplete\","]
    #[doc = "        \"not_started\","]
    #[doc = "        \"offboarded\","]
    #[doc = "        \"paused\","]
    #[doc = "        \"rejected\","]
    #[doc = "        \"under_review\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"user_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KycStatus {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub provider_user_id: ::std::option::Option<::std::string::String>,
        pub status: KycStatusStatus,
        pub user_id: ::std::string::String,
    }
    impl ::std::convert::From<&KycStatus> for KycStatus {
        fn from(value: &KycStatus) -> Self {
            value.clone()
        }
    }
    impl KycStatus {
        pub fn builder() -> builder::KycStatus {
            Default::default()
        }
    }
    #[doc = "`KycStatusStatus`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"not_found\","]
    #[doc = "    \"active\","]
    #[doc = "    \"awaiting_questionnaire\","]
    #[doc = "    \"awaiting_ubo\","]
    #[doc = "    \"incomplete\","]
    #[doc = "    \"not_started\","]
    #[doc = "    \"offboarded\","]
    #[doc = "    \"paused\","]
    #[doc = "    \"rejected\","]
    #[doc = "    \"under_review\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum KycStatusStatus {
        #[serde(rename = "not_found")]
        NotFound,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "awaiting_questionnaire")]
        AwaitingQuestionnaire,
        #[serde(rename = "awaiting_ubo")]
        AwaitingUbo,
        #[serde(rename = "incomplete")]
        Incomplete,
        #[serde(rename = "not_started")]
        NotStarted,
        #[serde(rename = "offboarded")]
        Offboarded,
        #[serde(rename = "paused")]
        Paused,
        #[serde(rename = "rejected")]
        Rejected,
        #[serde(rename = "under_review")]
        UnderReview,
    }
    impl ::std::convert::From<&Self> for KycStatusStatus {
        fn from(value: &KycStatusStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for KycStatusStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NotFound => f.write_str("not_found"),
                Self::Active => f.write_str("active"),
                Self::AwaitingQuestionnaire => f.write_str("awaiting_questionnaire"),
                Self::AwaitingUbo => f.write_str("awaiting_ubo"),
                Self::Incomplete => f.write_str("incomplete"),
                Self::NotStarted => f.write_str("not_started"),
                Self::Offboarded => f.write_str("offboarded"),
                Self::Paused => f.write_str("paused"),
                Self::Rejected => f.write_str("rejected"),
                Self::UnderReview => f.write_str("under_review"),
            }
        }
    }
    impl ::std::str::FromStr for KycStatusStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "not_found" => Ok(Self::NotFound),
                "active" => Ok(Self::Active),
                "awaiting_questionnaire" => Ok(Self::AwaitingQuestionnaire),
                "awaiting_ubo" => Ok(Self::AwaitingUbo),
                "incomplete" => Ok(Self::Incomplete),
                "not_started" => Ok(Self::NotStarted),
                "offboarded" => Ok(Self::Offboarded),
                "paused" => Ok(Self::Paused),
                "rejected" => Ok(Self::Rejected),
                "under_review" => Ok(Self::UnderReview),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for KycStatusStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for KycStatusStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for KycStatusStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountAppleInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Apple\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"apple_oauth\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountAppleInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountAppleInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountAppleInputType,
    }
    impl ::std::convert::From<&LinkedAccountAppleInput> for LinkedAccountAppleInput {
        fn from(value: &LinkedAccountAppleInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountAppleInput {
        pub fn builder() -> builder::LinkedAccountAppleInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountAppleInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountAppleInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountAppleInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountAppleInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountAppleInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountAppleInputSubject> for LinkedAccountAppleInputSubject {
        fn from(value: &LinkedAccountAppleInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountAppleInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountAppleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAppleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAppleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountAppleInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountAppleInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"apple_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountAppleInputType {
        #[serde(rename = "apple_oauth")]
        AppleOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountAppleInputType {
        fn from(value: &LinkedAccountAppleInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountAppleInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AppleOauth => f.write_str("apple_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountAppleInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "apple_oauth" => Ok(Self::AppleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountAppleInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAppleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAppleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountAppleOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Apple\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"apple_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountAppleOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountAppleOauthType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountAppleOauth> for LinkedAccountAppleOauth {
        fn from(value: &LinkedAccountAppleOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountAppleOauth {
        pub fn builder() -> builder::LinkedAccountAppleOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountAppleOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"apple_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountAppleOauthType {
        #[serde(rename = "apple_oauth")]
        AppleOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountAppleOauthType {
        fn from(value: &LinkedAccountAppleOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountAppleOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AppleOauth => f.write_str("apple_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountAppleOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "apple_oauth" => Ok(Self::AppleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountAppleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAppleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAppleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountAuthorizationKey`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Authorization Key\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"public_key\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"authorization_key\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountAuthorizationKey {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub public_key: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountAuthorizationKeyType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountAuthorizationKey> for LinkedAccountAuthorizationKey {
        fn from(value: &LinkedAccountAuthorizationKey) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountAuthorizationKey {
        pub fn builder() -> builder::LinkedAccountAuthorizationKey {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountAuthorizationKeyType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"authorization_key\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountAuthorizationKeyType {
        #[serde(rename = "authorization_key")]
        AuthorizationKey,
    }
    impl ::std::convert::From<&Self> for LinkedAccountAuthorizationKeyType {
        fn from(value: &LinkedAccountAuthorizationKeyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountAuthorizationKeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AuthorizationKey => f.write_str("authorization_key"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountAuthorizationKeyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "authorization_key" => Ok(Self::AuthorizationKey),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountAuthorizationKeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAuthorizationKeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAuthorizationKeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinSegwitEmbeddedWallet`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Bitcoin Segwit Embedded Wallet\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_id\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"connector_type\","]
    #[doc = "    \"delegated\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"imported\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"public_key\","]
    #[doc = "    \"recovery_method\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\","]
    #[doc = "    \"wallet_client\","]
    #[doc = "    \"wallet_client_type\","]
    #[doc = "    \"wallet_index\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"bitcoin-segwit\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"connector_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"embedded\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"delegated\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"imported\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"recovery_method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\","]
    #[doc = "        \"user-passcode\","]
    #[doc = "        \"google-drive\","]
    #[doc = "        \"icloud\","]
    #[doc = "        \"recovery-encryption-key\","]
    #[doc = "        \"privy-v2\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"wallet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"wallet_client\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_client_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_index\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountBitcoinSegwitEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountBitcoinSegwitEmbeddedWalletChainType,
        pub connector_type: LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub public_key: ::std::string::String,
        pub recovery_method: LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountBitcoinSegwitEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }
    impl ::std::convert::From<&LinkedAccountBitcoinSegwitEmbeddedWallet>
        for LinkedAccountBitcoinSegwitEmbeddedWallet
    {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWallet) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountBitcoinSegwitEmbeddedWallet {
        pub fn builder() -> builder::LinkedAccountBitcoinSegwitEmbeddedWallet {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountBitcoinSegwitEmbeddedWalletChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"bitcoin-segwit\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"embedded\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\","]
    #[doc = "    \"user-passcode\","]
    #[doc = "    \"google-drive\","]
    #[doc = "    \"icloud\","]
    #[doc = "    \"recovery-encryption-key\","]
    #[doc = "    \"privy-v2\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinSegwitEmbeddedWalletType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinTaprootEmbeddedWallet`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Bitcoin Taproot Embedded Wallet\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_id\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"connector_type\","]
    #[doc = "    \"delegated\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"imported\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"public_key\","]
    #[doc = "    \"recovery_method\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\","]
    #[doc = "    \"wallet_client\","]
    #[doc = "    \"wallet_client_type\","]
    #[doc = "    \"wallet_index\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"bitcoin-taproot\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"connector_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"embedded\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"delegated\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"imported\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"recovery_method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\","]
    #[doc = "        \"user-passcode\","]
    #[doc = "        \"google-drive\","]
    #[doc = "        \"icloud\","]
    #[doc = "        \"recovery-encryption-key\","]
    #[doc = "        \"privy-v2\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"wallet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"wallet_client\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_client_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_index\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountBitcoinTaprootEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountBitcoinTaprootEmbeddedWalletChainType,
        pub connector_type: LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub public_key: ::std::string::String,
        pub recovery_method: LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountBitcoinTaprootEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }
    impl ::std::convert::From<&LinkedAccountBitcoinTaprootEmbeddedWallet>
        for LinkedAccountBitcoinTaprootEmbeddedWallet
    {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWallet) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountBitcoinTaprootEmbeddedWallet {
        pub fn builder() -> builder::LinkedAccountBitcoinTaprootEmbeddedWallet {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountBitcoinTaprootEmbeddedWalletChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"bitcoin-taproot\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        #[serde(rename = "bitcoin-taproot")]
        BitcoinTaproot,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BitcoinTaproot => f.write_str("bitcoin-taproot"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bitcoin-taproot" => Ok(Self::BitcoinTaproot),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"embedded\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\","]
    #[doc = "    \"user-passcode\","]
    #[doc = "    \"google-drive\","]
    #[doc = "    \"icloud\","]
    #[doc = "    \"recovery-encryption-key\","]
    #[doc = "    \"privy-v2\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinTaprootEmbeddedWalletType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountCrossApp`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"CrossApp\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"embedded_wallets\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"provider_app_id\","]
    #[doc = "    \"smart_wallets\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"embedded_wallets\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"address\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"address\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"provider_app_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"smart_wallets\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"address\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"address\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"cross_app\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCrossApp {
        pub embedded_wallets: ::std::vec::Vec<LinkedAccountCrossAppEmbeddedWalletsItem>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub provider_app_id: ::std::string::String,
        pub smart_wallets: ::std::vec::Vec<LinkedAccountCrossAppSmartWalletsItem>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountCrossAppType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountCrossApp> for LinkedAccountCrossApp {
        fn from(value: &LinkedAccountCrossApp) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountCrossApp {
        pub fn builder() -> builder::LinkedAccountCrossApp {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountCrossAppEmbeddedWalletsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCrossAppEmbeddedWalletsItem {
        pub address: ::std::string::String,
    }
    impl ::std::convert::From<&LinkedAccountCrossAppEmbeddedWalletsItem>
        for LinkedAccountCrossAppEmbeddedWalletsItem
    {
        fn from(value: &LinkedAccountCrossAppEmbeddedWalletsItem) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountCrossAppEmbeddedWalletsItem {
        pub fn builder() -> builder::LinkedAccountCrossAppEmbeddedWalletsItem {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountCrossAppSmartWalletsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCrossAppSmartWalletsItem {
        pub address: ::std::string::String,
    }
    impl ::std::convert::From<&LinkedAccountCrossAppSmartWalletsItem>
        for LinkedAccountCrossAppSmartWalletsItem
    {
        fn from(value: &LinkedAccountCrossAppSmartWalletsItem) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountCrossAppSmartWalletsItem {
        pub fn builder() -> builder::LinkedAccountCrossAppSmartWalletsItem {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountCrossAppType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"cross_app\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountCrossAppType {
        #[serde(rename = "cross_app")]
        CrossApp,
    }
    impl ::std::convert::From<&Self> for LinkedAccountCrossAppType {
        fn from(value: &LinkedAccountCrossAppType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountCrossAppType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CrossApp => f.write_str("cross_app"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountCrossAppType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "cross_app" => Ok(Self::CrossApp),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountCrossAppType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCrossAppType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCrossAppType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountCustomJwt`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Custom Jwt\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"custom_user_id\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"custom_user_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"custom_auth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCustomJwt {
        pub custom_user_id: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountCustomJwtType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountCustomJwt> for LinkedAccountCustomJwt {
        fn from(value: &LinkedAccountCustomJwt) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountCustomJwt {
        pub fn builder() -> builder::LinkedAccountCustomJwt {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountCustomJwtInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Custom JWT\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"custom_user_id\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"custom_user_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 256,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"custom_auth\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountCustomJwtInput {
        pub custom_user_id: LinkedAccountCustomJwtInputCustomUserId,
        #[serde(rename = "type")]
        pub type_: LinkedAccountCustomJwtInputType,
    }
    impl ::std::convert::From<&LinkedAccountCustomJwtInput> for LinkedAccountCustomJwtInput {
        fn from(value: &LinkedAccountCustomJwtInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountCustomJwtInput {
        pub fn builder() -> builder::LinkedAccountCustomJwtInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountCustomJwtInputCustomUserId`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 256,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountCustomJwtInputCustomUserId(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountCustomJwtInputCustomUserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountCustomJwtInputCustomUserId> for ::std::string::String {
        fn from(value: LinkedAccountCustomJwtInputCustomUserId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountCustomJwtInputCustomUserId>
        for LinkedAccountCustomJwtInputCustomUserId
    {
        fn from(value: &LinkedAccountCustomJwtInputCustomUserId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountCustomJwtInputCustomUserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountCustomJwtInputCustomUserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCustomJwtInputCustomUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCustomJwtInputCustomUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountCustomJwtInputCustomUserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountCustomJwtInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"custom_auth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountCustomJwtInputType {
        #[serde(rename = "custom_auth")]
        CustomAuth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountCustomJwtInputType {
        fn from(value: &LinkedAccountCustomJwtInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountCustomJwtInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CustomAuth => f.write_str("custom_auth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountCustomJwtInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom_auth" => Ok(Self::CustomAuth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountCustomJwtInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCustomJwtInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCustomJwtInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountCustomJwtType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"custom_auth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountCustomJwtType {
        #[serde(rename = "custom_auth")]
        CustomAuth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountCustomJwtType {
        fn from(value: &LinkedAccountCustomJwtType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountCustomJwtType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CustomAuth => f.write_str("custom_auth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountCustomJwtType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom_auth" => Ok(Self::CustomAuth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountCustomJwtType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCustomJwtType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCustomJwtType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountDiscordInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Discord\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"discord_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountDiscordInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountDiscordInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountDiscordInputType,
        pub username: LinkedAccountDiscordInputUsername,
    }
    impl ::std::convert::From<&LinkedAccountDiscordInput> for LinkedAccountDiscordInput {
        fn from(value: &LinkedAccountDiscordInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountDiscordInput {
        pub fn builder() -> builder::LinkedAccountDiscordInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountDiscordInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountDiscordInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountDiscordInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountDiscordInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountDiscordInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountDiscordInputSubject> for LinkedAccountDiscordInputSubject {
        fn from(value: &LinkedAccountDiscordInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountDiscordInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountDiscordInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountDiscordInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"discord_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountDiscordInputType {
        #[serde(rename = "discord_oauth")]
        DiscordOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountDiscordInputType {
        fn from(value: &LinkedAccountDiscordInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountDiscordInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::DiscordOauth => f.write_str("discord_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountDiscordInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "discord_oauth" => Ok(Self::DiscordOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountDiscordInputUsername`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountDiscordInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountDiscordInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountDiscordInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountDiscordInputUsername) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountDiscordInputUsername>
        for LinkedAccountDiscordInputUsername
    {
        fn from(value: &LinkedAccountDiscordInputUsername) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountDiscordInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err ("doesn't match pattern \"^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$\"" . into ()) ;
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountDiscordInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountDiscordOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Discord\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"discord_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountDiscordOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountDiscordOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountDiscordOauth> for LinkedAccountDiscordOauth {
        fn from(value: &LinkedAccountDiscordOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountDiscordOauth {
        pub fn builder() -> builder::LinkedAccountDiscordOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountDiscordOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"discord_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountDiscordOauthType {
        #[serde(rename = "discord_oauth")]
        DiscordOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountDiscordOauthType {
        fn from(value: &LinkedAccountDiscordOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountDiscordOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::DiscordOauth => f.write_str("discord_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountDiscordOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "discord_oauth" => Ok(Self::DiscordOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEmail`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Email\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"email\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEmail {
        pub address: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEmailType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountEmail> for LinkedAccountEmail {
        fn from(value: &LinkedAccountEmail) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountEmail {
        pub fn builder() -> builder::LinkedAccountEmail {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountEmailInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Email\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"email\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEmailInput {
        pub address: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEmailInputType,
    }
    impl ::std::convert::From<&LinkedAccountEmailInput> for LinkedAccountEmailInput {
        fn from(value: &LinkedAccountEmailInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountEmailInput {
        pub fn builder() -> builder::LinkedAccountEmailInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountEmailInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"email\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEmailInputType {
        #[serde(rename = "email")]
        Email,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEmailInputType {
        fn from(value: &LinkedAccountEmailInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEmailInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEmailInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEmailInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEmailInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEmailInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEmailType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"email\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEmailType {
        #[serde(rename = "email")]
        Email,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEmailType {
        fn from(value: &LinkedAccountEmailType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEmailType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEmailType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEmailType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEmailType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEmailType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereum`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Ethereum\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\","]
    #[doc = "    \"wallet_client\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"connector_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"wallet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"wallet_client\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"unknown\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_client_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEthereum {
        pub address: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id: ::std::option::Option<::std::string::String>,
        pub chain_type: LinkedAccountEthereumChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connector_type: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEthereumType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountEthereumWalletClient,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub wallet_client_type: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&LinkedAccountEthereum> for LinkedAccountEthereum {
        fn from(value: &LinkedAccountEthereum) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountEthereum {
        pub fn builder() -> builder::LinkedAccountEthereum {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountEthereumChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumChainType {
        fn from(value: &LinkedAccountEthereumChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumEmbeddedWallet`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Ethereum Embedded Wallet\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_id\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"connector_type\","]
    #[doc = "    \"delegated\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"imported\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"recovery_method\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\","]
    #[doc = "    \"wallet_client\","]
    #[doc = "    \"wallet_client_type\","]
    #[doc = "    \"wallet_index\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"connector_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"embedded\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"delegated\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"imported\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"recovery_method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\","]
    #[doc = "        \"user-passcode\","]
    #[doc = "        \"google-drive\","]
    #[doc = "        \"icloud\","]
    #[doc = "        \"recovery-encryption-key\","]
    #[doc = "        \"privy-v2\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"wallet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"wallet_client\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_client_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_index\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEthereumEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountEthereumEmbeddedWalletChainType,
        pub connector_type: LinkedAccountEthereumEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub recovery_method: LinkedAccountEthereumEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEthereumEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountEthereumEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountEthereumEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }
    impl ::std::convert::From<&LinkedAccountEthereumEmbeddedWallet>
        for LinkedAccountEthereumEmbeddedWallet
    {
        fn from(value: &LinkedAccountEthereumEmbeddedWallet) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountEthereumEmbeddedWallet {
        pub fn builder() -> builder::LinkedAccountEthereumEmbeddedWallet {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountEthereumEmbeddedWalletChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletChainType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumEmbeddedWalletConnectorType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"embedded\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumEmbeddedWalletRecoveryMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\","]
    #[doc = "    \"user-passcode\","]
    #[doc = "    \"google-drive\","]
    #[doc = "    \"icloud\","]
    #[doc = "    \"recovery-encryption-key\","]
    #[doc = "    \"privy-v2\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumEmbeddedWalletType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumEmbeddedWalletWalletClient`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumEmbeddedWalletWalletClientType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumType {
        #[serde(rename = "wallet")]
        Wallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumType {
        fn from(value: &LinkedAccountEthereumType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountEthereumWalletClient`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"unknown\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumWalletClient {
        #[serde(rename = "unknown")]
        Unknown,
    }
    impl ::std::convert::From<&Self> for LinkedAccountEthereumWalletClient {
        fn from(value: &LinkedAccountEthereumWalletClient) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountEthereumWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => f.write_str("unknown"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountEthereumWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "unknown" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountFarcaster`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Farcaster\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"fid\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"owner_address\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"bio\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"fid\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"homepage_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"owner_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"profile_picture\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"profile_picture_url\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"signer_public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"farcaster\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountFarcaster {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bio: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<::std::string::String>,
        pub fid: f64,
        pub first_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub homepage_url: ::std::option::Option<::std::string::String>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub owner_address: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signer_public_key: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountFarcasterType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountFarcaster> for LinkedAccountFarcaster {
        fn from(value: &LinkedAccountFarcaster) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountFarcaster {
        pub fn builder() -> builder::LinkedAccountFarcaster {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountFarcasterInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Farcaster\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"fid\","]
    #[doc = "    \"owner_address\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"bio\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 256"]
    #[doc = "    },"]
    #[doc = "    \"display_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 32"]
    #[doc = "    },"]
    #[doc = "    \"fid\": {"]
    #[doc = "      \"type\": \"integer\""]
    #[doc = "    },"]
    #[doc = "    \"homepage_url\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 256"]
    #[doc = "    },"]
    #[doc = "    \"owner_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"profile_picture_url\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 256"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"farcaster\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 256"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountFarcasterInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bio: ::std::option::Option<LinkedAccountFarcasterInputBio>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<LinkedAccountFarcasterInputDisplayName>,
        pub fid: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub homepage_url: ::std::option::Option<LinkedAccountFarcasterInputHomepageUrl>,
        pub owner_address: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url:
            ::std::option::Option<LinkedAccountFarcasterInputProfilePictureUrl>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountFarcasterInputType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<LinkedAccountFarcasterInputUsername>,
    }
    impl ::std::convert::From<&LinkedAccountFarcasterInput> for LinkedAccountFarcasterInput {
        fn from(value: &LinkedAccountFarcasterInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountFarcasterInput {
        pub fn builder() -> builder::LinkedAccountFarcasterInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountFarcasterInputBio`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 256"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputBio(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputBio {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountFarcasterInputBio> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputBio) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountFarcasterInputBio> for LinkedAccountFarcasterInputBio {
        fn from(value: &LinkedAccountFarcasterInputBio) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountFarcasterInputBio {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputBio {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputBio {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputBio {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputBio {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountFarcasterInputDisplayName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 32"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputDisplayName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountFarcasterInputDisplayName> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputDisplayName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountFarcasterInputDisplayName>
        for LinkedAccountFarcasterInputDisplayName
    {
        fn from(value: &LinkedAccountFarcasterInputDisplayName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountFarcasterInputDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 32usize {
                return Err("longer than 32 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountFarcasterInputHomepageUrl`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 256"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputHomepageUrl(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputHomepageUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountFarcasterInputHomepageUrl> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputHomepageUrl) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountFarcasterInputHomepageUrl>
        for LinkedAccountFarcasterInputHomepageUrl
    {
        fn from(value: &LinkedAccountFarcasterInputHomepageUrl) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountFarcasterInputHomepageUrl {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputHomepageUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputHomepageUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputHomepageUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputHomepageUrl {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountFarcasterInputProfilePictureUrl`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 256"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputProfilePictureUrl(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputProfilePictureUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountFarcasterInputProfilePictureUrl> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputProfilePictureUrl) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountFarcasterInputProfilePictureUrl>
        for LinkedAccountFarcasterInputProfilePictureUrl
    {
        fn from(value: &LinkedAccountFarcasterInputProfilePictureUrl) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountFarcasterInputProfilePictureUrl {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputProfilePictureUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountFarcasterInputProfilePictureUrl
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountFarcasterInputProfilePictureUrl
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputProfilePictureUrl {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountFarcasterInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"farcaster\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountFarcasterInputType {
        #[serde(rename = "farcaster")]
        Farcaster,
    }
    impl ::std::convert::From<&Self> for LinkedAccountFarcasterInputType {
        fn from(value: &LinkedAccountFarcasterInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountFarcasterInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Farcaster => f.write_str("farcaster"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountFarcasterInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "farcaster" => Ok(Self::Farcaster),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountFarcasterInputUsername`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 256"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountFarcasterInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputUsername) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountFarcasterInputUsername>
        for LinkedAccountFarcasterInputUsername
    {
        fn from(value: &LinkedAccountFarcasterInputUsername) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountFarcasterInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountFarcasterType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"farcaster\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountFarcasterType {
        #[serde(rename = "farcaster")]
        Farcaster,
    }
    impl ::std::convert::From<&Self> for LinkedAccountFarcasterType {
        fn from(value: &LinkedAccountFarcasterType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountFarcasterType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Farcaster => f.write_str("farcaster"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountFarcasterType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "farcaster" => Ok(Self::Farcaster),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountGithubInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Github\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"github_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 39,"]
    #[doc = "      \"pattern\": \"^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountGithubInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountGithubInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGithubInputType,
        pub username: LinkedAccountGithubInputUsername,
    }
    impl ::std::convert::From<&LinkedAccountGithubInput> for LinkedAccountGithubInput {
        fn from(value: &LinkedAccountGithubInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountGithubInput {
        pub fn builder() -> builder::LinkedAccountGithubInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountGithubInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountGithubInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountGithubInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountGithubInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountGithubInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountGithubInputSubject> for LinkedAccountGithubInputSubject {
        fn from(value: &LinkedAccountGithubInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountGithubInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountGithubInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountGithubInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"github_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGithubInputType {
        #[serde(rename = "github_oauth")]
        GithubOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountGithubInputType {
        fn from(value: &LinkedAccountGithubInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountGithubInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GithubOauth => f.write_str("github_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountGithubInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "github_oauth" => Ok(Self::GithubOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountGithubInputUsername`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 39,"]
    #[doc = "  \"pattern\": \"^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountGithubInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountGithubInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountGithubInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountGithubInputUsername) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountGithubInputUsername> for LinkedAccountGithubInputUsername {
        fn from(value: &LinkedAccountGithubInputUsername) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountGithubInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 39usize {
                return Err("longer than 39 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountGithubInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountGithubOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Github\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"github_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountGithubOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGithubOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountGithubOauth> for LinkedAccountGithubOauth {
        fn from(value: &LinkedAccountGithubOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountGithubOauth {
        pub fn builder() -> builder::LinkedAccountGithubOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountGithubOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"github_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGithubOauthType {
        #[serde(rename = "github_oauth")]
        GithubOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountGithubOauthType {
        fn from(value: &LinkedAccountGithubOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountGithubOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GithubOauth => f.write_str("github_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountGithubOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "github_oauth" => Ok(Self::GithubOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountGoogleInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Google\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"name\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"google_oauth\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountGoogleInput {
        pub email: ::std::string::String,
        pub name: ::std::string::String,
        pub subject: LinkedAccountGoogleInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGoogleInputType,
    }
    impl ::std::convert::From<&LinkedAccountGoogleInput> for LinkedAccountGoogleInput {
        fn from(value: &LinkedAccountGoogleInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountGoogleInput {
        pub fn builder() -> builder::LinkedAccountGoogleInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountGoogleInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountGoogleInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountGoogleInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountGoogleInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountGoogleInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountGoogleInputSubject> for LinkedAccountGoogleInputSubject {
        fn from(value: &LinkedAccountGoogleInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountGoogleInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountGoogleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGoogleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGoogleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountGoogleInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountGoogleInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"google_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGoogleInputType {
        #[serde(rename = "google_oauth")]
        GoogleOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountGoogleInputType {
        fn from(value: &LinkedAccountGoogleInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountGoogleInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoogleOauth => f.write_str("google_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountGoogleInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "google_oauth" => Ok(Self::GoogleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountGoogleInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGoogleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGoogleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountGoogleOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Google\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"google_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountGoogleOauth {
        pub email: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGoogleOauthType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountGoogleOauth> for LinkedAccountGoogleOauth {
        fn from(value: &LinkedAccountGoogleOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountGoogleOauth {
        pub fn builder() -> builder::LinkedAccountGoogleOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountGoogleOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"google_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGoogleOauthType {
        #[serde(rename = "google_oauth")]
        GoogleOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountGoogleOauthType {
        fn from(value: &LinkedAccountGoogleOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountGoogleOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoogleOauth => f.write_str("google_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountGoogleOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "google_oauth" => Ok(Self::GoogleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountGoogleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGoogleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGoogleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The input for adding a linked account to a user."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"LinkedAccountInput\","]
    #[doc = "  \"description\": \"The input for adding a linked account to a user.\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"address\": \"tom.bombadill@privy.io\","]
    #[doc = "      \"type\": \"email\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountWalletInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountEmailInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountPhoneInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountGoogleInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountTwitterInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountDiscordInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountGithubInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountSpotifyInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountInstagramInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountTiktokInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountLineInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountAppleInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountLinkedInInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountFarcasterInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountTelegramInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountCustomJWTInput\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum LinkedAccountInput {
        WalletInput(LinkedAccountWalletInput),
        EmailInput(LinkedAccountEmailInput),
        PhoneInput(LinkedAccountPhoneInput),
        GoogleInput(LinkedAccountGoogleInput),
        TwitterInput(LinkedAccountTwitterInput),
        DiscordInput(LinkedAccountDiscordInput),
        GithubInput(LinkedAccountGithubInput),
        SpotifyInput(LinkedAccountSpotifyInput),
        InstagramInput(LinkedAccountInstagramInput),
        TiktokInput(LinkedAccountTiktokInput),
        LineInput(LinkedAccountLineInput),
        AppleInput(LinkedAccountAppleInput),
        LinkedInInput(LinkedAccountLinkedInInput),
        FarcasterInput(LinkedAccountFarcasterInput),
        TelegramInput(LinkedAccountTelegramInput),
        CustomJwtInput(LinkedAccountCustomJwtInput),
    }
    impl ::std::convert::From<&Self> for LinkedAccountInput {
        fn from(value: &LinkedAccountInput) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<LinkedAccountWalletInput> for LinkedAccountInput {
        fn from(value: LinkedAccountWalletInput) -> Self {
            Self::WalletInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountEmailInput> for LinkedAccountInput {
        fn from(value: LinkedAccountEmailInput) -> Self {
            Self::EmailInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountPhoneInput> for LinkedAccountInput {
        fn from(value: LinkedAccountPhoneInput) -> Self {
            Self::PhoneInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountGoogleInput> for LinkedAccountInput {
        fn from(value: LinkedAccountGoogleInput) -> Self {
            Self::GoogleInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountTwitterInput> for LinkedAccountInput {
        fn from(value: LinkedAccountTwitterInput) -> Self {
            Self::TwitterInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountDiscordInput> for LinkedAccountInput {
        fn from(value: LinkedAccountDiscordInput) -> Self {
            Self::DiscordInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountGithubInput> for LinkedAccountInput {
        fn from(value: LinkedAccountGithubInput) -> Self {
            Self::GithubInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountSpotifyInput> for LinkedAccountInput {
        fn from(value: LinkedAccountSpotifyInput) -> Self {
            Self::SpotifyInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountInstagramInput> for LinkedAccountInput {
        fn from(value: LinkedAccountInstagramInput) -> Self {
            Self::InstagramInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountTiktokInput> for LinkedAccountInput {
        fn from(value: LinkedAccountTiktokInput) -> Self {
            Self::TiktokInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountLineInput> for LinkedAccountInput {
        fn from(value: LinkedAccountLineInput) -> Self {
            Self::LineInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountAppleInput> for LinkedAccountInput {
        fn from(value: LinkedAccountAppleInput) -> Self {
            Self::AppleInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountLinkedInInput> for LinkedAccountInput {
        fn from(value: LinkedAccountLinkedInInput) -> Self {
            Self::LinkedInInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountFarcasterInput> for LinkedAccountInput {
        fn from(value: LinkedAccountFarcasterInput) -> Self {
            Self::FarcasterInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountTelegramInput> for LinkedAccountInput {
        fn from(value: LinkedAccountTelegramInput) -> Self {
            Self::TelegramInput(value)
        }
    }
    impl ::std::convert::From<LinkedAccountCustomJwtInput> for LinkedAccountInput {
        fn from(value: LinkedAccountCustomJwtInput) -> Self {
            Self::CustomJwtInput(value)
        }
    }
    #[doc = "`LinkedAccountInstagramInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Instagram\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"instagram_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountInstagramInput {
        pub subject: LinkedAccountInstagramInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountInstagramInputType,
        pub username: LinkedAccountInstagramInputUsername,
    }
    impl ::std::convert::From<&LinkedAccountInstagramInput> for LinkedAccountInstagramInput {
        fn from(value: &LinkedAccountInstagramInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountInstagramInput {
        pub fn builder() -> builder::LinkedAccountInstagramInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountInstagramInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountInstagramInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountInstagramInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountInstagramInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountInstagramInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountInstagramInputSubject>
        for LinkedAccountInstagramInputSubject
    {
        fn from(value: &LinkedAccountInstagramInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountInstagramInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountInstagramInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountInstagramInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"instagram_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountInstagramInputType {
        #[serde(rename = "instagram_oauth")]
        InstagramOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountInstagramInputType {
        fn from(value: &LinkedAccountInstagramInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountInstagramInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstagramOauth => f.write_str("instagram_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountInstagramInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instagram_oauth" => Ok(Self::InstagramOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountInstagramInputUsername`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountInstagramInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountInstagramInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountInstagramInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountInstagramInputUsername) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountInstagramInputUsername>
        for LinkedAccountInstagramInputUsername
    {
        fn from(value: &LinkedAccountInstagramInputUsername) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountInstagramInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountInstagramInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountInstagramOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Instagram\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"instagram_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountInstagramOauth {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountInstagramOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountInstagramOauth> for LinkedAccountInstagramOauth {
        fn from(value: &LinkedAccountInstagramOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountInstagramOauth {
        pub fn builder() -> builder::LinkedAccountInstagramOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountInstagramOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"instagram_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountInstagramOauthType {
        #[serde(rename = "instagram_oauth")]
        InstagramOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountInstagramOauthType {
        fn from(value: &LinkedAccountInstagramOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountInstagramOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstagramOauth => f.write_str("instagram_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountInstagramOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instagram_oauth" => Ok(Self::InstagramOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountLineInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"LINE\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 30,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"profile_picture_url\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"line_oauth\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountLineInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<LinkedAccountLineInputName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountLineInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLineInputType,
    }
    impl ::std::convert::From<&LinkedAccountLineInput> for LinkedAccountLineInput {
        fn from(value: &LinkedAccountLineInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountLineInput {
        pub fn builder() -> builder::LinkedAccountLineInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountLineInputName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 30,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountLineInputName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountLineInputName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountLineInputName> for ::std::string::String {
        fn from(value: LinkedAccountLineInputName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountLineInputName> for LinkedAccountLineInputName {
        fn from(value: &LinkedAccountLineInputName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountLineInputName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 30usize {
                return Err("longer than 30 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountLineInputName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountLineInputName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountLineInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountLineInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountLineInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountLineInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountLineInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountLineInputSubject> for LinkedAccountLineInputSubject {
        fn from(value: &LinkedAccountLineInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountLineInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountLineInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountLineInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountLineInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"line_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLineInputType {
        #[serde(rename = "line_oauth")]
        LineOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountLineInputType {
        fn from(value: &LinkedAccountLineInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountLineInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LineOauth => f.write_str("line_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountLineInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "line_oauth" => Ok(Self::LineOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountLineInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountLineOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Line\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"profile_picture_url\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"profile_picture_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"line_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountLineOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLineOauthType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountLineOauth> for LinkedAccountLineOauth {
        fn from(value: &LinkedAccountLineOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountLineOauth {
        pub fn builder() -> builder::LinkedAccountLineOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountLineOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"line_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLineOauthType {
        #[serde(rename = "line_oauth")]
        LineOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountLineOauthType {
        fn from(value: &LinkedAccountLineOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountLineOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LineOauth => f.write_str("line_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountLineOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "line_oauth" => Ok(Self::LineOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountLineOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountLinkedInInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"LinkedIn\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"linkedin_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vanityName\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountLinkedInInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountLinkedInInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLinkedInInputType,
        #[serde(
            rename = "vanityName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vanity_name: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&LinkedAccountLinkedInInput> for LinkedAccountLinkedInInput {
        fn from(value: &LinkedAccountLinkedInInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountLinkedInInput {
        pub fn builder() -> builder::LinkedAccountLinkedInInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountLinkedInInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountLinkedInInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountLinkedInInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountLinkedInInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountLinkedInInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountLinkedInInputSubject>
        for LinkedAccountLinkedInInputSubject
    {
        fn from(value: &LinkedAccountLinkedInInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountLinkedInInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountLinkedInInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLinkedInInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLinkedInInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountLinkedInInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountLinkedInInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"linkedin_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLinkedInInputType {
        #[serde(rename = "linkedin_oauth")]
        LinkedinOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountLinkedInInputType {
        fn from(value: &LinkedAccountLinkedInInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountLinkedInInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LinkedinOauth => f.write_str("linkedin_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountLinkedInInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "linkedin_oauth" => Ok(Self::LinkedinOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountLinkedInInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLinkedInInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLinkedInInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountLinkedInOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"LinkedIn\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"linkedin_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"vanity_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountLinkedInOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLinkedInOauthType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vanity_name: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountLinkedInOauth> for LinkedAccountLinkedInOauth {
        fn from(value: &LinkedAccountLinkedInOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountLinkedInOauth {
        pub fn builder() -> builder::LinkedAccountLinkedInOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountLinkedInOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"linkedin_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLinkedInOauthType {
        #[serde(rename = "linkedin_oauth")]
        LinkedinOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountLinkedInOauthType {
        fn from(value: &LinkedAccountLinkedInOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountLinkedInOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LinkedinOauth => f.write_str("linkedin_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountLinkedInOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "linkedin_oauth" => Ok(Self::LinkedinOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountLinkedInOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLinkedInOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLinkedInOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountPasskey`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Passkey\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"credential_id\","]
    #[doc = "    \"enrolled_in_mfa\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"authenticator_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_with_browser\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_with_device\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_with_os\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"credential_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"enrolled_in_mfa\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"passkey\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountPasskey {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authenticator_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_with_browser: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_with_device: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_with_os: ::std::option::Option<::std::string::String>,
        pub credential_id: ::std::string::String,
        pub enrolled_in_mfa: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_key: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountPasskeyType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountPasskey> for LinkedAccountPasskey {
        fn from(value: &LinkedAccountPasskey) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountPasskey {
        pub fn builder() -> builder::LinkedAccountPasskey {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountPasskeyType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"passkey\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountPasskeyType {
        #[serde(rename = "passkey")]
        Passkey,
    }
    impl ::std::convert::From<&Self> for LinkedAccountPasskeyType {
        fn from(value: &LinkedAccountPasskeyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountPasskeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passkey => f.write_str("passkey"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountPasskeyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passkey" => Ok(Self::Passkey),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountPasskeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountPasskeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountPasskeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountPhone`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Phone\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"phoneNumber\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"number\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"phoneNumber\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"phone\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountPhone {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub number: ::std::option::Option<::std::string::String>,
        #[serde(rename = "phoneNumber")]
        pub phone_number: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountPhoneType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountPhone> for LinkedAccountPhone {
        fn from(value: &LinkedAccountPhone) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountPhone {
        pub fn builder() -> builder::LinkedAccountPhone {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountPhoneInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Phone\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"number\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"number\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"phone\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountPhoneInput {
        pub number: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountPhoneInputType,
    }
    impl ::std::convert::From<&LinkedAccountPhoneInput> for LinkedAccountPhoneInput {
        fn from(value: &LinkedAccountPhoneInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountPhoneInput {
        pub fn builder() -> builder::LinkedAccountPhoneInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountPhoneInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"phone\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountPhoneInputType {
        #[serde(rename = "phone")]
        Phone,
    }
    impl ::std::convert::From<&Self> for LinkedAccountPhoneInputType {
        fn from(value: &LinkedAccountPhoneInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountPhoneInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Phone => f.write_str("phone"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountPhoneInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "phone" => Ok(Self::Phone),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountPhoneInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountPhoneInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountPhoneInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountPhoneType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"phone\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountPhoneType {
        #[serde(rename = "phone")]
        Phone,
    }
    impl ::std::convert::From<&Self> for LinkedAccountPhoneType {
        fn from(value: &LinkedAccountPhoneType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountPhoneType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Phone => f.write_str("phone"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountPhoneType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "phone" => Ok(Self::Phone),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountPhoneType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountPhoneType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountPhoneType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSmartWallet`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Smart Wallet\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"smart_wallet_type\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"smart_wallet_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"safe\","]
    #[doc = "        \"kernel\","]
    #[doc = "        \"biconomy\","]
    #[doc = "        \"light_account\","]
    #[doc = "        \"coinbase_smart_wallet\","]
    #[doc = "        \"thirdweb\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"smart_wallet_version\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"smart_wallet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSmartWallet {
        pub address: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub smart_wallet_type: LinkedAccountSmartWalletSmartWalletType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub smart_wallet_version: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSmartWalletType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountSmartWallet> for LinkedAccountSmartWallet {
        fn from(value: &LinkedAccountSmartWallet) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountSmartWallet {
        pub fn builder() -> builder::LinkedAccountSmartWallet {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountSmartWalletSmartWalletType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"safe\","]
    #[doc = "    \"kernel\","]
    #[doc = "    \"biconomy\","]
    #[doc = "    \"light_account\","]
    #[doc = "    \"coinbase_smart_wallet\","]
    #[doc = "    \"thirdweb\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSmartWalletSmartWalletType {
        #[serde(rename = "safe")]
        Safe,
        #[serde(rename = "kernel")]
        Kernel,
        #[serde(rename = "biconomy")]
        Biconomy,
        #[serde(rename = "light_account")]
        LightAccount,
        #[serde(rename = "coinbase_smart_wallet")]
        CoinbaseSmartWallet,
        #[serde(rename = "thirdweb")]
        Thirdweb,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSmartWalletSmartWalletType {
        fn from(value: &LinkedAccountSmartWalletSmartWalletType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSmartWalletSmartWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Safe => f.write_str("safe"),
                Self::Kernel => f.write_str("kernel"),
                Self::Biconomy => f.write_str("biconomy"),
                Self::LightAccount => f.write_str("light_account"),
                Self::CoinbaseSmartWallet => f.write_str("coinbase_smart_wallet"),
                Self::Thirdweb => f.write_str("thirdweb"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSmartWalletSmartWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "safe" => Ok(Self::Safe),
                "kernel" => Ok(Self::Kernel),
                "biconomy" => Ok(Self::Biconomy),
                "light_account" => Ok(Self::LightAccount),
                "coinbase_smart_wallet" => Ok(Self::CoinbaseSmartWallet),
                "thirdweb" => Ok(Self::Thirdweb),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSmartWalletSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSmartWalletSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSmartWalletSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSmartWalletType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"smart_wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSmartWalletType {
        #[serde(rename = "smart_wallet")]
        SmartWallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSmartWalletType {
        fn from(value: &LinkedAccountSmartWalletType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSmartWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SmartWallet => f.write_str("smart_wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSmartWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "smart_wallet" => Ok(Self::SmartWallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolana`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Solana\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\","]
    #[doc = "    \"wallet_client\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"connector_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"wallet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"wallet_client\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"unknown\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_client_type\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSolana {
        pub address: ::std::string::String,
        pub chain_type: LinkedAccountSolanaChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connector_type: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSolanaType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountSolanaWalletClient,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub wallet_client_type: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&LinkedAccountSolana> for LinkedAccountSolana {
        fn from(value: &LinkedAccountSolana) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountSolana {
        pub fn builder() -> builder::LinkedAccountSolana {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountSolanaChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaChainType {
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaChainType {
        fn from(value: &LinkedAccountSolanaChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaEmbeddedWallet`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Solana Embedded Wallet\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_id\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"connector_type\","]
    #[doc = "    \"delegated\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"imported\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"public_key\","]
    #[doc = "    \"recovery_method\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\","]
    #[doc = "    \"wallet_client\","]
    #[doc = "    \"wallet_client_type\","]
    #[doc = "    \"wallet_index\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"connector_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"embedded\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"delegated\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"imported\": {"]
    #[doc = "      \"default\": false,"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"recovery_method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\","]
    #[doc = "        \"user-passcode\","]
    #[doc = "        \"google-drive\","]
    #[doc = "        \"icloud\","]
    #[doc = "        \"recovery-encryption-key\","]
    #[doc = "        \"privy-v2\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"wallet\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"wallet_client\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_client_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"privy\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_index\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSolanaEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountSolanaEmbeddedWalletChainType,
        pub connector_type: LinkedAccountSolanaEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub public_key: ::std::string::String,
        pub recovery_method: LinkedAccountSolanaEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSolanaEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountSolanaEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountSolanaEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }
    impl ::std::convert::From<&LinkedAccountSolanaEmbeddedWallet>
        for LinkedAccountSolanaEmbeddedWallet
    {
        fn from(value: &LinkedAccountSolanaEmbeddedWallet) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountSolanaEmbeddedWallet {
        pub fn builder() -> builder::LinkedAccountSolanaEmbeddedWallet {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountSolanaEmbeddedWalletChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletChainType {
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletChainType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaEmbeddedWalletConnectorType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"embedded\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaEmbeddedWalletRecoveryMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\","]
    #[doc = "    \"user-passcode\","]
    #[doc = "    \"google-drive\","]
    #[doc = "    \"icloud\","]
    #[doc = "    \"recovery-encryption-key\","]
    #[doc = "    \"privy-v2\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaEmbeddedWalletType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaEmbeddedWalletWalletClient`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaEmbeddedWalletWalletClientType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"privy\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaType {
        #[serde(rename = "wallet")]
        Wallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaType {
        fn from(value: &LinkedAccountSolanaType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSolanaWalletClient`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"unknown\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaWalletClient {
        #[serde(rename = "unknown")]
        Unknown,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSolanaWalletClient {
        fn from(value: &LinkedAccountSolanaWalletClient) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSolanaWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => f.write_str("unknown"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSolanaWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "unknown" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSpotifyInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Spotify\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"email\""]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"spotify_oauth\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountSpotifyInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSpotifyInputType,
    }
    impl ::std::convert::From<&LinkedAccountSpotifyInput> for LinkedAccountSpotifyInput {
        fn from(value: &LinkedAccountSpotifyInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountSpotifyInput {
        pub fn builder() -> builder::LinkedAccountSpotifyInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountSpotifyInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"spotify_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSpotifyInputType {
        #[serde(rename = "spotify_oauth")]
        SpotifyOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSpotifyInputType {
        fn from(value: &LinkedAccountSpotifyInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSpotifyInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SpotifyOauth => f.write_str("spotify_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSpotifyInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "spotify_oauth" => Ok(Self::SpotifyOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSpotifyInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSpotifyInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSpotifyInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountSpotifyOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Spotify\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"email\","]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"email\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"spotify_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSpotifyOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSpotifyOauthType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountSpotifyOauth> for LinkedAccountSpotifyOauth {
        fn from(value: &LinkedAccountSpotifyOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountSpotifyOauth {
        pub fn builder() -> builder::LinkedAccountSpotifyOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountSpotifyOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"spotify_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSpotifyOauthType {
        #[serde(rename = "spotify_oauth")]
        SpotifyOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountSpotifyOauthType {
        fn from(value: &LinkedAccountSpotifyOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountSpotifyOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SpotifyOauth => f.write_str("spotify_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountSpotifyOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "spotify_oauth" => Ok(Self::SpotifyOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountSpotifyOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSpotifyOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSpotifyOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountTelegramInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Telegram\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"telegram_user_id\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"first_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255"]
    #[doc = "    },"]
    #[doc = "    \"last_name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255"]
    #[doc = "    },"]
    #[doc = "    \"photo_url\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255"]
    #[doc = "    },"]
    #[doc = "    \"telegram_user_id\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"telegram\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 255"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountTelegramInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_name: ::std::option::Option<LinkedAccountTelegramInputFirstName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_name: ::std::option::Option<LinkedAccountTelegramInputLastName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub photo_url: ::std::option::Option<LinkedAccountTelegramInputPhotoUrl>,
        pub telegram_user_id: LinkedAccountTelegramInputTelegramUserId,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTelegramInputType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<LinkedAccountTelegramInputUsername>,
    }
    impl ::std::convert::From<&LinkedAccountTelegramInput> for LinkedAccountTelegramInput {
        fn from(value: &LinkedAccountTelegramInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountTelegramInput {
        pub fn builder() -> builder::LinkedAccountTelegramInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountTelegramInputFirstName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputFirstName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTelegramInputFirstName> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputFirstName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTelegramInputFirstName>
        for LinkedAccountTelegramInputFirstName
    {
        fn from(value: &LinkedAccountTelegramInputFirstName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTelegramInputFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTelegramInputLastName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputLastName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTelegramInputLastName> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputLastName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTelegramInputLastName>
        for LinkedAccountTelegramInputLastName
    {
        fn from(value: &LinkedAccountTelegramInputLastName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTelegramInputLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTelegramInputPhotoUrl`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputPhotoUrl(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputPhotoUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTelegramInputPhotoUrl> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputPhotoUrl) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTelegramInputPhotoUrl>
        for LinkedAccountTelegramInputPhotoUrl
    {
        fn from(value: &LinkedAccountTelegramInputPhotoUrl) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTelegramInputPhotoUrl {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputPhotoUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputPhotoUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputPhotoUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputPhotoUrl {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTelegramInputTelegramUserId`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputTelegramUserId(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputTelegramUserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTelegramInputTelegramUserId> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputTelegramUserId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTelegramInputTelegramUserId>
        for LinkedAccountTelegramInputTelegramUserId
    {
        fn from(value: &LinkedAccountTelegramInputTelegramUserId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTelegramInputTelegramUserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputTelegramUserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputTelegramUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputTelegramUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputTelegramUserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTelegramInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"telegram\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTelegramInputType {
        #[serde(rename = "telegram")]
        Telegram,
    }
    impl ::std::convert::From<&Self> for LinkedAccountTelegramInputType {
        fn from(value: &LinkedAccountTelegramInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountTelegramInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Telegram => f.write_str("telegram"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountTelegramInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "telegram" => Ok(Self::Telegram),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountTelegramInputUsername`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 255"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTelegramInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputUsername) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTelegramInputUsername>
        for LinkedAccountTelegramInputUsername
    {
        fn from(value: &LinkedAccountTelegramInputUsername) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTelegramInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTiktokInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Tiktok\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ],"]
    #[doc = "      \"maxLength\": 30,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"tiktok_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountTiktokInput {
        pub name: ::std::option::Option<LinkedAccountTiktokInputName>,
        pub subject: LinkedAccountTiktokInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTiktokInputType,
        pub username: LinkedAccountTiktokInputUsername,
    }
    impl ::std::convert::From<&LinkedAccountTiktokInput> for LinkedAccountTiktokInput {
        fn from(value: &LinkedAccountTiktokInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountTiktokInput {
        pub fn builder() -> builder::LinkedAccountTiktokInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountTiktokInputName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 30,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTiktokInputName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTiktokInputName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTiktokInputName> for ::std::string::String {
        fn from(value: LinkedAccountTiktokInputName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTiktokInputName> for LinkedAccountTiktokInputName {
        fn from(value: &LinkedAccountTiktokInputName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTiktokInputName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 30usize {
                return Err("longer than 30 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTiktokInputName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTiktokInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTiktokInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTiktokInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTiktokInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountTiktokInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTiktokInputSubject> for LinkedAccountTiktokInputSubject {
        fn from(value: &LinkedAccountTiktokInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTiktokInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTiktokInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTiktokInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"tiktok_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTiktokInputType {
        #[serde(rename = "tiktok_oauth")]
        TiktokOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountTiktokInputType {
        fn from(value: &LinkedAccountTiktokInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountTiktokInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TiktokOauth => f.write_str("tiktok_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountTiktokInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "tiktok_oauth" => Ok(Self::TiktokOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountTiktokInputUsername`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTiktokInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTiktokInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTiktokInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountTiktokInputUsername) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTiktokInputUsername> for LinkedAccountTiktokInputUsername {
        fn from(value: &LinkedAccountTiktokInputUsername) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTiktokInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTiktokInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTiktokOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Tiktok\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"tiktok_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTiktokOauth {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTiktokOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountTiktokOauth> for LinkedAccountTiktokOauth {
        fn from(value: &LinkedAccountTiktokOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountTiktokOauth {
        pub fn builder() -> builder::LinkedAccountTiktokOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountTiktokOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"tiktok_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTiktokOauthType {
        #[serde(rename = "tiktok_oauth")]
        TiktokOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountTiktokOauthType {
        fn from(value: &LinkedAccountTiktokOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountTiktokOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TiktokOauth => f.write_str("tiktok_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountTiktokOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "tiktok_oauth" => Ok(Self::TiktokOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountTwitterInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Twitter\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"name\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 50,"]
    #[doc = "      \"minLength\": 1"]
    #[doc = "    },"]
    #[doc = "    \"profile_picture_url\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"format\": \"uri\""]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"twitter_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[0-9a-zA-Z|\\\\_]{1,15}$\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct LinkedAccountTwitterInput {
        pub name: LinkedAccountTwitterInputName,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountTwitterInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTwitterInputType,
        pub username: LinkedAccountTwitterInputUsername,
    }
    impl ::std::convert::From<&LinkedAccountTwitterInput> for LinkedAccountTwitterInput {
        fn from(value: &LinkedAccountTwitterInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountTwitterInput {
        pub fn builder() -> builder::LinkedAccountTwitterInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountTwitterInputName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 50,"]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTwitterInputName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTwitterInputName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTwitterInputName> for ::std::string::String {
        fn from(value: LinkedAccountTwitterInputName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTwitterInputName> for LinkedAccountTwitterInputName {
        fn from(value: &LinkedAccountTwitterInputName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTwitterInputName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTwitterInputName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTwitterInputSubject`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[\\\\x00-\\\\x7F]{1,256}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTwitterInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTwitterInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTwitterInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountTwitterInputSubject) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTwitterInputSubject> for LinkedAccountTwitterInputSubject {
        fn from(value: &LinkedAccountTwitterInputSubject) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTwitterInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTwitterInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTwitterInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"twitter_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTwitterInputType {
        #[serde(rename = "twitter_oauth")]
        TwitterOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountTwitterInputType {
        fn from(value: &LinkedAccountTwitterInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountTwitterInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TwitterOauth => f.write_str("twitter_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountTwitterInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "twitter_oauth" => Ok(Self::TwitterOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountTwitterInputUsername`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[0-9a-zA-Z|\\\\_]{1,15}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTwitterInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTwitterInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<LinkedAccountTwitterInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountTwitterInputUsername) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&LinkedAccountTwitterInputUsername>
        for LinkedAccountTwitterInputUsername
    {
        fn from(value: &LinkedAccountTwitterInputUsername) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for LinkedAccountTwitterInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[0-9a-zA-Z|\\_]{1,15}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[0-9a-zA-Z|\\_]{1,15}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTwitterInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`LinkedAccountTwitterOauth`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Twitter\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"first_verified_at\","]
    #[doc = "    \"latest_verified_at\","]
    #[doc = "    \"name\","]
    #[doc = "    \"profile_picture_url\","]
    #[doc = "    \"subject\","]
    #[doc = "    \"type\","]
    #[doc = "    \"username\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"first_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"latest_verified_at\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"profile_picture_url\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"subject\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"twitter_oauth\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"username\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTwitterOauth {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTwitterOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&LinkedAccountTwitterOauth> for LinkedAccountTwitterOauth {
        fn from(value: &LinkedAccountTwitterOauth) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountTwitterOauth {
        pub fn builder() -> builder::LinkedAccountTwitterOauth {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountTwitterOauthType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"twitter_oauth\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTwitterOauthType {
        #[serde(rename = "twitter_oauth")]
        TwitterOauth,
    }
    impl ::std::convert::From<&Self> for LinkedAccountTwitterOauthType {
        fn from(value: &LinkedAccountTwitterOauthType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountTwitterOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TwitterOauth => f.write_str("twitter_oauth"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountTwitterOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "twitter_oauth" => Ok(Self::TwitterOauth),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountWalletInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Wallet\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\","]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"wallet\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountWalletInput {
        pub address: LinkedAccountWalletInputAddress,
        pub chain_type: LinkedAccountWalletInputChainType,
        #[serde(rename = "type")]
        pub type_: LinkedAccountWalletInputType,
    }
    impl ::std::convert::From<&LinkedAccountWalletInput> for LinkedAccountWalletInput {
        fn from(value: &LinkedAccountWalletInput) -> Self {
            value.clone()
        }
    }
    impl LinkedAccountWalletInput {
        pub fn builder() -> builder::LinkedAccountWalletInput {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountWalletInputAddress`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountWalletInputAddress {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<::std::string::String>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&LinkedAccountWalletInputAddress> for LinkedAccountWalletInputAddress {
        fn from(value: &LinkedAccountWalletInputAddress) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for LinkedAccountWalletInputAddress {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
            }
        }
    }
    impl LinkedAccountWalletInputAddress {
        pub fn builder() -> builder::LinkedAccountWalletInputAddress {
            Default::default()
        }
    }
    #[doc = "`LinkedAccountWalletInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountWalletInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for LinkedAccountWalletInputChainType {
        fn from(value: &LinkedAccountWalletInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountWalletInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountWalletInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountWalletInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountWalletInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountWalletInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`LinkedAccountWalletInputType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountWalletInputType {
        #[serde(rename = "wallet")]
        Wallet,
    }
    impl ::std::convert::From<&Self> for LinkedAccountWalletInputType {
        fn from(value: &LinkedAccountWalletInputType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for LinkedAccountWalletInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }
    impl ::std::str::FromStr for LinkedAccountWalletInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for LinkedAccountWalletInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountWalletInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountWalletInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`Offramp`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"deposit_instructions\","]
    #[doc = "    \"id\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"deposit_instructions\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"amount\","]
    #[doc = "        \"chain\","]
    #[doc = "        \"currency\","]
    #[doc = "        \"from_address\","]
    #[doc = "        \"to_address\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"amount\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"chain\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"ethereum\","]
    #[doc = "            \"base\","]
    #[doc = "            \"arbitrum\","]
    #[doc = "            \"polygon\","]
    #[doc = "            \"optimism\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"currency\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"usdc\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"from_address\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"to_address\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"awaiting_funds\","]
    #[doc = "        \"in_review\","]
    #[doc = "        \"funds_received\","]
    #[doc = "        \"payment_submitted\","]
    #[doc = "        \"payment_processed\","]
    #[doc = "        \"canceled\","]
    #[doc = "        \"error\","]
    #[doc = "        \"undeliverable\","]
    #[doc = "        \"returned\","]
    #[doc = "        \"refunded\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Offramp {
        pub deposit_instructions: OfframpDepositInstructions,
        pub id: ::std::string::String,
        pub status: OfframpStatus,
    }
    impl ::std::convert::From<&Offramp> for Offramp {
        fn from(value: &Offramp) -> Self {
            value.clone()
        }
    }
    impl Offramp {
        pub fn builder() -> builder::Offramp {
            Default::default()
        }
    }
    #[doc = "`OfframpDepositInstructions`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"amount\","]
    #[doc = "    \"chain\","]
    #[doc = "    \"currency\","]
    #[doc = "    \"from_address\","]
    #[doc = "    \"to_address\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"amount\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ethereum\","]
    #[doc = "        \"base\","]
    #[doc = "        \"arbitrum\","]
    #[doc = "        \"polygon\","]
    #[doc = "        \"optimism\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"currency\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"usdc\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"from_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"to_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OfframpDepositInstructions {
        pub amount: ::std::string::String,
        pub chain: OfframpDepositInstructionsChain,
        pub currency: OfframpDepositInstructionsCurrency,
        pub from_address: ::std::string::String,
        pub to_address: ::std::string::String,
    }
    impl ::std::convert::From<&OfframpDepositInstructions> for OfframpDepositInstructions {
        fn from(value: &OfframpDepositInstructions) -> Self {
            value.clone()
        }
    }
    impl OfframpDepositInstructions {
        pub fn builder() -> builder::OfframpDepositInstructions {
            Default::default()
        }
    }
    #[doc = "`OfframpDepositInstructionsChain`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"base\","]
    #[doc = "    \"arbitrum\","]
    #[doc = "    \"polygon\","]
    #[doc = "    \"optimism\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OfframpDepositInstructionsChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
    }
    impl ::std::convert::From<&Self> for OfframpDepositInstructionsChain {
        fn from(value: &OfframpDepositInstructionsChain) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OfframpDepositInstructionsChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Base => f.write_str("base"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
            }
        }
    }
    impl ::std::str::FromStr for OfframpDepositInstructionsChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "base" => Ok(Self::Base),
                "arbitrum" => Ok(Self::Arbitrum),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OfframpDepositInstructionsChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OfframpDepositInstructionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OfframpDepositInstructionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`OfframpDepositInstructionsCurrency`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OfframpDepositInstructionsCurrency {
        #[serde(rename = "usdc")]
        Usdc,
    }
    impl ::std::convert::From<&Self> for OfframpDepositInstructionsCurrency {
        fn from(value: &OfframpDepositInstructionsCurrency) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OfframpDepositInstructionsCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
            }
        }
    }
    impl ::std::str::FromStr for OfframpDepositInstructionsCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OfframpDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OfframpDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OfframpDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`OfframpStatus`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"awaiting_funds\","]
    #[doc = "    \"in_review\","]
    #[doc = "    \"funds_received\","]
    #[doc = "    \"payment_submitted\","]
    #[doc = "    \"payment_processed\","]
    #[doc = "    \"canceled\","]
    #[doc = "    \"error\","]
    #[doc = "    \"undeliverable\","]
    #[doc = "    \"returned\","]
    #[doc = "    \"refunded\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OfframpStatus {
        #[serde(rename = "awaiting_funds")]
        AwaitingFunds,
        #[serde(rename = "in_review")]
        InReview,
        #[serde(rename = "funds_received")]
        FundsReceived,
        #[serde(rename = "payment_submitted")]
        PaymentSubmitted,
        #[serde(rename = "payment_processed")]
        PaymentProcessed,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "undeliverable")]
        Undeliverable,
        #[serde(rename = "returned")]
        Returned,
        #[serde(rename = "refunded")]
        Refunded,
    }
    impl ::std::convert::From<&Self> for OfframpStatus {
        fn from(value: &OfframpStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OfframpStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwaitingFunds => f.write_str("awaiting_funds"),
                Self::InReview => f.write_str("in_review"),
                Self::FundsReceived => f.write_str("funds_received"),
                Self::PaymentSubmitted => f.write_str("payment_submitted"),
                Self::PaymentProcessed => f.write_str("payment_processed"),
                Self::Canceled => f.write_str("canceled"),
                Self::Error => f.write_str("error"),
                Self::Undeliverable => f.write_str("undeliverable"),
                Self::Returned => f.write_str("returned"),
                Self::Refunded => f.write_str("refunded"),
            }
        }
    }
    impl ::std::str::FromStr for OfframpStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awaiting_funds" => Ok(Self::AwaitingFunds),
                "in_review" => Ok(Self::InReview),
                "funds_received" => Ok(Self::FundsReceived),
                "payment_submitted" => Ok(Self::PaymentSubmitted),
                "payment_processed" => Ok(Self::PaymentProcessed),
                "canceled" => Ok(Self::Canceled),
                "error" => Ok(Self::Error),
                "undeliverable" => Ok(Self::Undeliverable),
                "returned" => Ok(Self::Returned),
                "refunded" => Ok(Self::Refunded),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OfframpStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OfframpStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OfframpStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`Onramp`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"deposit_instructions\","]
    #[doc = "    \"id\","]
    #[doc = "    \"status\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"deposit_instructions\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"amount\","]
    #[doc = "        \"currency\","]
    #[doc = "        \"payment_rail\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"account_holder_name\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"amount\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"bank_account_number\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"bank_address\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"bank_beneficiary_address\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"bank_beneficiary_name\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"bank_name\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"bank_routing_number\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"bic\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"currency\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"usd\","]
    #[doc = "            \"eur\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"deposit_message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"iban\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"payment_rail\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"sepa\","]
    #[doc = "            \"ach_push\","]
    #[doc = "            \"wire\""]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"awaiting_funds\","]
    #[doc = "        \"in_review\","]
    #[doc = "        \"funds_received\","]
    #[doc = "        \"payment_submitted\","]
    #[doc = "        \"payment_processed\","]
    #[doc = "        \"canceled\","]
    #[doc = "        \"error\","]
    #[doc = "        \"undeliverable\","]
    #[doc = "        \"returned\","]
    #[doc = "        \"refunded\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Onramp {
        pub deposit_instructions: OnrampDepositInstructions,
        pub id: ::std::string::String,
        pub status: OnrampStatus,
    }
    impl ::std::convert::From<&Onramp> for Onramp {
        fn from(value: &Onramp) -> Self {
            value.clone()
        }
    }
    impl Onramp {
        pub fn builder() -> builder::Onramp {
            Default::default()
        }
    }
    #[doc = "`OnrampDepositInstructions`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"amount\","]
    #[doc = "    \"currency\","]
    #[doc = "    \"payment_rail\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"account_holder_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"amount\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bank_account_number\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bank_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bank_beneficiary_address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bank_beneficiary_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bank_name\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bank_routing_number\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"bic\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"currency\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"usd\","]
    #[doc = "        \"eur\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"deposit_message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"iban\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"payment_rail\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"sepa\","]
    #[doc = "        \"ach_push\","]
    #[doc = "        \"wire\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OnrampDepositInstructions {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_holder_name: ::std::option::Option<::std::string::String>,
        pub amount: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bic: ::std::option::Option<::std::string::String>,
        pub currency: OnrampDepositInstructionsCurrency,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deposit_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub iban: ::std::option::Option<::std::string::String>,
        pub payment_rail: OnrampDepositInstructionsPaymentRail,
    }
    impl ::std::convert::From<&OnrampDepositInstructions> for OnrampDepositInstructions {
        fn from(value: &OnrampDepositInstructions) -> Self {
            value.clone()
        }
    }
    impl OnrampDepositInstructions {
        pub fn builder() -> builder::OnrampDepositInstructions {
            Default::default()
        }
    }
    #[doc = "`OnrampDepositInstructionsCurrency`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usd\","]
    #[doc = "    \"eur\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampDepositInstructionsCurrency {
        #[serde(rename = "usd")]
        Usd,
        #[serde(rename = "eur")]
        Eur,
    }
    impl ::std::convert::From<&Self> for OnrampDepositInstructionsCurrency {
        fn from(value: &OnrampDepositInstructionsCurrency) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampDepositInstructionsCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
                Self::Eur => f.write_str("eur"),
            }
        }
    }
    impl ::std::str::FromStr for OnrampDepositInstructionsCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                "eur" => Ok(Self::Eur),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`OnrampDepositInstructionsPaymentRail`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"sepa\","]
    #[doc = "    \"ach_push\","]
    #[doc = "    \"wire\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampDepositInstructionsPaymentRail {
        #[serde(rename = "sepa")]
        Sepa,
        #[serde(rename = "ach_push")]
        AchPush,
        #[serde(rename = "wire")]
        Wire,
    }
    impl ::std::convert::From<&Self> for OnrampDepositInstructionsPaymentRail {
        fn from(value: &OnrampDepositInstructionsPaymentRail) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampDepositInstructionsPaymentRail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sepa => f.write_str("sepa"),
                Self::AchPush => f.write_str("ach_push"),
                Self::Wire => f.write_str("wire"),
            }
        }
    }
    impl ::std::str::FromStr for OnrampDepositInstructionsPaymentRail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sepa" => Ok(Self::Sepa),
                "ach_push" => Ok(Self::AchPush),
                "wire" => Ok(Self::Wire),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampDepositInstructionsPaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampDepositInstructionsPaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampDepositInstructionsPaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`OnrampStatus`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"awaiting_funds\","]
    #[doc = "    \"in_review\","]
    #[doc = "    \"funds_received\","]
    #[doc = "    \"payment_submitted\","]
    #[doc = "    \"payment_processed\","]
    #[doc = "    \"canceled\","]
    #[doc = "    \"error\","]
    #[doc = "    \"undeliverable\","]
    #[doc = "    \"returned\","]
    #[doc = "    \"refunded\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampStatus {
        #[serde(rename = "awaiting_funds")]
        AwaitingFunds,
        #[serde(rename = "in_review")]
        InReview,
        #[serde(rename = "funds_received")]
        FundsReceived,
        #[serde(rename = "payment_submitted")]
        PaymentSubmitted,
        #[serde(rename = "payment_processed")]
        PaymentProcessed,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "undeliverable")]
        Undeliverable,
        #[serde(rename = "returned")]
        Returned,
        #[serde(rename = "refunded")]
        Refunded,
    }
    impl ::std::convert::From<&Self> for OnrampStatus {
        fn from(value: &OnrampStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for OnrampStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwaitingFunds => f.write_str("awaiting_funds"),
                Self::InReview => f.write_str("in_review"),
                Self::FundsReceived => f.write_str("funds_received"),
                Self::PaymentSubmitted => f.write_str("payment_submitted"),
                Self::PaymentProcessed => f.write_str("payment_processed"),
                Self::Canceled => f.write_str("canceled"),
                Self::Error => f.write_str("error"),
                Self::Undeliverable => f.write_str("undeliverable"),
                Self::Returned => f.write_str("returned"),
                Self::Refunded => f.write_str("refunded"),
            }
        }
    }
    impl ::std::str::FromStr for OnrampStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awaiting_funds" => Ok(Self::AwaitingFunds),
                "in_review" => Ok(Self::InReview),
                "funds_received" => Ok(Self::FundsReceived),
                "payment_submitted" => Ok(Self::PaymentSubmitted),
                "payment_processed" => Ok(Self::PaymentProcessed),
                "canceled" => Ok(Self::Canceled),
                "error" => Ok(Self::Error),
                "undeliverable" => Ok(Self::Undeliverable),
                "returned" => Ok(Self::Returned),
                "refunded" => Ok(Self::Refunded),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for OnrampStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for OnrampStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for OnrampStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The key quorum ID to set as the owner of the resource. If you provide this, do not specify an owner."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The key quorum ID to set as the owner of the resource. If you provide this, do not specify an owner.\","]
    #[doc = "  \"type\": \"string\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct OwnerIdInput(pub ::std::string::String);
    impl ::std::ops::Deref for OwnerIdInput {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<OwnerIdInput> for ::std::string::String {
        fn from(value: OwnerIdInput) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&OwnerIdInput> for OwnerIdInput {
        fn from(value: &OwnerIdInput) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::string::String> for OwnerIdInput {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }
    impl ::std::str::FromStr for OwnerIdInput {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::fmt::Display for OwnerIdInput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }
    #[doc = "The owner of the resource. If you provide this, do not specify an owner_id as it will be generated automatically. When updating a wallet, you can set the owner to null to remove the owner."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The owner of the resource. If you provide this, do not specify an owner_id as it will be generated automatically. When updating a wallet, you can set the owner to null to remove the owner.\","]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"title\": \"Public key owner\","]
    #[doc = "      \"description\": \"The P-256 public key of the owner of the resource. If you provide this, do not specify an owner_id as it will be generated automatically.\","]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"public_key\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"public_key\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"title\": \"User owner\","]
    #[doc = "      \"description\": \"The user ID of the owner of the resource. The user must already exist, and this value must start with \\\"did:privy:\\\". If you provide this, do not specify an owner_id as it will be generated automatically.\","]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"user_id\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"user_id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {}"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OwnerInput {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<PublicKeyOwner>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<UserOwner>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_2: ::std::option::Option<::serde_json::Value>,
    }
    impl ::std::convert::From<&OwnerInput> for OwnerInput {
        fn from(value: &OwnerInput) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for OwnerInput {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
                subtype_2: Default::default(),
            }
        }
    }
    impl OwnerInput {
        pub fn builder() -> builder::OwnerInput {
            Default::default()
        }
    }
    #[doc = "`PasskeyMfaMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Passkey\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"passkey\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyMfaMethod {
        #[serde(rename = "type")]
        pub type_: PasskeyMfaMethodType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&PasskeyMfaMethod> for PasskeyMfaMethod {
        fn from(value: &PasskeyMfaMethod) -> Self {
            value.clone()
        }
    }
    impl PasskeyMfaMethod {
        pub fn builder() -> builder::PasskeyMfaMethod {
            Default::default()
        }
    }
    #[doc = "`PasskeyMfaMethodType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"passkey\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PasskeyMfaMethodType {
        #[serde(rename = "passkey")]
        Passkey,
    }
    impl ::std::convert::From<&Self> for PasskeyMfaMethodType {
        fn from(value: &PasskeyMfaMethodType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PasskeyMfaMethodType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passkey => f.write_str("passkey"),
            }
        }
    }
    impl ::std::str::FromStr for PasskeyMfaMethodType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passkey" => Ok(Self::Passkey),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PasskeyMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PasskeyMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PasskeyMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`Policy`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"chain_type\": \"ethereum\","]
    #[doc = "      \"created_at\": 1741833088894,"]
    #[doc = "      \"id\": \"tb54eps4z44ed0jepousxi4n\","]
    #[doc = "      \"name\": \"Allowlisted stablecoins\","]
    #[doc = "      \"owner_id\": null,"]
    #[doc = "      \"rules\": ["]
    #[doc = "        {"]
    #[doc = "          \"action\": \"ALLOW\","]
    #[doc = "          \"conditions\": ["]
    #[doc = "            {"]
    #[doc = "              \"field\": \"to\","]
    #[doc = "              \"field_source\": \"ethereum_transaction\","]
    #[doc = "              \"operator\": \"eq\","]
    #[doc = "              \"value\": \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\""]
    #[doc = "            }"]
    #[doc = "          ],"]
    #[doc = "          \"method\": \"eth_sendTransaction\","]
    #[doc = "          \"name\": \"Allowlist USDC contract on Base\""]
    #[doc = "        }"]
    #[doc = "      ],"]
    #[doc = "      \"version\": \"1.0\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"name\","]
    #[doc = "    \"owner_id\","]
    #[doc = "    \"rules\","]
    #[doc = "    \"version\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/PolicyChainType\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"description\": \"Unix timestamp of when the policy was created in milliseconds.\","]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"description\": \"Unique ID of the created policy. This will be the primary identifier when using the policy in the future.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 24,"]
    #[doc = "      \"minLength\": 24"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"description\": \"Name to assign to policy.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 50"]
    #[doc = "    },"]
    #[doc = "    \"owner_id\": {"]
    #[doc = "      \"description\": \"The key quorum ID of the owner of the policy.\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"rules\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"$ref\": \"#/components/schemas/PolicyRule\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"version\": {"]
    #[doc = "      \"description\": \"Version of the policy. Currently, 1.0 is the only version.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"1.0\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct Policy {
        pub chain_type: PolicyChainType,
        pub created_at: f64,
        #[doc = "Unique ID of the created policy. This will be the primary identifier when using the policy in the future."]
        pub id: PolicyId,
        #[doc = "Name to assign to policy."]
        pub name: PolicyName,
        #[doc = "The key quorum ID of the owner of the policy."]
        pub owner_id: ::std::option::Option<::std::string::String>,
        pub rules: ::std::vec::Vec<PolicyRule>,
        #[doc = "Version of the policy. Currently, 1.0 is the only version."]
        pub version: PolicyVersion,
    }
    impl ::std::convert::From<&Policy> for Policy {
        fn from(value: &Policy) -> Self {
            value.clone()
        }
    }
    impl Policy {
        pub fn builder() -> builder::Policy {
            Default::default()
        }
    }
    #[doc = "The chain type the policy applies to."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The chain type the policy applies to.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for PolicyChainType {
        fn from(value: &PolicyChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PolicyChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for PolicyChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Unique ID of the created policy. This will be the primary identifier when using the policy in the future."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Unique ID of the created policy. This will be the primary identifier when using the policy in the future.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 24,"]
    #[doc = "  \"minLength\": 24"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyId(::std::string::String);
    impl ::std::ops::Deref for PolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PolicyId> for ::std::string::String {
        fn from(value: PolicyId) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PolicyId> for PolicyId {
        fn from(value: &PolicyId) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "Name to assign to policy."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Name to assign to policy.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 50"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyName(::std::string::String);
    impl ::std::ops::Deref for PolicyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PolicyName> for ::std::string::String {
        fn from(value: PolicyName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PolicyName> for PolicyName {
        fn from(value: &PolicyName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PolicyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PolicyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "The rules that apply to each method the policy covers."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Rule\","]
    #[doc = "  \"description\": \"The rules that apply to each method the policy covers.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"action\","]
    #[doc = "    \"conditions\","]
    #[doc = "    \"method\","]
    #[doc = "    \"name\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"action\": {"]
    #[doc = "      \"description\": \"Action to take if the conditions are true.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"ALLOW\","]
    #[doc = "        \"DENY\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"conditions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"title\": \"Condition\","]
    #[doc = "        \"description\": \"A condition that must be true for the rule action to be applied.\","]
    #[doc = "        \"oneOf\": ["]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/EthereumTransactionCondition\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/EthereumCalldataCondition\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/EthereumTypedDataDomainCondition\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/EthereumTypedDataMessageCondition\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/Ethereum7702AuthorizationCondition\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/SolanaProgramInstructionCondition\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/SolanaSystemProgramInstructionCondition\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/SolanaTokenProgramInstructionCondition\""]
    #[doc = "          }"]
    #[doc = "        ]"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"description\": \"Method the rule applies to.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"eth_sendTransaction\","]
    #[doc = "        \"eth_signTransaction\","]
    #[doc = "        \"eth_signTypedData_v4\","]
    #[doc = "        \"eth_sign7702Authorization\","]
    #[doc = "        \"signTransaction\","]
    #[doc = "        \"signAndSendTransaction\","]
    #[doc = "        \"exportPrivateKey\","]
    #[doc = "        \"*\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"name\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"maxLength\": 50"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct PolicyRule {
        #[doc = "Action to take if the conditions are true."]
        pub action: PolicyRuleAction,
        pub conditions: ::std::vec::Vec<Condition>,
        #[doc = "Method the rule applies to."]
        pub method: PolicyRuleMethod,
        pub name: PolicyRuleName,
    }
    impl ::std::convert::From<&PolicyRule> for PolicyRule {
        fn from(value: &PolicyRule) -> Self {
            value.clone()
        }
    }
    impl PolicyRule {
        pub fn builder() -> builder::PolicyRule {
            Default::default()
        }
    }
    #[doc = "Action to take if the conditions are true."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Action to take if the conditions are true.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ALLOW\","]
    #[doc = "    \"DENY\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyRuleAction {
        #[serde(rename = "ALLOW")]
        Allow,
        #[serde(rename = "DENY")]
        Deny,
    }
    impl ::std::convert::From<&Self> for PolicyRuleAction {
        fn from(value: &PolicyRuleAction) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PolicyRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Allow => f.write_str("ALLOW"),
                Self::Deny => f.write_str("DENY"),
            }
        }
    }
    impl ::std::str::FromStr for PolicyRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ALLOW" => Ok(Self::Allow),
                "DENY" => Ok(Self::Deny),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Method the rule applies to."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Method the rule applies to.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"eth_sendTransaction\","]
    #[doc = "    \"eth_signTransaction\","]
    #[doc = "    \"eth_signTypedData_v4\","]
    #[doc = "    \"eth_sign7702Authorization\","]
    #[doc = "    \"signTransaction\","]
    #[doc = "    \"signAndSendTransaction\","]
    #[doc = "    \"exportPrivateKey\","]
    #[doc = "    \"*\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyRuleMethod {
        #[serde(rename = "eth_sendTransaction")]
        EthSendTransaction,
        #[serde(rename = "eth_signTransaction")]
        EthSignTransaction,
        #[serde(rename = "eth_signTypedData_v4")]
        EthSignTypedDataV4,
        #[serde(rename = "eth_sign7702Authorization")]
        EthSign7702Authorization,
        #[serde(rename = "signTransaction")]
        SignTransaction,
        #[serde(rename = "signAndSendTransaction")]
        SignAndSendTransaction,
        #[serde(rename = "exportPrivateKey")]
        ExportPrivateKey,
        #[serde(rename = "*")]
        X,
    }
    impl ::std::convert::From<&Self> for PolicyRuleMethod {
        fn from(value: &PolicyRuleMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PolicyRuleMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSendTransaction => f.write_str("eth_sendTransaction"),
                Self::EthSignTransaction => f.write_str("eth_signTransaction"),
                Self::EthSignTypedDataV4 => f.write_str("eth_signTypedData_v4"),
                Self::EthSign7702Authorization => f.write_str("eth_sign7702Authorization"),
                Self::SignTransaction => f.write_str("signTransaction"),
                Self::SignAndSendTransaction => f.write_str("signAndSendTransaction"),
                Self::ExportPrivateKey => f.write_str("exportPrivateKey"),
                Self::X => f.write_str("*"),
            }
        }
    }
    impl ::std::str::FromStr for PolicyRuleMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sendTransaction" => Ok(Self::EthSendTransaction),
                "eth_signTransaction" => Ok(Self::EthSignTransaction),
                "eth_signTypedData_v4" => Ok(Self::EthSignTypedDataV4),
                "eth_sign7702Authorization" => Ok(Self::EthSign7702Authorization),
                "signTransaction" => Ok(Self::SignTransaction),
                "signAndSendTransaction" => Ok(Self::SignAndSendTransaction),
                "exportPrivateKey" => Ok(Self::ExportPrivateKey),
                "*" => Ok(Self::X),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyRuleMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRuleMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyRuleMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`PolicyRuleName`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 50"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyRuleName(::std::string::String);
    impl ::std::ops::Deref for PolicyRuleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<PolicyRuleName> for ::std::string::String {
        fn from(value: PolicyRuleName) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&PolicyRuleName> for PolicyRuleName {
        fn from(value: &PolicyRuleName) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for PolicyRuleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyRuleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRuleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyRuleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for PolicyRuleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "Version of the policy. Currently, 1.0 is the only version."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Version of the policy. Currently, 1.0 is the only version.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"1.0\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyVersion {
        #[serde(rename = "1.0")]
        X10,
    }
    impl ::std::convert::From<&Self> for PolicyVersion {
        fn from(value: &PolicyVersion) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PolicyVersion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X10 => f.write_str("1.0"),
            }
        }
    }
    impl ::std::str::FromStr for PolicyVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "1.0" => Ok(Self::X10),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PolicyVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PolicyVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PolicyVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The input for private key wallets."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The input for private key wallets.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"encryption_type\","]
    #[doc = "    \"entropy_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"description\": \"The address of the wallet to import.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletImportSupportedChains\""]
    #[doc = "    },"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HPKEEncryption\""]
    #[doc = "    },"]
    #[doc = "    \"entropy_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"private-key\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PrivateKeyInitInput {
        #[doc = "The address of the wallet to import."]
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        pub encryption_type: HpkeEncryption,
        pub entropy_type: PrivateKeyInitInputEntropyType,
    }
    impl ::std::convert::From<&PrivateKeyInitInput> for PrivateKeyInitInput {
        fn from(value: &PrivateKeyInitInput) -> Self {
            value.clone()
        }
    }
    impl PrivateKeyInitInput {
        pub fn builder() -> builder::PrivateKeyInitInput {
            Default::default()
        }
    }
    #[doc = "`PrivateKeyInitInputEntropyType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"private-key\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrivateKeyInitInputEntropyType {
        #[serde(rename = "private-key")]
        PrivateKey,
    }
    impl ::std::convert::From<&Self> for PrivateKeyInitInputEntropyType {
        fn from(value: &PrivateKeyInitInputEntropyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PrivateKeyInitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PrivateKey => f.write_str("private-key"),
            }
        }
    }
    impl ::std::str::FromStr for PrivateKeyInitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "private-key" => Ok(Self::PrivateKey),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PrivateKeyInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PrivateKeyInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrivateKeyInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`PrivateKeySubmitInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"ciphertext\","]
    #[doc = "    \"encapsulated_key\","]
    #[doc = "    \"encryption_type\","]
    #[doc = "    \"entropy_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"description\": \"The address of the wallet to import.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletImportSupportedChains\""]
    #[doc = "    },"]
    #[doc = "    \"ciphertext\": {"]
    #[doc = "      \"description\": \"The encrypted entropy of the wallet to import.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encapsulated_key\": {"]
    #[doc = "      \"description\": \"The base64-encoded encapsulated key that was generated during encryption, for use during decryption inside the TEE.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HPKEEncryption\""]
    #[doc = "    },"]
    #[doc = "    \"entropy_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"private-key\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PrivateKeySubmitInput {
        #[doc = "The address of the wallet to import."]
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        #[doc = "The encrypted entropy of the wallet to import."]
        pub ciphertext: ::std::string::String,
        #[doc = "The base64-encoded encapsulated key that was generated during encryption, for use during decryption inside the TEE."]
        pub encapsulated_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
        pub entropy_type: PrivateKeySubmitInputEntropyType,
    }
    impl ::std::convert::From<&PrivateKeySubmitInput> for PrivateKeySubmitInput {
        fn from(value: &PrivateKeySubmitInput) -> Self {
            value.clone()
        }
    }
    impl PrivateKeySubmitInput {
        pub fn builder() -> builder::PrivateKeySubmitInput {
            Default::default()
        }
    }
    #[doc = "`PrivateKeySubmitInputEntropyType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"private-key\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrivateKeySubmitInputEntropyType {
        #[serde(rename = "private-key")]
        PrivateKey,
    }
    impl ::std::convert::From<&Self> for PrivateKeySubmitInputEntropyType {
        fn from(value: &PrivateKeySubmitInputEntropyType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for PrivateKeySubmitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PrivateKey => f.write_str("private-key"),
            }
        }
    }
    impl ::std::str::FromStr for PrivateKeySubmitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "private-key" => Ok(Self::PrivateKey),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for PrivateKeySubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for PrivateKeySubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for PrivateKeySubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The P-256 public key of the owner of the resource. If you provide this, do not specify an owner_id as it will be generated automatically."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Public key owner\","]
    #[doc = "  \"description\": \"The P-256 public key of the owner of the resource. If you provide this, do not specify an owner_id as it will be generated automatically.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"public_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PublicKeyOwner {
        pub public_key: ::std::string::String,
    }
    impl ::std::convert::From<&PublicKeyOwner> for PublicKeyOwner {
        fn from(value: &PublicKeyOwner) -> Self {
            value.clone()
        }
    }
    impl PublicKeyOwner {
        pub fn builder() -> builder::PublicKeyOwner {
            Default::default()
        }
    }
    #[doc = "`RawSign`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"raw_sign\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"params\": {"]
    #[doc = "        \"hash\": \"0x0775aeed9c9ce6e0fbc4db25c5e4e6368029651c905c286f813126a09025a21e\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"hash\": {"]
    #[doc = "          \"description\": \"The hash to sign. Must start with `0x`.\","]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RawSign {
        pub params: RawSignParams,
    }
    impl ::std::convert::From<&RawSign> for RawSign {
        fn from(value: &RawSign) -> Self {
            value.clone()
        }
    }
    impl RawSign {
        pub fn builder() -> builder::RawSign {
            Default::default()
        }
    }
    #[doc = "`RawSignParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"hash\": {"]
    #[doc = "      \"description\": \"The hash to sign. Must start with `0x`.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RawSignParams {
        #[doc = "The hash to sign. Must start with `0x`."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hash: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&RawSignParams> for RawSignParams {
        fn from(value: &RawSignParams) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for RawSignParams {
        fn default() -> Self {
            Self {
                hash: Default::default(),
            }
        }
    }
    impl RawSignParams {
        pub fn builder() -> builder::RawSignParams {
            Default::default()
        }
    }
    #[doc = "`RawSignResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"signature\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"hex\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"signature\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct RawSignResponse {
        pub data: RawSignResponseData,
    }
    impl ::std::convert::From<&RawSignResponse> for RawSignResponse {
        fn from(value: &RawSignResponse) -> Self {
            value.clone()
        }
    }
    impl RawSignResponse {
        pub fn builder() -> builder::RawSignResponse {
            Default::default()
        }
    }
    #[doc = "`RawSignResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"signature\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"hex\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RawSignResponseData {
        pub encoding: RawSignResponseDataEncoding,
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&RawSignResponseData> for RawSignResponseData {
        fn from(value: &RawSignResponseData) -> Self {
            value.clone()
        }
    }
    impl RawSignResponseData {
        pub fn builder() -> builder::RawSignResponseData {
            Default::default()
        }
    }
    #[doc = "`RawSignResponseDataEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"hex\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RawSignResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }
    impl ::std::convert::From<&Self> for RawSignResponseDataEncoding {
        fn from(value: &RawSignResponseDataEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for RawSignResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }
    impl ::std::str::FromStr for RawSignResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for RawSignResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for RawSignResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for RawSignResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`RuleResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Rule\","]
    #[doc = "  \"description\": \"A rule that defines the conditions and action to take if the conditions are true.\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"action\": \"ALLOW\","]
    #[doc = "      \"conditions\": ["]
    #[doc = "        {"]
    #[doc = "          \"field\": \"to\","]
    #[doc = "          \"field_source\": \"ethereum_transaction\","]
    #[doc = "          \"operator\": \"eq\","]
    #[doc = "          \"value\": \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\""]
    #[doc = "        }"]
    #[doc = "      ],"]
    #[doc = "      \"id\": \"rule_123\","]
    #[doc = "      \"method\": \"eth_sendTransaction\","]
    #[doc = "      \"name\": \"Allowlist USDC contract on Base\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"allOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/PolicyRule\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"id\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum RuleResponse {}
    impl ::std::convert::From<&Self> for RuleResponse {
        fn from(value: &RuleResponse) -> Self {
            value.clone()
        }
    }
    #[doc = "`SearchUsersBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"search_term\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"search_term\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"emails\","]
    #[doc = "        \"phoneNumbers\","]
    #[doc = "        \"walletAddresses\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"emails\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"format\": \"email\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"phoneNumbers\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"walletAddresses\": {"]
    #[doc = "          \"type\": \"array\","]
    #[doc = "          \"items\": {"]
    #[doc = "            \"anyOf\": ["]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              }"]
    #[doc = "            ]"]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SearchUsersBody {
        Variant0 {
            search_term: ::std::string::String,
        },
        Variant1 {
            emails: ::std::vec::Vec<::std::string::String>,
            #[serde(rename = "phoneNumbers")]
            phone_numbers: ::std::vec::Vec<::std::string::String>,
            #[serde(rename = "walletAddresses")]
            wallet_addresses: ::std::vec::Vec<SearchUsersBodyVariant1WalletAddressesItem>,
        },
    }
    impl ::std::convert::From<&Self> for SearchUsersBody {
        fn from(value: &SearchUsersBody) -> Self {
            value.clone()
        }
    }
    #[doc = "`SearchUsersBodyVariant1WalletAddressesItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SearchUsersBodyVariant1WalletAddressesItem {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<::std::string::String>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&SearchUsersBodyVariant1WalletAddressesItem>
        for SearchUsersBodyVariant1WalletAddressesItem
    {
        fn from(value: &SearchUsersBodyVariant1WalletAddressesItem) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for SearchUsersBodyVariant1WalletAddressesItem {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
            }
        }
    }
    impl SearchUsersBodyVariant1WalletAddressesItem {
        pub fn builder() -> builder::SearchUsersBodyVariant1WalletAddressesItem {
            Default::default()
        }
    }
    #[doc = "`SmsMfaMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"SMS\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"sms\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmsMfaMethod {
        #[serde(rename = "type")]
        pub type_: SmsMfaMethodType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&SmsMfaMethod> for SmsMfaMethod {
        fn from(value: &SmsMfaMethod) -> Self {
            value.clone()
        }
    }
    impl SmsMfaMethod {
        pub fn builder() -> builder::SmsMfaMethod {
            Default::default()
        }
    }
    #[doc = "`SmsMfaMethodType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"sms\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SmsMfaMethodType {
        #[serde(rename = "sms")]
        Sms,
    }
    impl ::std::convert::From<&Self> for SmsMfaMethodType {
        fn from(value: &SmsMfaMethodType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SmsMfaMethodType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sms => f.write_str("sms"),
            }
        }
    }
    impl ::std::str::FromStr for SmsMfaMethodType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sms" => Ok(Self::Sms),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SmsMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SmsMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SmsMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Solana Program attributes, enables allowlisting Solana Programs."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"solana_program_instruction\","]
    #[doc = "  \"description\": \"Solana Program attributes, enables allowlisting Solana Programs.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"SolanaProgramInstructionConditionField\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"programId\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana_program_instruction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaProgramInstructionCondition {
        pub field: SolanaProgramInstructionConditionField,
        pub field_source: SolanaProgramInstructionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&SolanaProgramInstructionCondition>
        for SolanaProgramInstructionCondition
    {
        fn from(value: &SolanaProgramInstructionCondition) -> Self {
            value.clone()
        }
    }
    impl SolanaProgramInstructionCondition {
        pub fn builder() -> builder::SolanaProgramInstructionCondition {
            Default::default()
        }
    }
    #[doc = "`SolanaProgramInstructionConditionField`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"SolanaProgramInstructionConditionField\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"programId\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaProgramInstructionConditionField {
        #[serde(rename = "programId")]
        ProgramId,
    }
    impl ::std::convert::From<&Self> for SolanaProgramInstructionConditionField {
        fn from(value: &SolanaProgramInstructionConditionField) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaProgramInstructionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ProgramId => f.write_str("programId"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaProgramInstructionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "programId" => Ok(Self::ProgramId),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaProgramInstructionConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana_program_instruction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaProgramInstructionConditionFieldSource {
        #[serde(rename = "solana_program_instruction")]
        SolanaProgramInstruction,
    }
    impl ::std::convert::From<&Self> for SolanaProgramInstructionConditionFieldSource {
        fn from(value: &SolanaProgramInstructionConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaProgramInstructionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolanaProgramInstruction => f.write_str("solana_program_instruction"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaProgramInstructionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana_program_instruction" => Ok(Self::SolanaProgramInstruction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaProgramInstructionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"caip2\","]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"caip2\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"signAndSendTransaction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"transaction\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"base64\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"transaction\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    },"]
    #[doc = "    \"sponsor\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SolanaSignAndSendTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        pub caip2: SolanaSignAndSendTransactionRpcInputCaip2,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<SolanaSignAndSendTransactionRpcInputChainType>,
        pub method: SolanaSignAndSendTransactionRpcInputMethod,
        pub params: SolanaSignAndSendTransactionRpcInputParams,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsor: ::std::option::Option<bool>,
    }
    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcInput>
        for SolanaSignAndSendTransactionRpcInput
    {
        fn from(value: &SolanaSignAndSendTransactionRpcInput) -> Self {
            value.clone()
        }
    }
    impl SolanaSignAndSendTransactionRpcInput {
        pub fn builder() -> builder::SolanaSignAndSendTransactionRpcInput {
            Default::default()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcInputCaip2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaSignAndSendTransactionRpcInputCaip2(::std::string::String);
    impl ::std::ops::Deref for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolanaSignAndSendTransactionRpcInputCaip2> for ::std::string::String {
        fn from(value: SolanaSignAndSendTransactionRpcInputCaip2) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcInputCaip2>
        for SolanaSignAndSendTransactionRpcInputCaip2
    {
        fn from(value: &SolanaSignAndSendTransactionRpcInputCaip2) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolanaSignAndSendTransactionRpcInputCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcInputChainType {
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcInputChainType {
        fn from(value: &SolanaSignAndSendTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"signAndSendTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcInputMethod {
        #[serde(rename = "signAndSendTransaction")]
        SignAndSendTransaction,
    }
    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcInputMethod {
        fn from(value: &SolanaSignAndSendTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignAndSendTransaction => f.write_str("signAndSendTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signAndSendTransaction" => Ok(Self::SignAndSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcInputMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignAndSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"transaction\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"base64\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"transaction\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SolanaSignAndSendTransactionRpcInputParams {
        pub encoding: SolanaSignAndSendTransactionRpcInputParamsEncoding,
        pub transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcInputParams>
        for SolanaSignAndSendTransactionRpcInputParams
    {
        fn from(value: &SolanaSignAndSendTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl SolanaSignAndSendTransactionRpcInputParams {
        pub fn builder() -> builder::SolanaSignAndSendTransactionRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcInputParamsEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"base64\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcInputParamsEncoding {
        #[serde(rename = "base64")]
        Base64,
    }
    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        fn from(value: &SolanaSignAndSendTransactionRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"caip2\","]
    #[doc = "        \"hash\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"caip2\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "        },"]
    #[doc = "        \"hash\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"transaction_id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"error\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"code\","]
    #[doc = "        \"message\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"code\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"signAndSendTransaction\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignAndSendTransactionRpcResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<SolanaSignAndSendTransactionRpcResponseData>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error: ::std::option::Option<SolanaSignAndSendTransactionRpcResponseError>,
        pub method: SolanaSignAndSendTransactionRpcResponseMethod,
    }
    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcResponse>
        for SolanaSignAndSendTransactionRpcResponse
    {
        fn from(value: &SolanaSignAndSendTransactionRpcResponse) -> Self {
            value.clone()
        }
    }
    impl SolanaSignAndSendTransactionRpcResponse {
        pub fn builder() -> builder::SolanaSignAndSendTransactionRpcResponse {
            Default::default()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"caip2\","]
    #[doc = "    \"hash\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"caip2\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "    },"]
    #[doc = "    \"hash\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"transaction_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignAndSendTransactionRpcResponseData {
        pub caip2: SolanaSignAndSendTransactionRpcResponseDataCaip2,
        pub hash: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_id: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcResponseData>
        for SolanaSignAndSendTransactionRpcResponseData
    {
        fn from(value: &SolanaSignAndSendTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl SolanaSignAndSendTransactionRpcResponseData {
        pub fn builder() -> builder::SolanaSignAndSendTransactionRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcResponseDataCaip2`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"pattern\": \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\""]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaSignAndSendTransactionRpcResponseDataCaip2(::std::string::String);
    impl ::std::ops::Deref for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<SolanaSignAndSendTransactionRpcResponseDataCaip2>
        for ::std::string::String
    {
        fn from(value: SolanaSignAndSendTransactionRpcResponseDataCaip2) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcResponseDataCaip2>
        for SolanaSignAndSendTransactionRpcResponseDataCaip2
    {
        fn from(value: &SolanaSignAndSendTransactionRpcResponseDataCaip2) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcResponseError`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"code\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"code\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignAndSendTransactionRpcResponseError {
        pub code: ::std::string::String,
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcResponseError>
        for SolanaSignAndSendTransactionRpcResponseError
    {
        fn from(value: &SolanaSignAndSendTransactionRpcResponseError) -> Self {
            value.clone()
        }
    }
    impl SolanaSignAndSendTransactionRpcResponseError {
        pub fn builder() -> builder::SolanaSignAndSendTransactionRpcResponseError {
            Default::default()
        }
    }
    #[doc = "`SolanaSignAndSendTransactionRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"signAndSendTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcResponseMethod {
        #[serde(rename = "signAndSendTransaction")]
        SignAndSendTransaction,
    }
    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcResponseMethod {
        fn from(value: &SolanaSignAndSendTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignAndSendTransaction => f.write_str("signAndSendTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signAndSendTransaction" => Ok(Self::SignAndSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignMessageRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"signMessage\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"message\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"base64\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"message\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SolanaSignMessageRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<SolanaSignMessageRpcInputChainType>,
        pub method: SolanaSignMessageRpcInputMethod,
        pub params: SolanaSignMessageRpcInputParams,
    }
    impl ::std::convert::From<&SolanaSignMessageRpcInput> for SolanaSignMessageRpcInput {
        fn from(value: &SolanaSignMessageRpcInput) -> Self {
            value.clone()
        }
    }
    impl SolanaSignMessageRpcInput {
        pub fn builder() -> builder::SolanaSignMessageRpcInput {
            Default::default()
        }
    }
    #[doc = "`SolanaSignMessageRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcInputChainType {
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for SolanaSignMessageRpcInputChainType {
        fn from(value: &SolanaSignMessageRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignMessageRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignMessageRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignMessageRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"signMessage\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcInputMethod {
        #[serde(rename = "signMessage")]
        SignMessage,
    }
    impl ::std::convert::From<&Self> for SolanaSignMessageRpcInputMethod {
        fn from(value: &SolanaSignMessageRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignMessageRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignMessage => f.write_str("signMessage"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignMessageRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signMessage" => Ok(Self::SignMessage),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignMessageRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"message\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"base64\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"message\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SolanaSignMessageRpcInputParams {
        pub encoding: SolanaSignMessageRpcInputParamsEncoding,
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&SolanaSignMessageRpcInputParams> for SolanaSignMessageRpcInputParams {
        fn from(value: &SolanaSignMessageRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl SolanaSignMessageRpcInputParams {
        pub fn builder() -> builder::SolanaSignMessageRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`SolanaSignMessageRpcInputParamsEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"base64\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcInputParamsEncoding {
        #[serde(rename = "base64")]
        Base64,
    }
    impl ::std::convert::From<&Self> for SolanaSignMessageRpcInputParamsEncoding {
        fn from(value: &SolanaSignMessageRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignMessageRpcInputParamsEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignMessageRpcInputParamsEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignMessageRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\","]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"signature\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"base64\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"signature\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"signMessage\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignMessageRpcResponse {
        pub data: SolanaSignMessageRpcResponseData,
        pub method: SolanaSignMessageRpcResponseMethod,
    }
    impl ::std::convert::From<&SolanaSignMessageRpcResponse> for SolanaSignMessageRpcResponse {
        fn from(value: &SolanaSignMessageRpcResponse) -> Self {
            value.clone()
        }
    }
    impl SolanaSignMessageRpcResponse {
        pub fn builder() -> builder::SolanaSignMessageRpcResponse {
            Default::default()
        }
    }
    #[doc = "`SolanaSignMessageRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"signature\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"base64\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signature\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignMessageRpcResponseData {
        pub encoding: SolanaSignMessageRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }
    impl ::std::convert::From<&SolanaSignMessageRpcResponseData> for SolanaSignMessageRpcResponseData {
        fn from(value: &SolanaSignMessageRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl SolanaSignMessageRpcResponseData {
        pub fn builder() -> builder::SolanaSignMessageRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`SolanaSignMessageRpcResponseDataEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"base64\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcResponseDataEncoding {
        #[serde(rename = "base64")]
        Base64,
    }
    impl ::std::convert::From<&Self> for SolanaSignMessageRpcResponseDataEncoding {
        fn from(value: &SolanaSignMessageRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignMessageRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignMessageRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignMessageRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"signMessage\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcResponseMethod {
        #[serde(rename = "signMessage")]
        SignMessage,
    }
    impl ::std::convert::From<&Self> for SolanaSignMessageRpcResponseMethod {
        fn from(value: &SolanaSignMessageRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignMessageRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignMessage => f.write_str("signMessage"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignMessageRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signMessage" => Ok(Self::SignMessage),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignTransactionRpcInput`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"method\","]
    #[doc = "    \"params\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"signTransaction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"params\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"transaction\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"base64\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"transaction\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SolanaSignTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<SolanaSignTransactionRpcInputChainType>,
        pub method: SolanaSignTransactionRpcInputMethod,
        pub params: SolanaSignTransactionRpcInputParams,
    }
    impl ::std::convert::From<&SolanaSignTransactionRpcInput> for SolanaSignTransactionRpcInput {
        fn from(value: &SolanaSignTransactionRpcInput) -> Self {
            value.clone()
        }
    }
    impl SolanaSignTransactionRpcInput {
        pub fn builder() -> builder::SolanaSignTransactionRpcInput {
            Default::default()
        }
    }
    #[doc = "`SolanaSignTransactionRpcInputChainType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcInputChainType {
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcInputChainType {
        fn from(value: &SolanaSignTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignTransactionRpcInputMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"signTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcInputMethod {
        #[serde(rename = "signTransaction")]
        SignTransaction,
    }
    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcInputMethod {
        fn from(value: &SolanaSignTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignTransaction => f.write_str("signTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signTransaction" => Ok(Self::SignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignTransactionRpcInputParams`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"transaction\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"base64\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"transaction\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct SolanaSignTransactionRpcInputParams {
        pub encoding: SolanaSignTransactionRpcInputParamsEncoding,
        pub transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SolanaSignTransactionRpcInputParams>
        for SolanaSignTransactionRpcInputParams
    {
        fn from(value: &SolanaSignTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }
    impl SolanaSignTransactionRpcInputParams {
        pub fn builder() -> builder::SolanaSignTransactionRpcInputParams {
            Default::default()
        }
    }
    #[doc = "`SolanaSignTransactionRpcInputParamsEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"base64\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcInputParamsEncoding {
        #[serde(rename = "base64")]
        Base64,
    }
    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcInputParamsEncoding {
        fn from(value: &SolanaSignTransactionRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignTransactionRpcInputParamsEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignTransactionRpcInputParamsEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignTransactionRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"data\","]
    #[doc = "    \"method\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"data\": {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"encoding\","]
    #[doc = "        \"signed_transaction\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"encoding\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"base64\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"signed_transaction\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"method\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"signTransaction\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignTransactionRpcResponse {
        pub data: SolanaSignTransactionRpcResponseData,
        pub method: SolanaSignTransactionRpcResponseMethod,
    }
    impl ::std::convert::From<&SolanaSignTransactionRpcResponse> for SolanaSignTransactionRpcResponse {
        fn from(value: &SolanaSignTransactionRpcResponse) -> Self {
            value.clone()
        }
    }
    impl SolanaSignTransactionRpcResponse {
        pub fn builder() -> builder::SolanaSignTransactionRpcResponse {
            Default::default()
        }
    }
    #[doc = "`SolanaSignTransactionRpcResponseData`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encoding\","]
    #[doc = "    \"signed_transaction\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encoding\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"base64\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"signed_transaction\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignTransactionRpcResponseData {
        pub encoding: SolanaSignTransactionRpcResponseDataEncoding,
        pub signed_transaction: ::std::string::String,
    }
    impl ::std::convert::From<&SolanaSignTransactionRpcResponseData>
        for SolanaSignTransactionRpcResponseData
    {
        fn from(value: &SolanaSignTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }
    impl SolanaSignTransactionRpcResponseData {
        pub fn builder() -> builder::SolanaSignTransactionRpcResponseData {
            Default::default()
        }
    }
    #[doc = "`SolanaSignTransactionRpcResponseDataEncoding`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"base64\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcResponseDataEncoding {
        #[serde(rename = "base64")]
        Base64,
    }
    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcResponseDataEncoding {
        fn from(value: &SolanaSignTransactionRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignTransactionRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignTransactionRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSignTransactionRpcResponseMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"signTransaction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcResponseMethod {
        #[serde(rename = "signTransaction")]
        SignTransaction,
    }
    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcResponseMethod {
        fn from(value: &SolanaSignTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSignTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignTransaction => f.write_str("signTransaction"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSignTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signTransaction" => Ok(Self::SignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Solana System Program attributes, including more granular Transfer instruction fields."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"solana_system_program_instruction\","]
    #[doc = "  \"description\": \"Solana System Program attributes, including more granular Transfer instruction fields.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"SolanaSystemProgramInstructionConditionField\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"instructionName\","]
    #[doc = "        \"Transfer.from\","]
    #[doc = "        \"Transfer.to\","]
    #[doc = "        \"Transfer.lamports\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana_system_program_instruction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSystemProgramInstructionCondition {
        pub field: SolanaSystemProgramInstructionConditionField,
        pub field_source: SolanaSystemProgramInstructionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&SolanaSystemProgramInstructionCondition>
        for SolanaSystemProgramInstructionCondition
    {
        fn from(value: &SolanaSystemProgramInstructionCondition) -> Self {
            value.clone()
        }
    }
    impl SolanaSystemProgramInstructionCondition {
        pub fn builder() -> builder::SolanaSystemProgramInstructionCondition {
            Default::default()
        }
    }
    #[doc = "`SolanaSystemProgramInstructionConditionField`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"SolanaSystemProgramInstructionConditionField\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"instructionName\","]
    #[doc = "    \"Transfer.from\","]
    #[doc = "    \"Transfer.to\","]
    #[doc = "    \"Transfer.lamports\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSystemProgramInstructionConditionField {
        #[serde(rename = "instructionName")]
        InstructionName,
        #[serde(rename = "Transfer.from")]
        TransferFrom,
        #[serde(rename = "Transfer.to")]
        TransferTo,
        #[serde(rename = "Transfer.lamports")]
        TransferLamports,
    }
    impl ::std::convert::From<&Self> for SolanaSystemProgramInstructionConditionField {
        fn from(value: &SolanaSystemProgramInstructionConditionField) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSystemProgramInstructionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstructionName => f.write_str("instructionName"),
                Self::TransferFrom => f.write_str("Transfer.from"),
                Self::TransferTo => f.write_str("Transfer.to"),
                Self::TransferLamports => f.write_str("Transfer.lamports"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaSystemProgramInstructionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instructionName" => Ok(Self::InstructionName),
                "Transfer.from" => Ok(Self::TransferFrom),
                "Transfer.to" => Ok(Self::TransferTo),
                "Transfer.lamports" => Ok(Self::TransferLamports),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSystemProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSystemProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSystemProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaSystemProgramInstructionConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana_system_program_instruction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSystemProgramInstructionConditionFieldSource {
        #[serde(rename = "solana_system_program_instruction")]
        SolanaSystemProgramInstruction,
    }
    impl ::std::convert::From<&Self> for SolanaSystemProgramInstructionConditionFieldSource {
        fn from(value: &SolanaSystemProgramInstructionConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaSystemProgramInstructionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolanaSystemProgramInstruction => {
                    f.write_str("solana_system_program_instruction")
                }
            }
        }
    }
    impl ::std::str::FromStr for SolanaSystemProgramInstructionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana_system_program_instruction" => Ok(Self::SolanaSystemProgramInstruction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaSystemProgramInstructionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSystemProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSystemProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "Solana Token Program attributes, including more granular TransferChecked instruction fields."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"solana_token_program_instruction\","]
    #[doc = "  \"description\": \"Solana Token Program attributes, including more granular TransferChecked instruction fields.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"field\","]
    #[doc = "    \"field_source\","]
    #[doc = "    \"operator\","]
    #[doc = "    \"value\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"field\": {"]
    #[doc = "      \"title\": \"SolanaTokenProgramInstructionConditionField\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"instructionName\","]
    #[doc = "        \"TransferChecked.source\","]
    #[doc = "        \"TransferChecked.destination\","]
    #[doc = "        \"TransferChecked.authority\","]
    #[doc = "        \"TransferChecked.amount\","]
    #[doc = "        \"TransferChecked.mint\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"field_source\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"solana_token_program_instruction\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"operator\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionOperator\""]
    #[doc = "    },"]
    #[doc = "    \"value\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/ConditionValue\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaTokenProgramInstructionCondition {
        pub field: SolanaTokenProgramInstructionConditionField,
        pub field_source: SolanaTokenProgramInstructionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }
    impl ::std::convert::From<&SolanaTokenProgramInstructionCondition>
        for SolanaTokenProgramInstructionCondition
    {
        fn from(value: &SolanaTokenProgramInstructionCondition) -> Self {
            value.clone()
        }
    }
    impl SolanaTokenProgramInstructionCondition {
        pub fn builder() -> builder::SolanaTokenProgramInstructionCondition {
            Default::default()
        }
    }
    #[doc = "`SolanaTokenProgramInstructionConditionField`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"SolanaTokenProgramInstructionConditionField\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"instructionName\","]
    #[doc = "    \"TransferChecked.source\","]
    #[doc = "    \"TransferChecked.destination\","]
    #[doc = "    \"TransferChecked.authority\","]
    #[doc = "    \"TransferChecked.amount\","]
    #[doc = "    \"TransferChecked.mint\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaTokenProgramInstructionConditionField {
        #[serde(rename = "instructionName")]
        InstructionName,
        #[serde(rename = "TransferChecked.source")]
        TransferCheckedSource,
        #[serde(rename = "TransferChecked.destination")]
        TransferCheckedDestination,
        #[serde(rename = "TransferChecked.authority")]
        TransferCheckedAuthority,
        #[serde(rename = "TransferChecked.amount")]
        TransferCheckedAmount,
        #[serde(rename = "TransferChecked.mint")]
        TransferCheckedMint,
    }
    impl ::std::convert::From<&Self> for SolanaTokenProgramInstructionConditionField {
        fn from(value: &SolanaTokenProgramInstructionConditionField) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaTokenProgramInstructionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstructionName => f.write_str("instructionName"),
                Self::TransferCheckedSource => f.write_str("TransferChecked.source"),
                Self::TransferCheckedDestination => f.write_str("TransferChecked.destination"),
                Self::TransferCheckedAuthority => f.write_str("TransferChecked.authority"),
                Self::TransferCheckedAmount => f.write_str("TransferChecked.amount"),
                Self::TransferCheckedMint => f.write_str("TransferChecked.mint"),
            }
        }
    }
    impl ::std::str::FromStr for SolanaTokenProgramInstructionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instructionName" => Ok(Self::InstructionName),
                "TransferChecked.source" => Ok(Self::TransferCheckedSource),
                "TransferChecked.destination" => Ok(Self::TransferCheckedDestination),
                "TransferChecked.authority" => Ok(Self::TransferCheckedAuthority),
                "TransferChecked.amount" => Ok(Self::TransferCheckedAmount),
                "TransferChecked.mint" => Ok(Self::TransferCheckedMint),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaTokenProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaTokenProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaTokenProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`SolanaTokenProgramInstructionConditionFieldSource`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana_token_program_instruction\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaTokenProgramInstructionConditionFieldSource {
        #[serde(rename = "solana_token_program_instruction")]
        SolanaTokenProgramInstruction,
    }
    impl ::std::convert::From<&Self> for SolanaTokenProgramInstructionConditionFieldSource {
        fn from(value: &SolanaTokenProgramInstructionConditionFieldSource) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for SolanaTokenProgramInstructionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolanaTokenProgramInstruction => {
                    f.write_str("solana_token_program_instruction")
                }
            }
        }
    }
    impl ::std::str::FromStr for SolanaTokenProgramInstructionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana_token_program_instruction" => Ok(Self::SolanaTokenProgramInstruction),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for SolanaTokenProgramInstructionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaTokenProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaTokenProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`TotpMfaMethod`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"TOTP\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"type\","]
    #[doc = "    \"verified_at\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"type\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"totp\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"verified_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TotpMfaMethod {
        #[serde(rename = "type")]
        pub type_: TotpMfaMethodType,
        pub verified_at: f64,
    }
    impl ::std::convert::From<&TotpMfaMethod> for TotpMfaMethod {
        fn from(value: &TotpMfaMethod) -> Self {
            value.clone()
        }
    }
    impl TotpMfaMethod {
        pub fn builder() -> builder::TotpMfaMethod {
            Default::default()
        }
    }
    #[doc = "`TotpMfaMethodType`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"totp\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TotpMfaMethodType {
        #[serde(rename = "totp")]
        Totp,
    }
    impl ::std::convert::From<&Self> for TotpMfaMethodType {
        fn from(value: &TotpMfaMethodType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TotpMfaMethodType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Totp => f.write_str("totp"),
            }
        }
    }
    impl ::std::str::FromStr for TotpMfaMethodType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "totp" => Ok(Self::Totp),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for TotpMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for TotpMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for TotpMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`Transaction`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"caip2\": \"eip155:8453\","]
    #[doc = "      \"created_at\": 1631573050000,"]
    #[doc = "      \"id\": \"cm7oxq1el000e11o8iwp7d0d0\","]
    #[doc = "      \"status\": \"confirmed\","]
    #[doc = "      \"transaction_hash\": \"0x2446f1fd773fbb9f080e674b60c6a033c7ed7427b8b9413cf28a2a4a6da9b56c\","]
    #[doc = "      \"wallet_id\": \"fmfdj6yqly31huorjqzq38zc\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"caip2\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"status\","]
    #[doc = "    \"transaction_hash\","]
    #[doc = "    \"wallet_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"caip2\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"sponsored\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"broadcasted\","]
    #[doc = "        \"confirmed\","]
    #[doc = "        \"execution_reverted\","]
    #[doc = "        \"failed\","]
    #[doc = "        \"replaced\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"transaction_hash\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Transaction {
        pub caip2: ::std::string::String,
        pub created_at: f64,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsored: ::std::option::Option<bool>,
        pub status: TransactionStatus,
        pub transaction_hash: ::std::option::Option<::std::string::String>,
        pub wallet_id: ::std::string::String,
    }
    impl ::std::convert::From<&Transaction> for Transaction {
        fn from(value: &Transaction) -> Self {
            value.clone()
        }
    }
    impl Transaction {
        pub fn builder() -> builder::Transaction {
            Default::default()
        }
    }
    #[doc = "`TransactionStatus`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"broadcasted\","]
    #[doc = "    \"confirmed\","]
    #[doc = "    \"execution_reverted\","]
    #[doc = "    \"failed\","]
    #[doc = "    \"replaced\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TransactionStatus {
        #[serde(rename = "broadcasted")]
        Broadcasted,
        #[serde(rename = "confirmed")]
        Confirmed,
        #[serde(rename = "execution_reverted")]
        ExecutionReverted,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "replaced")]
        Replaced,
    }
    impl ::std::convert::From<&Self> for TransactionStatus {
        fn from(value: &TransactionStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for TransactionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Broadcasted => f.write_str("broadcasted"),
                Self::Confirmed => f.write_str("confirmed"),
                Self::ExecutionReverted => f.write_str("execution_reverted"),
                Self::Failed => f.write_str("failed"),
                Self::Replaced => f.write_str("replaced"),
            }
        }
    }
    impl ::std::str::FromStr for TransactionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "broadcasted" => Ok(Self::Broadcasted),
                "confirmed" => Ok(Self::Confirmed),
                "execution_reverted" => Ok(Self::ExecutionReverted),
                "failed" => Ok(Self::Failed),
                "replaced" => Ok(Self::Replaced),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`UpdateWalletBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"policy_ids\": ["]
    #[doc = "        \"tb54eps4z44ed0jepousxi4n\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"additional_signers\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletAdditionalSigner\""]
    #[doc = "    },"]
    #[doc = "    \"owner\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/OwnerInput\""]
    #[doc = "    },"]
    #[doc = "    \"owner_id\": {"]
    #[doc = "      \"allOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"$ref\": \"#/components/schemas/OwnerIdInput\""]
    #[doc = "        },"]
    #[doc = "        {}"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"policy_ids\": {"]
    #[doc = "      \"description\": \"New policy IDs to enforce on the wallet. Currently, only one policy is supported per wallet.\","]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"maxLength\": 24,"]
    #[doc = "        \"minLength\": 24"]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 1"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateWalletBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub additional_signers: ::std::option::Option<WalletAdditionalSigner>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<OwnerInput>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<OwnerIdInput>,
        #[doc = "New policy IDs to enforce on the wallet. Currently, only one policy is supported per wallet."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<UpdateWalletBodyPolicyIdsItem>,
    }
    impl ::std::convert::From<&UpdateWalletBody> for UpdateWalletBody {
        fn from(value: &UpdateWalletBody) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for UpdateWalletBody {
        fn default() -> Self {
            Self {
                additional_signers: Default::default(),
                owner: Default::default(),
                owner_id: Default::default(),
                policy_ids: Default::default(),
            }
        }
    }
    impl UpdateWalletBody {
        pub fn builder() -> builder::UpdateWalletBody {
            Default::default()
        }
    }
    #[doc = "`UpdateWalletBodyPolicyIdsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"maxLength\": 24,"]
    #[doc = "  \"minLength\": 24"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateWalletBodyPolicyIdsItem(::std::string::String);
    impl ::std::ops::Deref for UpdateWalletBodyPolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<UpdateWalletBodyPolicyIdsItem> for ::std::string::String {
        fn from(value: UpdateWalletBodyPolicyIdsItem) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&UpdateWalletBodyPolicyIdsItem> for UpdateWalletBodyPolicyIdsItem {
        fn from(value: &UpdateWalletBodyPolicyIdsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for UpdateWalletBodyPolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for UpdateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for UpdateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for UpdateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for UpdateWalletBodyPolicyIdsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`User`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"created_at\": 1731974895,"]
    #[doc = "      \"has_accepted_terms\": true,"]
    #[doc = "      \"id\": \"did:privy:cm3np4u9j001rc8b73seqmqqk\","]
    #[doc = "      \"is_guest\": false,"]
    #[doc = "      \"linked_accounts\": ["]
    #[doc = "        {"]
    #[doc = "          \"address\": \"tom.bombadill@privy.io\","]
    #[doc = "          \"first_verified_at\": 1674788927,"]
    #[doc = "          \"latest_verified_at\": 1674788927,"]
    #[doc = "          \"type\": \"email\","]
    #[doc = "          \"verified_at\": 1674788927"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"bio\": \"engineering at /privy. building pixelpool.xyz, the first Farcaster video client. nyc. 👨\u{200d}💻🍎🏳\u{fe0f}\u{200d}🌈  nf.td/payton\","]
    #[doc = "          \"display_name\": \"payton ↑\","]
    #[doc = "          \"fid\": 4423,"]
    #[doc = "          \"first_verified_at\": 1740678402,"]
    #[doc = "          \"latest_verified_at\": 1741194370,"]
    #[doc = "          \"owner_address\": \"0xE6bFb4137F3A8C069F98cc775f324A84FE45FdFF\","]
    #[doc = "          \"profile_picture\": \"https://supercast.mypinata.cloud/ipfs/QmNexfCxdnFzWdJqKVgrjd27UGLMexNaw5FXu1XKR3cQF7?filename=IMG_2799.png\","]
    #[doc = "          \"profile_picture_url\": \"https://supercast.mypinata.cloud/ipfs/QmNexfCxdnFzWdJqKVgrjd27UGLMexNaw5FXu1XKR3cQF7?filename=IMG_2799.png\","]
    #[doc = "          \"type\": \"farcaster\","]
    #[doc = "          \"username\": \"payton\","]
    #[doc = "          \"verified_at\": 1740678402"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"authenticator_name\": \"1Password\","]
    #[doc = "          \"created_with_browser\": \"Chrome\","]
    #[doc = "          \"created_with_device\": \"Macintosh\","]
    #[doc = "          \"created_with_os\": \"Mac OS\","]
    #[doc = "          \"credential_id\": \"Il5vP-3Tm3hNmDVBmDlREgXzIOJnZEaiVnT-XMliXe-BufP9GL1-d3qhozk9IkZwQ_\","]
    #[doc = "          \"enrolled_in_mfa\": true,"]
    #[doc = "          \"first_verified_at\": 1741194420,"]
    #[doc = "          \"latest_verified_at\": 1741194420,"]
    #[doc = "          \"public_key\": \"pQECAyYgASFYIKdGwx5XxZ/7CJJzT8d5L6jyLNQdTH7X+rSZdPJ9Ux/QIlggRm4OcJ8F3aB5zYz3T9LxLdDfGpWvYkHgS4A8tPz9CqE=\","]
    #[doc = "          \"type\": \"passkey\","]
    #[doc = "          \"verified_at\": 1741194420"]
    #[doc = "        }"]
    #[doc = "      ],"]
    #[doc = "      \"mfa_methods\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"passkey\","]
    #[doc = "          \"verified_at\": 1741194420"]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"created_at\","]
    #[doc = "    \"has_accepted_terms\","]
    #[doc = "    \"id\","]
    #[doc = "    \"is_guest\","]
    #[doc = "    \"linked_accounts\","]
    #[doc = "    \"mfa_methods\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"description\": \"Unix timestamp of when the user was created in milliseconds.\","]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"custom_metadata\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/CustomMetadata\""]
    #[doc = "    },"]
    #[doc = "    \"has_accepted_terms\": {"]
    #[doc = "      \"description\": \"Indicates if the user has accepted the terms of service.\","]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"is_guest\": {"]
    #[doc = "      \"description\": \"Indicates if the user is a guest account user.\","]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"linked_accounts\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"anyOf\": ["]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountEmail\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountPhone\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountCrossApp\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountAuthorizationKey\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountCustomJwt\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountAppleOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountDiscordOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountGithubOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountGoogleOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountInstagramOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountLinkedInOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountSpotifyOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountTiktokOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountLineOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountTwitterOauth\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountSmartWallet\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountPasskey\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountFarcaster\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountEthereum\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountEthereumEmbeddedWallet\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountSolana\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountSolanaEmbeddedWallet\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountBitcoinSegwitEmbeddedWallet\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/LinkedAccountBitcoinTaprootEmbeddedWallet\""]
    #[doc = "          }"]
    #[doc = "        ]"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"mfa_methods\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"oneOf\": ["]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/PasskeyMfaMethod\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/SmsMfaMethod\""]
    #[doc = "          },"]
    #[doc = "          {"]
    #[doc = "            \"$ref\": \"#/components/schemas/TotpMfaMethod\""]
    #[doc = "          }"]
    #[doc = "        ]"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct User {
        pub created_at: f64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub custom_metadata: ::std::option::Option<CustomMetadata>,
        #[doc = "Indicates if the user has accepted the terms of service."]
        pub has_accepted_terms: bool,
        pub id: ::std::string::String,
        #[doc = "Indicates if the user is a guest account user."]
        pub is_guest: bool,
        pub linked_accounts: ::std::vec::Vec<UserLinkedAccountsItem>,
        pub mfa_methods: ::std::vec::Vec<UserMfaMethodsItem>,
    }
    impl ::std::convert::From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }
    impl User {
        pub fn builder() -> builder::User {
            Default::default()
        }
    }
    #[doc = "`UserLinkedAccountsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountEmail\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountPhone\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountCrossApp\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountAuthorizationKey\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountCustomJwt\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountAppleOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountDiscordOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountGithubOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountGoogleOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountInstagramOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountLinkedInOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountSpotifyOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountTiktokOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountLineOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountTwitterOauth\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountSmartWallet\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountPasskey\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountFarcaster\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountEthereum\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountEthereumEmbeddedWallet\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountSolana\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountSolanaEmbeddedWallet\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountBitcoinSegwitEmbeddedWallet\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/LinkedAccountBitcoinTaprootEmbeddedWallet\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UserLinkedAccountsItem {
        Email(LinkedAccountEmail),
        Phone(LinkedAccountPhone),
        CrossApp(LinkedAccountCrossApp),
        AuthorizationKey(LinkedAccountAuthorizationKey),
        CustomJwt(LinkedAccountCustomJwt),
        AppleOauth(LinkedAccountAppleOauth),
        DiscordOauth(LinkedAccountDiscordOauth),
        GithubOauth(LinkedAccountGithubOauth),
        GoogleOauth(LinkedAccountGoogleOauth),
        InstagramOauth(LinkedAccountInstagramOauth),
        LinkedInOauth(LinkedAccountLinkedInOauth),
        SpotifyOauth(LinkedAccountSpotifyOauth),
        TiktokOauth(LinkedAccountTiktokOauth),
        LineOauth(LinkedAccountLineOauth),
        TwitterOauth(LinkedAccountTwitterOauth),
        SmartWallet(LinkedAccountSmartWallet),
        Passkey(LinkedAccountPasskey),
        Farcaster(LinkedAccountFarcaster),
        Ethereum(LinkedAccountEthereum),
        EthereumEmbeddedWallet(LinkedAccountEthereumEmbeddedWallet),
        Solana(LinkedAccountSolana),
        SolanaEmbeddedWallet(LinkedAccountSolanaEmbeddedWallet),
        BitcoinSegwitEmbeddedWallet(LinkedAccountBitcoinSegwitEmbeddedWallet),
        BitcoinTaprootEmbeddedWallet(LinkedAccountBitcoinTaprootEmbeddedWallet),
    }
    impl ::std::convert::From<&Self> for UserLinkedAccountsItem {
        fn from(value: &UserLinkedAccountsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<LinkedAccountEmail> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountEmail) -> Self {
            Self::Email(value)
        }
    }
    impl ::std::convert::From<LinkedAccountPhone> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountPhone) -> Self {
            Self::Phone(value)
        }
    }
    impl ::std::convert::From<LinkedAccountCrossApp> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountCrossApp) -> Self {
            Self::CrossApp(value)
        }
    }
    impl ::std::convert::From<LinkedAccountAuthorizationKey> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountAuthorizationKey) -> Self {
            Self::AuthorizationKey(value)
        }
    }
    impl ::std::convert::From<LinkedAccountCustomJwt> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountCustomJwt) -> Self {
            Self::CustomJwt(value)
        }
    }
    impl ::std::convert::From<LinkedAccountAppleOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountAppleOauth) -> Self {
            Self::AppleOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountDiscordOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountDiscordOauth) -> Self {
            Self::DiscordOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountGithubOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountGithubOauth) -> Self {
            Self::GithubOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountGoogleOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountGoogleOauth) -> Self {
            Self::GoogleOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountInstagramOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountInstagramOauth) -> Self {
            Self::InstagramOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountLinkedInOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountLinkedInOauth) -> Self {
            Self::LinkedInOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountSpotifyOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSpotifyOauth) -> Self {
            Self::SpotifyOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountTiktokOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountTiktokOauth) -> Self {
            Self::TiktokOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountLineOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountLineOauth) -> Self {
            Self::LineOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountTwitterOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountTwitterOauth) -> Self {
            Self::TwitterOauth(value)
        }
    }
    impl ::std::convert::From<LinkedAccountSmartWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSmartWallet) -> Self {
            Self::SmartWallet(value)
        }
    }
    impl ::std::convert::From<LinkedAccountPasskey> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountPasskey) -> Self {
            Self::Passkey(value)
        }
    }
    impl ::std::convert::From<LinkedAccountFarcaster> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountFarcaster) -> Self {
            Self::Farcaster(value)
        }
    }
    impl ::std::convert::From<LinkedAccountEthereum> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountEthereum) -> Self {
            Self::Ethereum(value)
        }
    }
    impl ::std::convert::From<LinkedAccountEthereumEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountEthereumEmbeddedWallet) -> Self {
            Self::EthereumEmbeddedWallet(value)
        }
    }
    impl ::std::convert::From<LinkedAccountSolana> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSolana) -> Self {
            Self::Solana(value)
        }
    }
    impl ::std::convert::From<LinkedAccountSolanaEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSolanaEmbeddedWallet) -> Self {
            Self::SolanaEmbeddedWallet(value)
        }
    }
    impl ::std::convert::From<LinkedAccountBitcoinSegwitEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountBitcoinSegwitEmbeddedWallet) -> Self {
            Self::BitcoinSegwitEmbeddedWallet(value)
        }
    }
    impl ::std::convert::From<LinkedAccountBitcoinTaprootEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountBitcoinTaprootEmbeddedWallet) -> Self {
            Self::BitcoinTaprootEmbeddedWallet(value)
        }
    }
    #[doc = "`UserMfaMethodsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/PasskeyMfaMethod\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SmsMfaMethod\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/TotpMfaMethod\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UserMfaMethodsItem {
        PasskeyMfaMethod(PasskeyMfaMethod),
        SmsMfaMethod(SmsMfaMethod),
        TotpMfaMethod(TotpMfaMethod),
    }
    impl ::std::convert::From<&Self> for UserMfaMethodsItem {
        fn from(value: &UserMfaMethodsItem) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<PasskeyMfaMethod> for UserMfaMethodsItem {
        fn from(value: PasskeyMfaMethod) -> Self {
            Self::PasskeyMfaMethod(value)
        }
    }
    impl ::std::convert::From<SmsMfaMethod> for UserMfaMethodsItem {
        fn from(value: SmsMfaMethod) -> Self {
            Self::SmsMfaMethod(value)
        }
    }
    impl ::std::convert::From<TotpMfaMethod> for UserMfaMethodsItem {
        fn from(value: TotpMfaMethod) -> Self {
            Self::TotpMfaMethod(value)
        }
    }
    #[doc = "The user ID of the owner of the resource. The user must already exist, and this value must start with \"did:privy:\". If you provide this, do not specify an owner_id as it will be generated automatically."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"User owner\","]
    #[doc = "  \"description\": \"The user ID of the owner of the resource. The user must already exist, and this value must start with \\\"did:privy:\\\". If you provide this, do not specify an owner_id as it will be generated automatically.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"user_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"user_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserOwner {
        pub user_id: ::std::string::String,
    }
    impl ::std::convert::From<&UserOwner> for UserOwner {
        fn from(value: &UserOwner) -> Self {
            value.clone()
        }
    }
    impl UserOwner {
        pub fn builder() -> builder::UserOwner {
            Default::default()
        }
    }
    #[doc = "`Wallet`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"additional_signers\": [],"]
    #[doc = "      \"address\": \"0xF1DBff66C993EE895C8cb176c30b07A559d76496\","]
    #[doc = "      \"chain_type\": \"ethereum\","]
    #[doc = "      \"created_at\": 1741834854578,"]
    #[doc = "      \"exported_at\": null,"]
    #[doc = "      \"id\": \"id2tptkqrxd39qo9j423etij\","]
    #[doc = "      \"imported_at\": null,"]
    #[doc = "      \"owner_id\": \"rkiz0ivz254drv1xw982v3jq\","]
    #[doc = "      \"policy_ids\": []"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"additional_signers\","]
    #[doc = "    \"address\","]
    #[doc = "    \"chain_type\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"exported_at\","]
    #[doc = "    \"id\","]
    #[doc = "    \"imported_at\","]
    #[doc = "    \"policy_ids\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"additional_signers\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletAdditionalSigner\""]
    #[doc = "    },"]
    #[doc = "    \"address\": {"]
    #[doc = "      \"description\": \"Address of the wallet.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"chain_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/WalletChainType\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"description\": \"Unix timestamp of when the wallet was created in milliseconds.\","]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"exported_at\": {"]
    #[doc = "      \"description\": \"Unix timestamp of when the wallet was exported in milliseconds, if the wallet was exported.\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"id\": {"]
    #[doc = "      \"description\": \"Unique ID of the wallet. This will be the primary identifier when using the wallet in the future.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"imported_at\": {"]
    #[doc = "      \"description\": \"Unix timestamp of when the wallet was imported in milliseconds, if the wallet was imported.\","]
    #[doc = "      \"type\": ["]
    #[doc = "        \"number\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"owner_id\": {"]
    #[doc = "      \"description\": \"The key quorum ID of the owner of the wallet.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"policy_ids\": {"]
    #[doc = "      \"description\": \"List of policy IDs for policies that are enforced on the wallet.\","]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"description\": \"The compressed, raw public key for the wallet along the chain cryptographic curve.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Wallet {
        pub additional_signers: WalletAdditionalSigner,
        #[doc = "Address of the wallet."]
        pub address: ::std::string::String,
        pub chain_type: WalletChainType,
        pub created_at: f64,
        #[doc = "Unix timestamp of when the wallet was exported in milliseconds, if the wallet was exported."]
        pub exported_at: ::std::option::Option<f64>,
        #[doc = "Unique ID of the wallet. This will be the primary identifier when using the wallet in the future."]
        pub id: ::std::string::String,
        #[doc = "Unix timestamp of when the wallet was imported in milliseconds, if the wallet was imported."]
        pub imported_at: ::std::option::Option<f64>,
        #[doc = "The key quorum ID of the owner of the wallet."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<::std::string::String>,
        #[doc = "List of policy IDs for policies that are enforced on the wallet."]
        pub policy_ids: ::std::vec::Vec<::std::string::String>,
        #[doc = "The compressed, raw public key for the wallet along the chain cryptographic curve."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_key: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&Wallet> for Wallet {
        fn from(value: &Wallet) -> Self {
            value.clone()
        }
    }
    impl Wallet {
        pub fn builder() -> builder::Wallet {
            Default::default()
        }
    }
    #[doc = "Additional signers for the wallet."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Additional signers for the wallet.\","]
    #[doc = "  \"type\": \"array\","]
    #[doc = "  \"items\": {"]
    #[doc = "    \"type\": \"object\","]
    #[doc = "    \"required\": ["]
    #[doc = "      \"override_policy_ids\","]
    #[doc = "      \"signer_id\""]
    #[doc = "    ],"]
    #[doc = "    \"properties\": {"]
    #[doc = "      \"override_policy_ids\": {"]
    #[doc = "        \"type\": \"array\","]
    #[doc = "        \"items\": {"]
    #[doc = "          \"description\": \"The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet.\","]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"signer_id\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct WalletAdditionalSigner(pub ::std::vec::Vec<WalletAdditionalSignerItem>);
    impl ::std::ops::Deref for WalletAdditionalSigner {
        type Target = ::std::vec::Vec<WalletAdditionalSignerItem>;
        fn deref(&self) -> &::std::vec::Vec<WalletAdditionalSignerItem> {
            &self.0
        }
    }
    impl ::std::convert::From<WalletAdditionalSigner> for ::std::vec::Vec<WalletAdditionalSignerItem> {
        fn from(value: WalletAdditionalSigner) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&WalletAdditionalSigner> for WalletAdditionalSigner {
        fn from(value: &WalletAdditionalSigner) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::std::vec::Vec<WalletAdditionalSignerItem>> for WalletAdditionalSigner {
        fn from(value: ::std::vec::Vec<WalletAdditionalSignerItem>) -> Self {
            Self(value)
        }
    }
    #[doc = "`WalletAdditionalSignerItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"override_policy_ids\","]
    #[doc = "    \"signer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"override_policy_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"description\": \"The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet.\","]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"signer_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletAdditionalSignerItem {
        pub override_policy_ids: ::std::vec::Vec<::std::string::String>,
        pub signer_id: ::std::string::String,
    }
    impl ::std::convert::From<&WalletAdditionalSignerItem> for WalletAdditionalSignerItem {
        fn from(value: &WalletAdditionalSignerItem) -> Self {
            value.clone()
        }
    }
    impl WalletAdditionalSignerItem {
        pub fn builder() -> builder::WalletAdditionalSignerItem {
            Default::default()
        }
    }
    #[doc = "Chain type of the wallet"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"Chain type of the wallet\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"solana\","]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"cosmos\","]
    #[doc = "    \"stellar\","]
    #[doc = "    \"sui\","]
    #[doc = "    \"tron\","]
    #[doc = "    \"bitcoin-segwit\","]
    #[doc = "    \"near\","]
    #[doc = "    \"spark\","]
    #[doc = "    \"ton\","]
    #[doc = "    \"starknet\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletChainType {
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "cosmos")]
        Cosmos,
        #[serde(rename = "stellar")]
        Stellar,
        #[serde(rename = "sui")]
        Sui,
        #[serde(rename = "tron")]
        Tron,
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
        #[serde(rename = "near")]
        Near,
        #[serde(rename = "spark")]
        Spark,
        #[serde(rename = "ton")]
        Ton,
        #[serde(rename = "starknet")]
        Starknet,
    }
    impl ::std::convert::From<&Self> for WalletChainType {
        fn from(value: &WalletChainType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
                Self::Ethereum => f.write_str("ethereum"),
                Self::Cosmos => f.write_str("cosmos"),
                Self::Stellar => f.write_str("stellar"),
                Self::Sui => f.write_str("sui"),
                Self::Tron => f.write_str("tron"),
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
                Self::Near => f.write_str("near"),
                Self::Spark => f.write_str("spark"),
                Self::Ton => f.write_str("ton"),
                Self::Starknet => f.write_str("starknet"),
            }
        }
    }
    impl ::std::str::FromStr for WalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                "ethereum" => Ok(Self::Ethereum),
                "cosmos" => Ok(Self::Cosmos),
                "stellar" => Ok(Self::Stellar),
                "sui" => Ok(Self::Sui),
                "tron" => Ok(Self::Tron),
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                "near" => Ok(Self::Near),
                "spark" => Ok(Self::Spark),
                "ton" => Ok(Self::Ton),
                "starknet" => Ok(Self::Starknet),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for WalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for WalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletExportRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Wallet export request\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"encryption_type\": \"HPKE\","]
    #[doc = "      \"recipient_public_key\": \"BDAZLOIdTaPycEYkgG0MvCzbIKJLli/yWkAV5yCa9yOsZ4JsrLweA5MnP8YIiY4k/RRzC+APhhO+P+Hoz/rt7Go=\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encryption_type\","]
    #[doc = "    \"recipient_public_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HPKEEncryption\""]
    #[doc = "    },"]
    #[doc = "    \"recipient_public_key\": {"]
    #[doc = "      \"description\": \"The base64-encoded encryption public key to encrypt the wallet private key with.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletExportRequest {
        pub encryption_type: HpkeEncryption,
        #[doc = "The base64-encoded encryption public key to encrypt the wallet private key with."]
        pub recipient_public_key: ::std::string::String,
    }
    impl ::std::convert::From<&WalletExportRequest> for WalletExportRequest {
        fn from(value: &WalletExportRequest) -> Self {
            value.clone()
        }
    }
    impl WalletExportRequest {
        pub fn builder() -> builder::WalletExportRequest {
            Default::default()
        }
    }
    #[doc = "`WalletExportResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Wallet export response\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"ciphertext\": \"PRoRXygG+YYSDBXjCopNYZmx8Z6nvdl1D0lpePTYZdZI2VGfK+LkFt+GlEJqdoi9\","]
    #[doc = "      \"encapsulated_key\": \"BOhR6xITDt5THJawHHJKrKdI9CBr2M/SDWzZZAaOW4gCMsSpC65U007WyKiwuuOVAo1BNm4YgcBBROuMmyIZXZk=\","]
    #[doc = "      \"encryption_type\": \"HPKE\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"ciphertext\","]
    #[doc = "    \"encapsulated_key\","]
    #[doc = "    \"encryption_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"ciphertext\": {"]
    #[doc = "      \"description\": \"The encrypted private key.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encapsulated_key\": {"]
    #[doc = "      \"description\": \"The base64-encoded encapsulated key that was generated during encryption, for use during decryption.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HPKEEncryption\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletExportResponse {
        #[doc = "The encrypted private key."]
        pub ciphertext: ::std::string::String,
        #[doc = "The base64-encoded encapsulated key that was generated during encryption, for use during decryption."]
        pub encapsulated_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
    }
    impl ::std::convert::From<&WalletExportResponse> for WalletExportResponse {
        fn from(value: &WalletExportResponse) -> Self {
            value.clone()
        }
    }
    impl WalletExportResponse {
        pub fn builder() -> builder::WalletExportResponse {
            Default::default()
        }
    }
    #[doc = "`WalletImportInitializationRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Wallet import initialization request\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"address\": \"0xF1DBff66C993EE895C8cb176c30b07A559d76496\","]
    #[doc = "      \"chain_type\": \"ethereum\","]
    #[doc = "      \"encryption_type\": \"HPKE\","]
    #[doc = "      \"entropy_type\": \"private-key\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HDInitInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/PrivateKeyInitInput\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletImportInitializationRequest {
        HdInitInput(HdInitInput),
        PrivateKeyInitInput(PrivateKeyInitInput),
    }
    impl ::std::convert::From<&Self> for WalletImportInitializationRequest {
        fn from(value: &WalletImportInitializationRequest) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<HdInitInput> for WalletImportInitializationRequest {
        fn from(value: HdInitInput) -> Self {
            Self::HdInitInput(value)
        }
    }
    impl ::std::convert::From<PrivateKeyInitInput> for WalletImportInitializationRequest {
        fn from(value: PrivateKeyInitInput) -> Self {
            Self::PrivateKeyInitInput(value)
        }
    }
    #[doc = "`WalletImportInitializationResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Wallet import initialization response\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"encryption_public_key\": \"BDAZLOIdTaPycEYkgG0MvCzbIKJLli/yWkAV5yCa9yOsZ4JsrLweA5MnP8YIiY4k/RRzC+APhhO+P+Hoz/rt7Go=\","]
    #[doc = "      \"encryption_type\": \"HPKE\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"encryption_public_key\","]
    #[doc = "    \"encryption_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"encryption_public_key\": {"]
    #[doc = "      \"description\": \"The base64-encoded encryption public key to encrypt the wallet entropy with.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HPKEEncryption\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletImportInitializationResponse {
        #[doc = "The base64-encoded encryption public key to encrypt the wallet entropy with."]
        pub encryption_public_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
    }
    impl ::std::convert::From<&WalletImportInitializationResponse>
        for WalletImportInitializationResponse
    {
        fn from(value: &WalletImportInitializationResponse) -> Self {
            value.clone()
        }
    }
    impl WalletImportInitializationResponse {
        pub fn builder() -> builder::WalletImportInitializationResponse {
            Default::default()
        }
    }
    #[doc = "`WalletImportSubmissionRequest`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"title\": \"Wallet import submission request\","]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"owner_id\": \"rkiz0ivz254drv1xw982v3jq\","]
    #[doc = "      \"wallet\": {"]
    #[doc = "        \"address\": \"0xF1DBff66C993EE895C8cb176c30b07A559d76496\","]
    #[doc = "        \"chain_type\": \"ethereum\","]
    #[doc = "        \"ciphertext\": \"PRoRXygG+YYSDBXjCopNYZmx8Z6nvdl1D0lpePTYZdZI2VGfK+LkFt+GlEJqdoi9\","]
    #[doc = "        \"encapsulated_key\": \"BOhR6xITDt5THJawHHJKrKdI9CBr2M/SDWzZZAaOW4gCMsSpC65U007WyKiwuuOVAo1BNm4YgcBBROuMmyIZXZk=\","]
    #[doc = "        \"encryption_type\": \"HPKE\","]
    #[doc = "        \"entropy_type\": \"private-key\""]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"wallet\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"additional_signers\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"signer_id\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"override_policy_ids\": {"]
    #[doc = "            \"type\": \"array\","]
    #[doc = "            \"items\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"maxItems\": 1"]
    #[doc = "          },"]
    #[doc = "          \"signer_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"additionalProperties\": false"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    \"owner\": {"]
    #[doc = "      \"anyOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"user_id\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"user_id\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"additionalProperties\": false"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"public_key\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"public_key\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            }"]
    #[doc = "          },"]
    #[doc = "          \"additionalProperties\": false"]
    #[doc = "        },"]
    #[doc = "        {},"]
    #[doc = "        {}"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"owner_id\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"policy_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 1"]
    #[doc = "    },"]
    #[doc = "    \"wallet\": {"]
    #[doc = "      \"oneOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"$ref\": \"#/components/schemas/HDSubmitInput\""]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"$ref\": \"#/components/schemas/PrivateKeySubmitInput\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WalletImportSubmissionRequest {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub additional_signers: ::std::vec::Vec<WalletImportSubmissionRequestAdditionalSignersItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<WalletImportSubmissionRequestOwner>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<::std::string::String>,
        pub wallet: WalletImportSubmissionRequestWallet,
    }
    impl ::std::convert::From<&WalletImportSubmissionRequest> for WalletImportSubmissionRequest {
        fn from(value: &WalletImportSubmissionRequest) -> Self {
            value.clone()
        }
    }
    impl WalletImportSubmissionRequest {
        pub fn builder() -> builder::WalletImportSubmissionRequest {
            Default::default()
        }
    }
    #[doc = "`WalletImportSubmissionRequestAdditionalSignersItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"signer_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"override_policy_ids\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\""]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 1"]
    #[doc = "    },"]
    #[doc = "    \"signer_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WalletImportSubmissionRequestAdditionalSignersItem {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub override_policy_ids: ::std::vec::Vec<::std::string::String>,
        pub signer_id: ::std::string::String,
    }
    impl ::std::convert::From<&WalletImportSubmissionRequestAdditionalSignersItem>
        for WalletImportSubmissionRequestAdditionalSignersItem
    {
        fn from(value: &WalletImportSubmissionRequestAdditionalSignersItem) -> Self {
            value.clone()
        }
    }
    impl WalletImportSubmissionRequestAdditionalSignersItem {
        pub fn builder() -> builder::WalletImportSubmissionRequestAdditionalSignersItem {
            Default::default()
        }
    }
    #[doc = "`WalletImportSubmissionRequestOwner`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"user_id\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"user_id\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"public_key\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"public_key\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"additionalProperties\": false"]
    #[doc = "    },"]
    #[doc = "    {},"]
    #[doc = "    {}"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletImportSubmissionRequestOwner {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_0: ::std::option::Option<WalletImportSubmissionRequestOwnerSubtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_1: ::std::option::Option<WalletImportSubmissionRequestOwnerSubtype1>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_2: ::std::option::Option<::serde_json::Value>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub subtype_3: ::std::option::Option<::serde_json::Value>,
    }
    impl ::std::convert::From<&WalletImportSubmissionRequestOwner>
        for WalletImportSubmissionRequestOwner
    {
        fn from(value: &WalletImportSubmissionRequestOwner) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for WalletImportSubmissionRequestOwner {
        fn default() -> Self {
            Self {
                subtype_0: Default::default(),
                subtype_1: Default::default(),
                subtype_2: Default::default(),
                subtype_3: Default::default(),
            }
        }
    }
    impl WalletImportSubmissionRequestOwner {
        pub fn builder() -> builder::WalletImportSubmissionRequestOwner {
            Default::default()
        }
    }
    #[doc = "`WalletImportSubmissionRequestOwnerSubtype0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"user_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"user_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WalletImportSubmissionRequestOwnerSubtype0 {
        pub user_id: ::std::string::String,
    }
    impl ::std::convert::From<&WalletImportSubmissionRequestOwnerSubtype0>
        for WalletImportSubmissionRequestOwnerSubtype0
    {
        fn from(value: &WalletImportSubmissionRequestOwnerSubtype0) -> Self {
            value.clone()
        }
    }
    impl WalletImportSubmissionRequestOwnerSubtype0 {
        pub fn builder() -> builder::WalletImportSubmissionRequestOwnerSubtype0 {
            Default::default()
        }
    }
    #[doc = "`WalletImportSubmissionRequestOwnerSubtype1`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"public_key\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"public_key\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  },"]
    #[doc = "  \"additionalProperties\": false"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(deny_unknown_fields)]
    pub struct WalletImportSubmissionRequestOwnerSubtype1 {
        pub public_key: ::std::string::String,
    }
    impl ::std::convert::From<&WalletImportSubmissionRequestOwnerSubtype1>
        for WalletImportSubmissionRequestOwnerSubtype1
    {
        fn from(value: &WalletImportSubmissionRequestOwnerSubtype1) -> Self {
            value.clone()
        }
    }
    impl WalletImportSubmissionRequestOwnerSubtype1 {
        pub fn builder() -> builder::WalletImportSubmissionRequestOwnerSubtype1 {
            Default::default()
        }
    }
    #[doc = "`WalletImportSubmissionRequestWallet`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/HDSubmitInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/PrivateKeySubmitInput\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletImportSubmissionRequestWallet {
        HdSubmitInput(HdSubmitInput),
        PrivateKeySubmitInput(PrivateKeySubmitInput),
    }
    impl ::std::convert::From<&Self> for WalletImportSubmissionRequestWallet {
        fn from(value: &WalletImportSubmissionRequestWallet) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<HdSubmitInput> for WalletImportSubmissionRequestWallet {
        fn from(value: HdSubmitInput) -> Self {
            Self::HdSubmitInput(value)
        }
    }
    impl ::std::convert::From<PrivateKeySubmitInput> for WalletImportSubmissionRequestWallet {
        fn from(value: PrivateKeySubmitInput) -> Self {
            Self::PrivateKeySubmitInput(value)
        }
    }
    #[doc = "The chain type of the wallet to import. Currently supports `ethereum` and `solana`."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The chain type of the wallet to import. Currently supports `ethereum` and `solana`.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"solana\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletImportSupportedChains {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "solana")]
        Solana,
    }
    impl ::std::convert::From<&Self> for WalletImportSupportedChains {
        fn from(value: &WalletImportSupportedChains) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletImportSupportedChains {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }
    impl ::std::str::FromStr for WalletImportSupportedChains {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WalletImportSupportedChains {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for WalletImportSupportedChains {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for WalletImportSupportedChains {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletRpcBody`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"caip2\": \"eip155:8453\","]
    #[doc = "      \"chain_type\": \"ethereum\","]
    #[doc = "      \"method\": \"eth_sendTransaction\","]
    #[doc = "      \"params\": {"]
    #[doc = "        \"transaction\": {"]
    #[doc = "          \"to\": \"0x0000000000000000000000000000000000000000\","]
    #[doc = "          \"value\": 1"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSignTransactionRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSendTransactionRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumPersonalSignRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSignTypedDataRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSign7702AuthorizationRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSecp256k1SignRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaSignTransactionRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaSignAndSendTransactionRpcInput\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaSignMessageRpcInput\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletRpcBody {
        EthereumSignTransactionRpcInput(EthereumSignTransactionRpcInput),
        EthereumSendTransactionRpcInput(EthereumSendTransactionRpcInput),
        EthereumPersonalSignRpcInput(EthereumPersonalSignRpcInput),
        EthereumSignTypedDataRpcInput(EthereumSignTypedDataRpcInput),
        EthereumSign7702AuthorizationRpcInput(EthereumSign7702AuthorizationRpcInput),
        EthereumSecp256k1SignRpcInput(EthereumSecp256k1SignRpcInput),
        SolanaSignTransactionRpcInput(SolanaSignTransactionRpcInput),
        SolanaSignAndSendTransactionRpcInput(SolanaSignAndSendTransactionRpcInput),
        SolanaSignMessageRpcInput(SolanaSignMessageRpcInput),
    }
    impl ::std::convert::From<&Self> for WalletRpcBody {
        fn from(value: &WalletRpcBody) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<EthereumSignTransactionRpcInput> for WalletRpcBody {
        fn from(value: EthereumSignTransactionRpcInput) -> Self {
            Self::EthereumSignTransactionRpcInput(value)
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcInput> for WalletRpcBody {
        fn from(value: EthereumSendTransactionRpcInput) -> Self {
            Self::EthereumSendTransactionRpcInput(value)
        }
    }
    impl ::std::convert::From<EthereumPersonalSignRpcInput> for WalletRpcBody {
        fn from(value: EthereumPersonalSignRpcInput) -> Self {
            Self::EthereumPersonalSignRpcInput(value)
        }
    }
    impl ::std::convert::From<EthereumSignTypedDataRpcInput> for WalletRpcBody {
        fn from(value: EthereumSignTypedDataRpcInput) -> Self {
            Self::EthereumSignTypedDataRpcInput(value)
        }
    }
    impl ::std::convert::From<EthereumSign7702AuthorizationRpcInput> for WalletRpcBody {
        fn from(value: EthereumSign7702AuthorizationRpcInput) -> Self {
            Self::EthereumSign7702AuthorizationRpcInput(value)
        }
    }
    impl ::std::convert::From<EthereumSecp256k1SignRpcInput> for WalletRpcBody {
        fn from(value: EthereumSecp256k1SignRpcInput) -> Self {
            Self::EthereumSecp256k1SignRpcInput(value)
        }
    }
    impl ::std::convert::From<SolanaSignTransactionRpcInput> for WalletRpcBody {
        fn from(value: SolanaSignTransactionRpcInput) -> Self {
            Self::SolanaSignTransactionRpcInput(value)
        }
    }
    impl ::std::convert::From<SolanaSignAndSendTransactionRpcInput> for WalletRpcBody {
        fn from(value: SolanaSignAndSendTransactionRpcInput) -> Self {
            Self::SolanaSignAndSendTransactionRpcInput(value)
        }
    }
    impl ::std::convert::From<SolanaSignMessageRpcInput> for WalletRpcBody {
        fn from(value: SolanaSignMessageRpcInput) -> Self {
            Self::SolanaSignMessageRpcInput(value)
        }
    }
    #[doc = "`WalletRpcResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"data\": {"]
    #[doc = "        \"caip2\": \"eip155:8453\","]
    #[doc = "        \"hash\": \"0x0775aeed9c9ce6e0fbc4db25c5e4e6368029651c905c286f813126a09025a21e\","]
    #[doc = "        \"transaction_request\": {"]
    #[doc = "          \"chain_id\": \"1\","]
    #[doc = "          \"from\": \"0x38Bc05d7b69F63D05337829fA5Dc4896F179B5fA\","]
    #[doc = "          \"gas_limit\": \"0x5208\","]
    #[doc = "          \"max_fee_per_gas\": \"0xfc328\","]
    #[doc = "          \"max_priority_fee_per_gas\": \"0xf4240\","]
    #[doc = "          \"nonce\": 1,"]
    #[doc = "          \"to\": \"0xF1DBff66C993EE895C8cb176c30b07A559d76496\","]
    #[doc = "          \"type\": 2,"]
    #[doc = "          \"value\": \"0x1\""]
    #[doc = "        }"]
    #[doc = "      },"]
    #[doc = "      \"method\": \"eth_sendTransaction\""]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaSignTransactionRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaSignAndSendTransactionRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/SolanaSignMessageRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSignTransactionRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSendTransactionRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumPersonalSignRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSignTypedDataRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSign7702AuthorizationRpcResponse\""]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"$ref\": \"#/components/schemas/EthereumSecp256k1SignRpcResponse\""]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletRpcResponse {
        SolanaSignTransactionRpcResponse(SolanaSignTransactionRpcResponse),
        SolanaSignAndSendTransactionRpcResponse(SolanaSignAndSendTransactionRpcResponse),
        SolanaSignMessageRpcResponse(SolanaSignMessageRpcResponse),
        EthereumSignTransactionRpcResponse(EthereumSignTransactionRpcResponse),
        EthereumSendTransactionRpcResponse(EthereumSendTransactionRpcResponse),
        EthereumPersonalSignRpcResponse(EthereumPersonalSignRpcResponse),
        EthereumSignTypedDataRpcResponse(EthereumSignTypedDataRpcResponse),
        EthereumSign7702AuthorizationRpcResponse(EthereumSign7702AuthorizationRpcResponse),
        EthereumSecp256k1SignRpcResponse(EthereumSecp256k1SignRpcResponse),
    }
    impl ::std::convert::From<&Self> for WalletRpcResponse {
        fn from(value: &WalletRpcResponse) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<SolanaSignTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: SolanaSignTransactionRpcResponse) -> Self {
            Self::SolanaSignTransactionRpcResponse(value)
        }
    }
    impl ::std::convert::From<SolanaSignAndSendTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: SolanaSignAndSendTransactionRpcResponse) -> Self {
            Self::SolanaSignAndSendTransactionRpcResponse(value)
        }
    }
    impl ::std::convert::From<SolanaSignMessageRpcResponse> for WalletRpcResponse {
        fn from(value: SolanaSignMessageRpcResponse) -> Self {
            Self::SolanaSignMessageRpcResponse(value)
        }
    }
    impl ::std::convert::From<EthereumSignTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSignTransactionRpcResponse) -> Self {
            Self::EthereumSignTransactionRpcResponse(value)
        }
    }
    impl ::std::convert::From<EthereumSendTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSendTransactionRpcResponse) -> Self {
            Self::EthereumSendTransactionRpcResponse(value)
        }
    }
    impl ::std::convert::From<EthereumPersonalSignRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumPersonalSignRpcResponse) -> Self {
            Self::EthereumPersonalSignRpcResponse(value)
        }
    }
    impl ::std::convert::From<EthereumSignTypedDataRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSignTypedDataRpcResponse) -> Self {
            Self::EthereumSignTypedDataRpcResponse(value)
        }
    }
    impl ::std::convert::From<EthereumSign7702AuthorizationRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSign7702AuthorizationRpcResponse) -> Self {
            Self::EthereumSign7702AuthorizationRpcResponse(value)
        }
    }
    impl ::std::convert::From<EthereumSecp256k1SignRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSecp256k1SignRpcResponse) -> Self {
            Self::EthereumSecp256k1SignRpcResponse(value)
        }
    }
    #[doc = "`WalletTransactionsAsset`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"anyOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"usdc\","]
    #[doc = "        \"eth\","]
    #[doc = "        \"pol\","]
    #[doc = "        \"sol\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"string\","]
    #[doc = "        \"enum\": ["]
    #[doc = "          \"usdc\","]
    #[doc = "          \"eth\","]
    #[doc = "          \"pol\","]
    #[doc = "          \"sol\""]
    #[doc = "        ]"]
    #[doc = "      },"]
    #[doc = "      \"maxItems\": 2"]
    #[doc = "    }"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletTransactionsAsset {
        Variant0(WalletTransactionsAssetVariant0),
        Variant1(::std::vec::Vec<WalletTransactionsAssetVariant1Item>),
    }
    impl ::std::convert::From<&Self> for WalletTransactionsAsset {
        fn from(value: &WalletTransactionsAsset) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<WalletTransactionsAssetVariant0> for WalletTransactionsAsset {
        fn from(value: WalletTransactionsAssetVariant0) -> Self {
            Self::Variant0(value)
        }
    }
    impl ::std::convert::From<::std::vec::Vec<WalletTransactionsAssetVariant1Item>>
        for WalletTransactionsAsset
    {
        fn from(value: ::std::vec::Vec<WalletTransactionsAssetVariant1Item>) -> Self {
            Self::Variant1(value)
        }
    }
    #[doc = "`WalletTransactionsAssetVariant0`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\","]
    #[doc = "    \"eth\","]
    #[doc = "    \"pol\","]
    #[doc = "    \"sol\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsAssetVariant0 {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "sol")]
        Sol,
    }
    impl ::std::convert::From<&Self> for WalletTransactionsAssetVariant0 {
        fn from(value: &WalletTransactionsAssetVariant0) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsAssetVariant0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsAssetVariant0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WalletTransactionsAssetVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsAssetVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsAssetVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsAssetVariant1Item`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\","]
    #[doc = "    \"eth\","]
    #[doc = "    \"pol\","]
    #[doc = "    \"sol\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsAssetVariant1Item {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "sol")]
        Sol,
    }
    impl ::std::convert::From<&Self> for WalletTransactionsAssetVariant1Item {
        fn from(value: &WalletTransactionsAssetVariant1Item) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsAssetVariant1Item {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsAssetVariant1Item {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WalletTransactionsAssetVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsAssetVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsAssetVariant1Item {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsChain`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"base\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsChain {
        #[serde(rename = "base")]
        Base,
    }
    impl ::std::convert::From<&Self> for WalletTransactionsChain {
        fn from(value: &WalletTransactionsChain) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base => f.write_str("base"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base" => Ok(Self::Base),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WalletTransactionsChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsCursor`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"minLength\": 1"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct WalletTransactionsCursor(::std::string::String);
    impl ::std::ops::Deref for WalletTransactionsCursor {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }
    impl ::std::convert::From<WalletTransactionsCursor> for ::std::string::String {
        fn from(value: WalletTransactionsCursor) -> Self {
            value.0
        }
    }
    impl ::std::convert::From<&WalletTransactionsCursor> for WalletTransactionsCursor {
        fn from(value: &WalletTransactionsCursor) -> Self {
            value.clone()
        }
    }
    impl ::std::str::FromStr for WalletTransactionsCursor {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }
    impl ::std::convert::TryFrom<&str> for WalletTransactionsCursor {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl<'de> ::serde::Deserialize<'de> for WalletTransactionsCursor {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }
    #[doc = "`WalletTransactionsResponse`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"examples\": ["]
    #[doc = "    {"]
    #[doc = "      \"next_cursor\": null,"]
    #[doc = "      \"transactions\": ["]
    #[doc = "        {"]
    #[doc = "          \"caip2\": \"eip155:8453\","]
    #[doc = "          \"created_at\": 1746920539240,"]
    #[doc = "          \"details\": {"]
    #[doc = "            \"asset\": \"eth\","]
    #[doc = "            \"chain\": \"base\","]
    #[doc = "            \"display_values\": {"]
    #[doc = "              \"eth\": \"0.000000000000000001\""]
    #[doc = "            },"]
    #[doc = "            \"raw_value\": \"1\","]
    #[doc = "            \"raw_value_decimals\": 18,"]
    #[doc = "            \"recipient\": \"0x38bc05d7b69f63d05337829fa5dc4896f179b5fa\","]
    #[doc = "            \"recipient_privy_user_id\": \"cmakymbpt000te63uaj85d9r6\","]
    #[doc = "            \"sender\": \"0xa24c8d74c913e5dba36e45236c478f37c8bba20e\","]
    #[doc = "            \"sender_privy_user_id\": \"rkiz0ivz254drv1xw982v3jq\","]
    #[doc = "            \"type\": \"transfer_sent\""]
    #[doc = "          },"]
    #[doc = "          \"privy_transaction_id\": \"au6wxoyhbw4yhwbn1s5v9gs9\","]
    #[doc = "          \"status\": \"confirmed\","]
    #[doc = "          \"transaction_hash\": \"0x03fe1b0fd11a74d277a5b7a68b762de906503b82cbce2fc791250fd2b77cf137\","]
    #[doc = "          \"wallet_id\": \"xs76o3pi0v5syd62ui1wmijw\""]
    #[doc = "        }"]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  ],"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"next_cursor\","]
    #[doc = "    \"transactions\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"next_cursor\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"transactions\": {"]
    #[doc = "      \"type\": \"array\","]
    #[doc = "      \"items\": {"]
    #[doc = "        \"type\": \"object\","]
    #[doc = "        \"required\": ["]
    #[doc = "          \"caip2\","]
    #[doc = "          \"created_at\","]
    #[doc = "          \"details\","]
    #[doc = "          \"privy_transaction_id\","]
    #[doc = "          \"status\","]
    #[doc = "          \"transaction_hash\","]
    #[doc = "          \"wallet_id\""]
    #[doc = "        ],"]
    #[doc = "        \"properties\": {"]
    #[doc = "          \"caip2\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"created_at\": {"]
    #[doc = "            \"type\": \"number\""]
    #[doc = "          },"]
    #[doc = "          \"details\": {"]
    #[doc = "            \"oneOf\": ["]
    #[doc = "              {"]
    #[doc = "                \"type\": \"object\","]
    #[doc = "                \"required\": ["]
    #[doc = "                  \"asset\","]
    #[doc = "                  \"chain\","]
    #[doc = "                  \"display_values\","]
    #[doc = "                  \"raw_value\","]
    #[doc = "                  \"raw_value_decimals\","]
    #[doc = "                  \"recipient\","]
    #[doc = "                  \"recipient_privy_user_id\","]
    #[doc = "                  \"sender\","]
    #[doc = "                  \"sender_privy_user_id\","]
    #[doc = "                  \"type\""]
    #[doc = "                ],"]
    #[doc = "                \"properties\": {"]
    #[doc = "                  \"asset\": {"]
    #[doc = "                    \"type\": \"string\","]
    #[doc = "                    \"enum\": ["]
    #[doc = "                      \"usdc\","]
    #[doc = "                      \"eth\","]
    #[doc = "                      \"pol\","]
    #[doc = "                      \"sol\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"chain\": {"]
    #[doc = "                    \"type\": \"string\","]
    #[doc = "                    \"enum\": ["]
    #[doc = "                      \"ethereum\","]
    #[doc = "                      \"arbitrum\","]
    #[doc = "                      \"base\","]
    #[doc = "                      \"linea\","]
    #[doc = "                      \"optimism\","]
    #[doc = "                      \"polygon\","]
    #[doc = "                      \"solana\","]
    #[doc = "                      \"zksync_era\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"display_values\": {"]
    #[doc = "                    \"type\": \"object\","]
    #[doc = "                    \"additionalProperties\": {"]
    #[doc = "                      \"type\": \"string\""]
    #[doc = "                    }"]
    #[doc = "                  },"]
    #[doc = "                  \"raw_value\": {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  \"raw_value_decimals\": {"]
    #[doc = "                    \"type\": \"number\""]
    #[doc = "                  },"]
    #[doc = "                  \"recipient\": {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  \"recipient_privy_user_id\": {"]
    #[doc = "                    \"type\": ["]
    #[doc = "                      \"string\","]
    #[doc = "                      \"null\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"sender\": {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  \"sender_privy_user_id\": {"]
    #[doc = "                    \"type\": ["]
    #[doc = "                      \"string\","]
    #[doc = "                      \"null\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"type\": {"]
    #[doc = "                    \"type\": \"string\","]
    #[doc = "                    \"enum\": ["]
    #[doc = "                      \"transfer_sent\""]
    #[doc = "                    ]"]
    #[doc = "                  }"]
    #[doc = "                }"]
    #[doc = "              },"]
    #[doc = "              {"]
    #[doc = "                \"type\": \"object\","]
    #[doc = "                \"required\": ["]
    #[doc = "                  \"asset\","]
    #[doc = "                  \"chain\","]
    #[doc = "                  \"display_values\","]
    #[doc = "                  \"raw_value\","]
    #[doc = "                  \"raw_value_decimals\","]
    #[doc = "                  \"recipient\","]
    #[doc = "                  \"recipient_privy_user_id\","]
    #[doc = "                  \"sender\","]
    #[doc = "                  \"sender_privy_user_id\","]
    #[doc = "                  \"type\""]
    #[doc = "                ],"]
    #[doc = "                \"properties\": {"]
    #[doc = "                  \"asset\": {"]
    #[doc = "                    \"type\": \"string\","]
    #[doc = "                    \"enum\": ["]
    #[doc = "                      \"usdc\","]
    #[doc = "                      \"eth\","]
    #[doc = "                      \"pol\","]
    #[doc = "                      \"sol\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"chain\": {"]
    #[doc = "                    \"type\": \"string\","]
    #[doc = "                    \"enum\": ["]
    #[doc = "                      \"ethereum\","]
    #[doc = "                      \"arbitrum\","]
    #[doc = "                      \"base\","]
    #[doc = "                      \"linea\","]
    #[doc = "                      \"optimism\","]
    #[doc = "                      \"polygon\","]
    #[doc = "                      \"solana\","]
    #[doc = "                      \"zksync_era\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"display_values\": {"]
    #[doc = "                    \"type\": \"object\","]
    #[doc = "                    \"additionalProperties\": {"]
    #[doc = "                      \"type\": \"string\""]
    #[doc = "                    }"]
    #[doc = "                  },"]
    #[doc = "                  \"raw_value\": {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  \"raw_value_decimals\": {"]
    #[doc = "                    \"type\": \"number\""]
    #[doc = "                  },"]
    #[doc = "                  \"recipient\": {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  \"recipient_privy_user_id\": {"]
    #[doc = "                    \"type\": ["]
    #[doc = "                      \"string\","]
    #[doc = "                      \"null\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"sender\": {"]
    #[doc = "                    \"type\": \"string\""]
    #[doc = "                  },"]
    #[doc = "                  \"sender_privy_user_id\": {"]
    #[doc = "                    \"type\": ["]
    #[doc = "                      \"string\","]
    #[doc = "                      \"null\""]
    #[doc = "                    ]"]
    #[doc = "                  },"]
    #[doc = "                  \"type\": {"]
    #[doc = "                    \"type\": \"string\","]
    #[doc = "                    \"enum\": ["]
    #[doc = "                      \"transfer_received\""]
    #[doc = "                    ]"]
    #[doc = "                  }"]
    #[doc = "                }"]
    #[doc = "              },"]
    #[doc = "              {}"]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"privy_transaction_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          },"]
    #[doc = "          \"sponsored\": {"]
    #[doc = "            \"type\": \"boolean\""]
    #[doc = "          },"]
    #[doc = "          \"status\": {"]
    #[doc = "            \"type\": \"string\","]
    #[doc = "            \"enum\": ["]
    #[doc = "              \"broadcasted\","]
    #[doc = "              \"confirmed\","]
    #[doc = "              \"execution_reverted\","]
    #[doc = "              \"failed\","]
    #[doc = "              \"replaced\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"transaction_hash\": {"]
    #[doc = "            \"type\": ["]
    #[doc = "              \"string\","]
    #[doc = "              \"null\""]
    #[doc = "            ]"]
    #[doc = "          },"]
    #[doc = "          \"wallet_id\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletTransactionsResponse {
        pub next_cursor: ::std::option::Option<::std::string::String>,
        pub transactions: ::std::vec::Vec<WalletTransactionsResponseTransactionsItem>,
    }
    impl ::std::convert::From<&WalletTransactionsResponse> for WalletTransactionsResponse {
        fn from(value: &WalletTransactionsResponse) -> Self {
            value.clone()
        }
    }
    impl WalletTransactionsResponse {
        pub fn builder() -> builder::WalletTransactionsResponse {
            Default::default()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItem`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"caip2\","]
    #[doc = "    \"created_at\","]
    #[doc = "    \"details\","]
    #[doc = "    \"privy_transaction_id\","]
    #[doc = "    \"status\","]
    #[doc = "    \"transaction_hash\","]
    #[doc = "    \"wallet_id\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"caip2\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"created_at\": {"]
    #[doc = "      \"type\": \"number\""]
    #[doc = "    },"]
    #[doc = "    \"details\": {"]
    #[doc = "      \"oneOf\": ["]
    #[doc = "        {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"asset\","]
    #[doc = "            \"chain\","]
    #[doc = "            \"display_values\","]
    #[doc = "            \"raw_value\","]
    #[doc = "            \"raw_value_decimals\","]
    #[doc = "            \"recipient\","]
    #[doc = "            \"recipient_privy_user_id\","]
    #[doc = "            \"sender\","]
    #[doc = "            \"sender_privy_user_id\","]
    #[doc = "            \"type\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"asset\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"usdc\","]
    #[doc = "                \"eth\","]
    #[doc = "                \"pol\","]
    #[doc = "                \"sol\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"chain\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"ethereum\","]
    #[doc = "                \"arbitrum\","]
    #[doc = "                \"base\","]
    #[doc = "                \"linea\","]
    #[doc = "                \"optimism\","]
    #[doc = "                \"polygon\","]
    #[doc = "                \"solana\","]
    #[doc = "                \"zksync_era\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"display_values\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"additionalProperties\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              }"]
    #[doc = "            },"]
    #[doc = "            \"raw_value\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"raw_value_decimals\": {"]
    #[doc = "              \"type\": \"number\""]
    #[doc = "            },"]
    #[doc = "            \"recipient\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"recipient_privy_user_id\": {"]
    #[doc = "              \"type\": ["]
    #[doc = "                \"string\","]
    #[doc = "                \"null\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"sender\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"sender_privy_user_id\": {"]
    #[doc = "              \"type\": ["]
    #[doc = "                \"string\","]
    #[doc = "                \"null\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"type\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"transfer_sent\""]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"required\": ["]
    #[doc = "            \"asset\","]
    #[doc = "            \"chain\","]
    #[doc = "            \"display_values\","]
    #[doc = "            \"raw_value\","]
    #[doc = "            \"raw_value_decimals\","]
    #[doc = "            \"recipient\","]
    #[doc = "            \"recipient_privy_user_id\","]
    #[doc = "            \"sender\","]
    #[doc = "            \"sender_privy_user_id\","]
    #[doc = "            \"type\""]
    #[doc = "          ],"]
    #[doc = "          \"properties\": {"]
    #[doc = "            \"asset\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"usdc\","]
    #[doc = "                \"eth\","]
    #[doc = "                \"pol\","]
    #[doc = "                \"sol\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"chain\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"ethereum\","]
    #[doc = "                \"arbitrum\","]
    #[doc = "                \"base\","]
    #[doc = "                \"linea\","]
    #[doc = "                \"optimism\","]
    #[doc = "                \"polygon\","]
    #[doc = "                \"solana\","]
    #[doc = "                \"zksync_era\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"display_values\": {"]
    #[doc = "              \"type\": \"object\","]
    #[doc = "              \"additionalProperties\": {"]
    #[doc = "                \"type\": \"string\""]
    #[doc = "              }"]
    #[doc = "            },"]
    #[doc = "            \"raw_value\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"raw_value_decimals\": {"]
    #[doc = "              \"type\": \"number\""]
    #[doc = "            },"]
    #[doc = "            \"recipient\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"recipient_privy_user_id\": {"]
    #[doc = "              \"type\": ["]
    #[doc = "                \"string\","]
    #[doc = "                \"null\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"sender\": {"]
    #[doc = "              \"type\": \"string\""]
    #[doc = "            },"]
    #[doc = "            \"sender_privy_user_id\": {"]
    #[doc = "              \"type\": ["]
    #[doc = "                \"string\","]
    #[doc = "                \"null\""]
    #[doc = "              ]"]
    #[doc = "            },"]
    #[doc = "            \"type\": {"]
    #[doc = "              \"type\": \"string\","]
    #[doc = "              \"enum\": ["]
    #[doc = "                \"transfer_received\""]
    #[doc = "              ]"]
    #[doc = "            }"]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        {}"]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"privy_transaction_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"sponsored\": {"]
    #[doc = "      \"type\": \"boolean\""]
    #[doc = "    },"]
    #[doc = "    \"status\": {"]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"broadcasted\","]
    #[doc = "        \"confirmed\","]
    #[doc = "        \"execution_reverted\","]
    #[doc = "        \"failed\","]
    #[doc = "        \"replaced\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"transaction_hash\": {"]
    #[doc = "      \"type\": ["]
    #[doc = "        \"string\","]
    #[doc = "        \"null\""]
    #[doc = "      ]"]
    #[doc = "    },"]
    #[doc = "    \"wallet_id\": {"]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletTransactionsResponseTransactionsItem {
        pub caip2: ::std::string::String,
        pub created_at: f64,
        pub details: WalletTransactionsResponseTransactionsItemDetails,
        pub privy_transaction_id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsored: ::std::option::Option<bool>,
        pub status: WalletTransactionsResponseTransactionsItemStatus,
        pub transaction_hash: ::std::option::Option<::std::string::String>,
        pub wallet_id: ::std::string::String,
    }
    impl ::std::convert::From<&WalletTransactionsResponseTransactionsItem>
        for WalletTransactionsResponseTransactionsItem
    {
        fn from(value: &WalletTransactionsResponseTransactionsItem) -> Self {
            value.clone()
        }
    }
    impl WalletTransactionsResponseTransactionsItem {
        pub fn builder() -> builder::WalletTransactionsResponseTransactionsItem {
            Default::default()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemDetails`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"oneOf\": ["]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"asset\","]
    #[doc = "        \"chain\","]
    #[doc = "        \"display_values\","]
    #[doc = "        \"raw_value\","]
    #[doc = "        \"raw_value_decimals\","]
    #[doc = "        \"recipient\","]
    #[doc = "        \"recipient_privy_user_id\","]
    #[doc = "        \"sender\","]
    #[doc = "        \"sender_privy_user_id\","]
    #[doc = "        \"type\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"asset\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"usdc\","]
    #[doc = "            \"eth\","]
    #[doc = "            \"pol\","]
    #[doc = "            \"sol\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"chain\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"ethereum\","]
    #[doc = "            \"arbitrum\","]
    #[doc = "            \"base\","]
    #[doc = "            \"linea\","]
    #[doc = "            \"optimism\","]
    #[doc = "            \"polygon\","]
    #[doc = "            \"solana\","]
    #[doc = "            \"zksync_era\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"display_values\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"additionalProperties\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"raw_value\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"raw_value_decimals\": {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        },"]
    #[doc = "        \"recipient\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"recipient_privy_user_id\": {"]
    #[doc = "          \"type\": ["]
    #[doc = "            \"string\","]
    #[doc = "            \"null\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"sender\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"sender_privy_user_id\": {"]
    #[doc = "          \"type\": ["]
    #[doc = "            \"string\","]
    #[doc = "            \"null\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"type\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"transfer_sent\""]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {"]
    #[doc = "      \"type\": \"object\","]
    #[doc = "      \"required\": ["]
    #[doc = "        \"asset\","]
    #[doc = "        \"chain\","]
    #[doc = "        \"display_values\","]
    #[doc = "        \"raw_value\","]
    #[doc = "        \"raw_value_decimals\","]
    #[doc = "        \"recipient\","]
    #[doc = "        \"recipient_privy_user_id\","]
    #[doc = "        \"sender\","]
    #[doc = "        \"sender_privy_user_id\","]
    #[doc = "        \"type\""]
    #[doc = "      ],"]
    #[doc = "      \"properties\": {"]
    #[doc = "        \"asset\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"usdc\","]
    #[doc = "            \"eth\","]
    #[doc = "            \"pol\","]
    #[doc = "            \"sol\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"chain\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"ethereum\","]
    #[doc = "            \"arbitrum\","]
    #[doc = "            \"base\","]
    #[doc = "            \"linea\","]
    #[doc = "            \"optimism\","]
    #[doc = "            \"polygon\","]
    #[doc = "            \"solana\","]
    #[doc = "            \"zksync_era\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"display_values\": {"]
    #[doc = "          \"type\": \"object\","]
    #[doc = "          \"additionalProperties\": {"]
    #[doc = "            \"type\": \"string\""]
    #[doc = "          }"]
    #[doc = "        },"]
    #[doc = "        \"raw_value\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"raw_value_decimals\": {"]
    #[doc = "          \"type\": \"number\""]
    #[doc = "        },"]
    #[doc = "        \"recipient\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"recipient_privy_user_id\": {"]
    #[doc = "          \"type\": ["]
    #[doc = "            \"string\","]
    #[doc = "            \"null\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"sender\": {"]
    #[doc = "          \"type\": \"string\""]
    #[doc = "        },"]
    #[doc = "        \"sender_privy_user_id\": {"]
    #[doc = "          \"type\": ["]
    #[doc = "            \"string\","]
    #[doc = "            \"null\""]
    #[doc = "          ]"]
    #[doc = "        },"]
    #[doc = "        \"type\": {"]
    #[doc = "          \"type\": \"string\","]
    #[doc = "          \"enum\": ["]
    #[doc = "            \"transfer_received\""]
    #[doc = "          ]"]
    #[doc = "        }"]
    #[doc = "      }"]
    #[doc = "    },"]
    #[doc = "    {}"]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletTransactionsResponseTransactionsItemDetails {
        Variant0 {
            asset: WalletTransactionsResponseTransactionsItemDetailsVariant0Asset,
            chain: WalletTransactionsResponseTransactionsItemDetailsVariant0Chain,
            display_values:
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            raw_value: ::std::string::String,
            raw_value_decimals: f64,
            recipient: ::std::string::String,
            recipient_privy_user_id: ::std::option::Option<::std::string::String>,
            sender: ::std::string::String,
            sender_privy_user_id: ::std::option::Option<::std::string::String>,
            #[serde(rename = "type")]
            type_: WalletTransactionsResponseTransactionsItemDetailsVariant0Type,
        },
        Variant1 {
            asset: WalletTransactionsResponseTransactionsItemDetailsVariant1Asset,
            chain: WalletTransactionsResponseTransactionsItemDetailsVariant1Chain,
            display_values:
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            raw_value: ::std::string::String,
            raw_value_decimals: f64,
            recipient: ::std::string::String,
            recipient_privy_user_id: ::std::option::Option<::std::string::String>,
            sender: ::std::string::String,
            sender_privy_user_id: ::std::option::Option<::std::string::String>,
            #[serde(rename = "type")]
            type_: WalletTransactionsResponseTransactionsItemDetailsVariant1Type,
        },
        Variant2(::serde_json::Value),
    }
    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemDetails {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetails) -> Self {
            value.clone()
        }
    }
    impl ::std::convert::From<::serde_json::Value>
        for WalletTransactionsResponseTransactionsItemDetails
    {
        fn from(value: ::serde_json::Value) -> Self {
            Self::Variant2(value)
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemDetailsVariant0Asset`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\","]
    #[doc = "    \"eth\","]
    #[doc = "    \"pol\","]
    #[doc = "    \"sol\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant0Asset {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "sol")]
        Sol,
    }
    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant0Asset) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemDetailsVariant0Chain`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"arbitrum\","]
    #[doc = "    \"base\","]
    #[doc = "    \"linea\","]
    #[doc = "    \"optimism\","]
    #[doc = "    \"polygon\","]
    #[doc = "    \"solana\","]
    #[doc = "    \"zksync_era\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant0Chain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }
    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant0Chain) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemDetailsVariant0Type`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"transfer_sent\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        #[serde(rename = "transfer_sent")]
        TransferSent,
    }
    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant0Type) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TransferSent => f.write_str("transfer_sent"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "transfer_sent" => Ok(Self::TransferSent),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Type
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemDetailsVariant1Asset`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"usdc\","]
    #[doc = "    \"eth\","]
    #[doc = "    \"pol\","]
    #[doc = "    \"sol\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant1Asset {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "sol")]
        Sol,
    }
    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant1Asset) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemDetailsVariant1Chain`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"ethereum\","]
    #[doc = "    \"arbitrum\","]
    #[doc = "    \"base\","]
    #[doc = "    \"linea\","]
    #[doc = "    \"optimism\","]
    #[doc = "    \"polygon\","]
    #[doc = "    \"solana\","]
    #[doc = "    \"zksync_era\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant1Chain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }
    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant1Chain) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemDetailsVariant1Type`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"transfer_received\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        #[serde(rename = "transfer_received")]
        TransferReceived,
    }
    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant1Type) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TransferReceived => f.write_str("transfer_received"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "transfer_received" => Ok(Self::TransferReceived),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Type
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "`WalletTransactionsResponseTransactionsItemStatus`"]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"broadcasted\","]
    #[doc = "    \"confirmed\","]
    #[doc = "    \"execution_reverted\","]
    #[doc = "    \"failed\","]
    #[doc = "    \"replaced\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemStatus {
        #[serde(rename = "broadcasted")]
        Broadcasted,
        #[serde(rename = "confirmed")]
        Confirmed,
        #[serde(rename = "execution_reverted")]
        ExecutionReverted,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "replaced")]
        Replaced,
    }
    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemStatus {
        fn from(value: &WalletTransactionsResponseTransactionsItemStatus) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Broadcasted => f.write_str("broadcasted"),
                Self::Confirmed => f.write_str("confirmed"),
                Self::ExecutionReverted => f.write_str("execution_reverted"),
                Self::Failed => f.write_str("failed"),
                Self::Replaced => f.write_str("replaced"),
            }
        }
    }
    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "broadcasted" => Ok(Self::Broadcasted),
                "confirmed" => Ok(Self::Confirmed),
                "execution_reverted" => Ok(Self::ExecutionReverted),
                "failed" => Ok(Self::Failed),
                "replaced" => Ok(Self::Replaced),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WalletTransactionsResponseTransactionsItemStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = "The encrypted authorization key data."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The encrypted authorization key data.\","]
    #[doc = "  \"type\": \"object\","]
    #[doc = "  \"required\": ["]
    #[doc = "    \"ciphertext\","]
    #[doc = "    \"encapsulated_key\","]
    #[doc = "    \"encryption_type\""]
    #[doc = "  ],"]
    #[doc = "  \"properties\": {"]
    #[doc = "    \"ciphertext\": {"]
    #[doc = "      \"description\": \"The encrypted authorization key corresponding to the user's current authentication session.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encapsulated_key\": {"]
    #[doc = "      \"description\": \"Base64-encoded ephemeral public key used in the HPKE encryption process. Required for decryption.\","]
    #[doc = "      \"type\": \"string\""]
    #[doc = "    },"]
    #[doc = "    \"encryption_type\": {"]
    #[doc = "      \"description\": \"The encryption type used. Currently only supports HPKE.\","]
    #[doc = "      \"type\": \"string\","]
    #[doc = "      \"enum\": ["]
    #[doc = "        \"HPKE\""]
    #[doc = "      ]"]
    #[doc = "    }"]
    #[doc = "  }"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WithEncryptionEncryptedAuthorizationKey {
        #[doc = "The encrypted authorization key corresponding to the user's current authentication session."]
        pub ciphertext: ::std::string::String,
        #[doc = "Base64-encoded ephemeral public key used in the HPKE encryption process. Required for decryption."]
        pub encapsulated_key: ::std::string::String,
        #[doc = "The encryption type used. Currently only supports HPKE."]
        pub encryption_type: WithEncryptionEncryptedAuthorizationKeyEncryptionType,
    }
    impl ::std::convert::From<&WithEncryptionEncryptedAuthorizationKey>
        for WithEncryptionEncryptedAuthorizationKey
    {
        fn from(value: &WithEncryptionEncryptedAuthorizationKey) -> Self {
            value.clone()
        }
    }
    impl WithEncryptionEncryptedAuthorizationKey {
        pub fn builder() -> builder::WithEncryptionEncryptedAuthorizationKey {
            Default::default()
        }
    }
    #[doc = "The encryption type used. Currently only supports HPKE."]
    #[doc = r""]
    #[doc = r" <details><summary>JSON schema</summary>"]
    #[doc = r""]
    #[doc = r" ```json"]
    #[doc = "{"]
    #[doc = "  \"description\": \"The encryption type used. Currently only supports HPKE.\","]
    #[doc = "  \"type\": \"string\","]
    #[doc = "  \"enum\": ["]
    #[doc = "    \"HPKE\""]
    #[doc = "  ]"]
    #[doc = "}"]
    #[doc = r" ```"]
    #[doc = r" </details>"]
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        #[serde(rename = "HPKE")]
        Hpke,
    }
    impl ::std::convert::From<&Self> for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        fn from(value: &WithEncryptionEncryptedAuthorizationKeyEncryptionType) -> Self {
            value.clone()
        }
    }
    impl ::std::fmt::Display for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hpke => f.write_str("HPKE"),
            }
        }
    }
    impl ::std::str::FromStr for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "HPKE" => Ok(Self::Hpke),
                _ => Err("invalid value".into()),
            }
        }
    }
    impl ::std::convert::TryFrom<&str> for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<&::std::string::String>
        for WithEncryptionEncryptedAuthorizationKeyEncryptionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    impl ::std::convert::TryFrom<::std::string::String>
        for WithEncryptionEncryptedAuthorizationKeyEncryptionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
    #[doc = r" Types for composing complex structures."]
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct AuthenticateBody {
            encryption_type: ::std::result::Result<
                ::std::option::Option<super::AuthenticateBodyEncryptionType>,
                ::std::string::String,
            >,
            recipient_public_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            user_jwt: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for AuthenticateBody {
            fn default() -> Self {
                Self {
                    encryption_type: Ok(Default::default()),
                    recipient_public_key: Ok(Default::default()),
                    user_jwt: Err("no value supplied for user_jwt".to_string()),
                }
            }
        }
        impl AuthenticateBody {
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::AuthenticateBodyEncryptionType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
            pub fn recipient_public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.recipient_public_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for recipient_public_key: {}",
                        e
                    )
                });
                self
            }
            pub fn user_jwt<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_jwt = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_jwt: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<AuthenticateBody> for super::AuthenticateBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AuthenticateBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encryption_type: value.encryption_type?,
                    recipient_public_key: value.recipient_public_key?,
                    user_jwt: value.user_jwt?,
                })
            }
        }
        impl ::std::convert::From<super::AuthenticateBody> for AuthenticateBody {
            fn from(value: super::AuthenticateBody) -> Self {
                Self {
                    encryption_type: Ok(value.encryption_type),
                    recipient_public_key: Ok(value.recipient_public_key),
                    user_jwt: Ok(value.user_jwt),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserBody {
            custom_metadata: ::std::result::Result<
                ::std::option::Option<super::CustomMetadata>,
                ::std::string::String,
            >,
            linked_accounts: ::std::result::Result<
                ::std::vec::Vec<super::LinkedAccountInput>,
                ::std::string::String,
            >,
            wallets: ::std::result::Result<
                ::std::vec::Vec<super::CreateUserBodyWalletsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateUserBody {
            fn default() -> Self {
                Self {
                    custom_metadata: Ok(Default::default()),
                    linked_accounts: Err("no value supplied for linked_accounts".to_string()),
                    wallets: Ok(Default::default()),
                }
            }
        }
        impl CreateUserBody {
            pub fn custom_metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::CustomMetadata>>,
                T::Error: ::std::fmt::Display,
            {
                self.custom_metadata = value.try_into().map_err(|e| {
                    format!("error converting supplied value for custom_metadata: {}", e)
                });
                self
            }
            pub fn linked_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::LinkedAccountInput>>,
                T::Error: ::std::fmt::Display,
            {
                self.linked_accounts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for linked_accounts: {}", e)
                });
                self
            }
            pub fn wallets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::CreateUserBodyWalletsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.wallets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for wallets: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserBody> for super::CreateUserBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    custom_metadata: value.custom_metadata?,
                    linked_accounts: value.linked_accounts?,
                    wallets: value.wallets?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserBody> for CreateUserBody {
            fn from(value: super::CreateUserBody) -> Self {
                Self {
                    custom_metadata: Ok(value.custom_metadata),
                    linked_accounts: Ok(value.linked_accounts),
                    wallets: Ok(value.wallets),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserBodyWalletsItem {
            additional_signers: ::std::result::Result<
                ::std::vec::Vec<super::CreateUserBodyWalletsItemAdditionalSignersItem>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<super::WalletChainType, ::std::string::String>,
            create_smart_wallet:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            policy_ids: ::std::result::Result<
                ::std::vec::Vec<super::CreateUserBodyWalletsItemPolicyIdsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateUserBodyWalletsItem {
            fn default() -> Self {
                Self {
                    additional_signers: Ok(Default::default()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    create_smart_wallet: Ok(Default::default()),
                    policy_ids: Ok(Default::default()),
                }
            }
        }
        impl CreateUserBodyWalletsItem {
            pub fn additional_signers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::CreateUserBodyWalletsItemAdditionalSignersItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.additional_signers = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for additional_signers: {}",
                        e
                    )
                });
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn create_smart_wallet<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.create_smart_wallet = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for create_smart_wallet: {}",
                        e
                    )
                });
                self
            }
            pub fn policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::CreateUserBodyWalletsItemPolicyIdsItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.policy_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_ids: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserBodyWalletsItem> for super::CreateUserBodyWalletsItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserBodyWalletsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    additional_signers: value.additional_signers?,
                    chain_type: value.chain_type?,
                    create_smart_wallet: value.create_smart_wallet?,
                    policy_ids: value.policy_ids?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserBodyWalletsItem> for CreateUserBodyWalletsItem {
            fn from(value: super::CreateUserBodyWalletsItem) -> Self {
                Self {
                    additional_signers: Ok(value.additional_signers),
                    chain_type: Ok(value.chain_type),
                    create_smart_wallet: Ok(value.create_smart_wallet),
                    policy_ids: Ok(value.policy_ids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserBodyWalletsItemAdditionalSignersItem {
            override_policy_ids: ::std::result::Result<
                ::std::vec::Vec<
                    super::CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem,
                >,
                ::std::string::String,
            >,
            signer_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateUserBodyWalletsItemAdditionalSignersItem {
            fn default() -> Self {
                Self {
                    override_policy_ids: Ok(Default::default()),
                    signer_id: Err("no value supplied for signer_id".to_string()),
                }
            }
        }
        impl CreateUserBodyWalletsItemAdditionalSignersItem {
            pub fn override_policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<
                        super::CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.override_policy_ids = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for override_policy_ids: {}",
                        e
                    )
                });
                self
            }
            pub fn signer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signer_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserBodyWalletsItemAdditionalSignersItem>
            for super::CreateUserBodyWalletsItemAdditionalSignersItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserBodyWalletsItemAdditionalSignersItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    override_policy_ids: value.override_policy_ids?,
                    signer_id: value.signer_id?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserBodyWalletsItemAdditionalSignersItem>
            for CreateUserBodyWalletsItemAdditionalSignersItem
        {
            fn from(value: super::CreateUserBodyWalletsItemAdditionalSignersItem) -> Self {
                Self {
                    override_policy_ids: Ok(value.override_policy_ids),
                    signer_id: Ok(value.signer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserWalletBody {
            wallets: ::std::result::Result<
                ::std::vec::Vec<super::CreateUserWalletBodyWalletsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateUserWalletBody {
            fn default() -> Self {
                Self {
                    wallets: Err("no value supplied for wallets".to_string()),
                }
            }
        }
        impl CreateUserWalletBody {
            pub fn wallets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::CreateUserWalletBodyWalletsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.wallets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for wallets: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserWalletBody> for super::CreateUserWalletBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserWalletBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    wallets: value.wallets?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserWalletBody> for CreateUserWalletBody {
            fn from(value: super::CreateUserWalletBody) -> Self {
                Self {
                    wallets: Ok(value.wallets),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserWalletBodyWalletsItem {
            additional_signers: ::std::result::Result<
                ::std::vec::Vec<super::CreateUserWalletBodyWalletsItemAdditionalSignersItem>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                super::CreateUserWalletBodyWalletsItemChainType,
                ::std::string::String,
            >,
            create_smart_wallet:
                ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            policy_ids: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateUserWalletBodyWalletsItem {
            fn default() -> Self {
                Self {
                    additional_signers: Ok(Default::default()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    create_smart_wallet: Ok(Default::default()),
                    policy_ids: Ok(Default::default()),
                }
            }
        }
        impl CreateUserWalletBodyWalletsItem {
            pub fn additional_signers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::CreateUserWalletBodyWalletsItemAdditionalSignersItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.additional_signers = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for additional_signers: {}",
                        e
                    )
                });
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::CreateUserWalletBodyWalletsItemChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn create_smart_wallet<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.create_smart_wallet = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for create_smart_wallet: {}",
                        e
                    )
                });
                self
            }
            pub fn policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_ids: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserWalletBodyWalletsItem>
            for super::CreateUserWalletBodyWalletsItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserWalletBodyWalletsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    additional_signers: value.additional_signers?,
                    chain_type: value.chain_type?,
                    create_smart_wallet: value.create_smart_wallet?,
                    policy_ids: value.policy_ids?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserWalletBodyWalletsItem>
            for CreateUserWalletBodyWalletsItem
        {
            fn from(value: super::CreateUserWalletBodyWalletsItem) -> Self {
                Self {
                    additional_signers: Ok(value.additional_signers),
                    chain_type: Ok(value.chain_type),
                    create_smart_wallet: Ok(value.create_smart_wallet),
                    policy_ids: Ok(value.policy_ids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserWalletBodyWalletsItemAdditionalSignersItem {
            override_policy_ids: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            signer_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateUserWalletBodyWalletsItemAdditionalSignersItem {
            fn default() -> Self {
                Self {
                    override_policy_ids: Ok(Default::default()),
                    signer_id: Err("no value supplied for signer_id".to_string()),
                }
            }
        }
        impl CreateUserWalletBodyWalletsItemAdditionalSignersItem {
            pub fn override_policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.override_policy_ids = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for override_policy_ids: {}",
                        e
                    )
                });
                self
            }
            pub fn signer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signer_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserWalletBodyWalletsItemAdditionalSignersItem>
            for super::CreateUserWalletBodyWalletsItemAdditionalSignersItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserWalletBodyWalletsItemAdditionalSignersItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    override_policy_ids: value.override_policy_ids?,
                    signer_id: value.signer_id?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserWalletBodyWalletsItemAdditionalSignersItem>
            for CreateUserWalletBodyWalletsItemAdditionalSignersItem
        {
            fn from(value: super::CreateUserWalletBodyWalletsItemAdditionalSignersItem) -> Self {
                Self {
                    override_policy_ids: Ok(value.override_policy_ids),
                    signer_id: Ok(value.signer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateUserWalletBodyWalletsItemChainType {
            subtype_0: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype0>,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype1>,
                ::std::string::String,
            >,
            subtype_2: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype2>,
                ::std::string::String,
            >,
            subtype_3: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype3>,
                ::std::string::String,
            >,
            subtype_4: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype4>,
                ::std::string::String,
            >,
            subtype_5: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype5>,
                ::std::string::String,
            >,
            subtype_6: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype6>,
                ::std::string::String,
            >,
            subtype_7: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype7>,
                ::std::string::String,
            >,
            subtype_8: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype8>,
                ::std::string::String,
            >,
            subtype_9: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype9>,
                ::std::string::String,
            >,
            subtype_10: ::std::result::Result<
                ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype10>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateUserWalletBodyWalletsItemChainType {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                    subtype_2: Ok(Default::default()),
                    subtype_3: Ok(Default::default()),
                    subtype_4: Ok(Default::default()),
                    subtype_5: Ok(Default::default()),
                    subtype_6: Ok(Default::default()),
                    subtype_7: Ok(Default::default()),
                    subtype_8: Ok(Default::default()),
                    subtype_9: Ok(Default::default()),
                    subtype_10: Ok(Default::default()),
                }
            }
        }
        impl CreateUserWalletBodyWalletsItemChainType {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype0>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype1>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
            pub fn subtype_2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
                self
            }
            pub fn subtype_3<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype3>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_3 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_3: {}", e));
                self
            }
            pub fn subtype_4<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype4>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_4 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_4: {}", e));
                self
            }
            pub fn subtype_5<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype5>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_5 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_5: {}", e));
                self
            }
            pub fn subtype_6<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype6>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_6 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_6: {}", e));
                self
            }
            pub fn subtype_7<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype7>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_7 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_7: {}", e));
                self
            }
            pub fn subtype_8<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype8>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_8 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_8: {}", e));
                self
            }
            pub fn subtype_9<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype9>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_9 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_9: {}", e));
                self
            }
            pub fn subtype_10<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::CreateUserWalletBodyWalletsItemChainTypeSubtype10>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_10 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_10: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateUserWalletBodyWalletsItemChainType>
            for super::CreateUserWalletBodyWalletsItemChainType
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateUserWalletBodyWalletsItemChainType,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                    subtype_2: value.subtype_2?,
                    subtype_3: value.subtype_3?,
                    subtype_4: value.subtype_4?,
                    subtype_5: value.subtype_5?,
                    subtype_6: value.subtype_6?,
                    subtype_7: value.subtype_7?,
                    subtype_8: value.subtype_8?,
                    subtype_9: value.subtype_9?,
                    subtype_10: value.subtype_10?,
                })
            }
        }
        impl ::std::convert::From<super::CreateUserWalletBodyWalletsItemChainType>
            for CreateUserWalletBodyWalletsItemChainType
        {
            fn from(value: super::CreateUserWalletBodyWalletsItemChainType) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                    subtype_2: Ok(value.subtype_2),
                    subtype_3: Ok(value.subtype_3),
                    subtype_4: Ok(value.subtype_4),
                    subtype_5: Ok(value.subtype_5),
                    subtype_6: Ok(value.subtype_6),
                    subtype_7: Ok(value.subtype_7),
                    subtype_8: Ok(value.subtype_8),
                    subtype_9: Ok(value.subtype_9),
                    subtype_10: Ok(value.subtype_10),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateWalletBody {
            additional_signers: ::std::result::Result<
                ::std::option::Option<super::WalletAdditionalSigner>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<super::WalletChainType, ::std::string::String>,
            owner: ::std::result::Result<
                ::std::option::Option<super::OwnerInput>,
                ::std::string::String,
            >,
            owner_id: ::std::result::Result<
                ::std::option::Option<super::OwnerIdInput>,
                ::std::string::String,
            >,
            policy_ids: ::std::result::Result<
                ::std::vec::Vec<super::CreateWalletBodyPolicyIdsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateWalletBody {
            fn default() -> Self {
                Self {
                    additional_signers: Ok(Default::default()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    owner: Ok(Default::default()),
                    owner_id: Ok(Default::default()),
                    policy_ids: Ok(Default::default()),
                }
            }
        }
        impl CreateWalletBody {
            pub fn additional_signers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::WalletAdditionalSigner>>,
                T::Error: ::std::fmt::Display,
            {
                self.additional_signers = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for additional_signers: {}",
                        e
                    )
                });
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OwnerInput>>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner: {}", e));
                self
            }
            pub fn owner_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OwnerIdInput>>,
                T::Error: ::std::fmt::Display,
            {
                self.owner_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner_id: {}", e));
                self
            }
            pub fn policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::CreateWalletBodyPolicyIdsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_ids: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateWalletBody> for super::CreateWalletBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateWalletBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    additional_signers: value.additional_signers?,
                    chain_type: value.chain_type?,
                    owner: value.owner?,
                    owner_id: value.owner_id?,
                    policy_ids: value.policy_ids?,
                })
            }
        }
        impl ::std::convert::From<super::CreateWalletBody> for CreateWalletBody {
            fn from(value: super::CreateWalletBody) -> Self {
                Self {
                    additional_signers: Ok(value.additional_signers),
                    chain_type: Ok(value.chain_type),
                    owner: Ok(value.owner),
                    owner_id: Ok(value.owner_id),
                    policy_ids: Ok(value.policy_ids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Ethereum7702AuthorizationCondition {
            field: ::std::result::Result<
                super::Ethereum7702AuthorizationConditionField,
                ::std::string::String,
            >,
            field_source: ::std::result::Result<
                super::Ethereum7702AuthorizationConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for Ethereum7702AuthorizationCondition {
            fn default() -> Self {
                Self {
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl Ethereum7702AuthorizationCondition {
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ethereum7702AuthorizationConditionField>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ethereum7702AuthorizationConditionFieldSource>,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Ethereum7702AuthorizationCondition>
            for super::Ethereum7702AuthorizationCondition
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Ethereum7702AuthorizationCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::Ethereum7702AuthorizationCondition>
            for Ethereum7702AuthorizationCondition
        {
            fn from(value: super::Ethereum7702AuthorizationCondition) -> Self {
                Self {
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumCalldataCondition {
            abi: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            field: ::std::result::Result<::std::string::String, ::std::string::String>,
            field_source: ::std::result::Result<
                super::EthereumCalldataConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumCalldataCondition {
            fn default() -> Self {
                Self {
                    abi: Err("no value supplied for abi".to_string()),
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EthereumCalldataCondition {
            pub fn abi<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.abi = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for abi: {}", e));
                self
            }
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumCalldataConditionFieldSource>,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumCalldataCondition> for super::EthereumCalldataCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumCalldataCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    abi: value.abi?,
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumCalldataCondition> for EthereumCalldataCondition {
            fn from(value: super::EthereumCalldataCondition) -> Self {
                Self {
                    abi: Ok(value.abi),
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumPersonalSignRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::EthereumPersonalSignRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumPersonalSignRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::EthereumPersonalSignRpcInputParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumPersonalSignRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl EthereumPersonalSignRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumPersonalSignRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumPersonalSignRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumPersonalSignRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumPersonalSignRpcInput> for super::EthereumPersonalSignRpcInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumPersonalSignRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumPersonalSignRpcInput> for EthereumPersonalSignRpcInput {
            fn from(value: super::EthereumPersonalSignRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumPersonalSignRpcInputParams {
            encoding: ::std::result::Result<
                super::EthereumPersonalSignRpcInputParamsEncoding,
                ::std::string::String,
            >,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumPersonalSignRpcInputParams {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl EthereumPersonalSignRpcInputParams {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumPersonalSignRpcInputParamsEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumPersonalSignRpcInputParams>
            for super::EthereumPersonalSignRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumPersonalSignRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumPersonalSignRpcInputParams>
            for EthereumPersonalSignRpcInputParams
        {
            fn from(value: super::EthereumPersonalSignRpcInputParams) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumPersonalSignRpcInputParamsEncoding {
            subtype_0: ::std::result::Result<
                ::std::option::Option<super::EthereumPersonalSignRpcInputParamsEncodingSubtype0>,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<super::EthereumPersonalSignRpcInputParamsEncodingSubtype1>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumPersonalSignRpcInputParamsEncoding {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                }
            }
        }
        impl EthereumPersonalSignRpcInputParamsEncoding {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumPersonalSignRpcInputParamsEncodingSubtype0,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumPersonalSignRpcInputParamsEncodingSubtype1,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumPersonalSignRpcInputParamsEncoding>
            for super::EthereumPersonalSignRpcInputParamsEncoding
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumPersonalSignRpcInputParamsEncoding,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumPersonalSignRpcInputParamsEncoding>
            for EthereumPersonalSignRpcInputParamsEncoding
        {
            fn from(value: super::EthereumPersonalSignRpcInputParamsEncoding) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumPersonalSignRpcResponse {
            data: ::std::result::Result<
                super::EthereumPersonalSignRpcResponseData,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumPersonalSignRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumPersonalSignRpcResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl EthereumPersonalSignRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumPersonalSignRpcResponseData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumPersonalSignRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumPersonalSignRpcResponse>
            for super::EthereumPersonalSignRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumPersonalSignRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumPersonalSignRpcResponse>
            for EthereumPersonalSignRpcResponse
        {
            fn from(value: super::EthereumPersonalSignRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumPersonalSignRpcResponseData {
            encoding: ::std::result::Result<
                super::EthereumPersonalSignRpcResponseDataEncoding,
                ::std::string::String,
            >,
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumPersonalSignRpcResponseData {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl EthereumPersonalSignRpcResponseData {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumPersonalSignRpcResponseDataEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumPersonalSignRpcResponseData>
            for super::EthereumPersonalSignRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumPersonalSignRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumPersonalSignRpcResponseData>
            for EthereumPersonalSignRpcResponseData
        {
            fn from(value: super::EthereumPersonalSignRpcResponseData) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSecp256k1SignRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::EthereumSecp256k1SignRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSecp256k1SignRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::EthereumSecp256k1SignRpcInputParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSecp256k1SignRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl EthereumSecp256k1SignRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSecp256k1SignRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSecp256k1SignRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSecp256k1SignRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSecp256k1SignRpcInput>
            for super::EthereumSecp256k1SignRpcInput
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSecp256k1SignRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSecp256k1SignRpcInput> for EthereumSecp256k1SignRpcInput {
            fn from(value: super::EthereumSecp256k1SignRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSecp256k1SignRpcInputParams {
            hash: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSecp256k1SignRpcInputParams {
            fn default() -> Self {
                Self {
                    hash: Err("no value supplied for hash".to_string()),
                }
            }
        }
        impl EthereumSecp256k1SignRpcInputParams {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hash: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSecp256k1SignRpcInputParams>
            for super::EthereumSecp256k1SignRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSecp256k1SignRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { hash: value.hash? })
            }
        }
        impl ::std::convert::From<super::EthereumSecp256k1SignRpcInputParams>
            for EthereumSecp256k1SignRpcInputParams
        {
            fn from(value: super::EthereumSecp256k1SignRpcInputParams) -> Self {
                Self {
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSecp256k1SignRpcResponse {
            data: ::std::result::Result<
                super::EthereumSecp256k1SignRpcResponseData,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSecp256k1SignRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSecp256k1SignRpcResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl EthereumSecp256k1SignRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSecp256k1SignRpcResponseData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSecp256k1SignRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSecp256k1SignRpcResponse>
            for super::EthereumSecp256k1SignRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSecp256k1SignRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSecp256k1SignRpcResponse>
            for EthereumSecp256k1SignRpcResponse
        {
            fn from(value: super::EthereumSecp256k1SignRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSecp256k1SignRpcResponseData {
            encoding: ::std::result::Result<
                super::EthereumSecp256k1SignRpcResponseDataEncoding,
                ::std::string::String,
            >,
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSecp256k1SignRpcResponseData {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl EthereumSecp256k1SignRpcResponseData {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSecp256k1SignRpcResponseDataEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSecp256k1SignRpcResponseData>
            for super::EthereumSecp256k1SignRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSecp256k1SignRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSecp256k1SignRpcResponseData>
            for EthereumSecp256k1SignRpcResponseData
        {
            fn from(value: super::EthereumSecp256k1SignRpcResponseData) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            caip2: ::std::result::Result<
                super::EthereumSendTransactionRpcInputCaip2,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::EthereumSendTransactionRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSendTransactionRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::EthereumSendTransactionRpcInputParams,
                ::std::string::String,
            >,
            sponsor: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    caip2: Err("no value supplied for caip2".to_string()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                    sponsor: Ok(Default::default()),
                }
            }
        }
        impl EthereumSendTransactionRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn caip2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSendTransactionRpcInputCaip2>,
                T::Error: ::std::fmt::Display,
            {
                self.caip2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for caip2: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSendTransactionRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSendTransactionRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSendTransactionRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
            pub fn sponsor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sponsor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sponsor: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcInput>
            for super::EthereumSendTransactionRpcInput
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    caip2: value.caip2?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                    sponsor: value.sponsor?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcInput>
            for EthereumSendTransactionRpcInput
        {
            fn from(value: super::EthereumSendTransactionRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    caip2: Ok(value.caip2),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                    sponsor: Ok(value.sponsor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcInputParams {
            transaction: ::std::result::Result<
                super::EthereumSendTransactionRpcInputParamsTransaction,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcInputParams {
            fn default() -> Self {
                Self {
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl EthereumSendTransactionRpcInputParams {
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSendTransactionRpcInputParamsTransaction>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcInputParams>
            for super::EthereumSendTransactionRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcInputParams>
            for EthereumSendTransactionRpcInputParams
        {
            fn from(value: super::EthereumSendTransactionRpcInputParams) -> Self {
                Self {
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcInputParamsTransaction {
            chain_id: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionChainId,
                >,
                ::std::string::String,
            >,
            data: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            from: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            gas_limit: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionGasLimit,
                >,
                ::std::string::String,
            >,
            gas_price: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionGasPrice,
                >,
                ::std::string::String,
            >,
            max_fee_per_gas: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas,
                >,
                ::std::string::String,
            >,
            max_priority_fee_per_gas: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
                >,
                ::std::string::String,
            >,
            nonce: ::std::result::Result<
                ::std::option::Option<super::EthereumSendTransactionRpcInputParamsTransactionNonce>,
                ::std::string::String,
            >,
            to: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<super::EthereumSendTransactionRpcInputParamsTransactionType>,
                ::std::string::String,
            >,
            value: ::std::result::Result<
                ::std::option::Option<super::EthereumSendTransactionRpcInputParamsTransactionValue>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcInputParamsTransaction {
            fn default() -> Self {
                Self {
                    chain_id: Ok(Default::default()),
                    data: Ok(Default::default()),
                    from: Ok(Default::default()),
                    gas_limit: Ok(Default::default()),
                    gas_price: Ok(Default::default()),
                    max_fee_per_gas: Ok(Default::default()),
                    max_priority_fee_per_gas: Ok(Default::default()),
                    nonce: Ok(Default::default()),
                    to: Ok(Default::default()),
                    type_: Ok(Default::default()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl EthereumSendTransactionRpcInputParamsTransaction {
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionChainId,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn from<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.from = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from: {}", e));
                self
            }
            pub fn gas_limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionGasLimit,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.gas_limit = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_limit: {}", e));
                self
            }
            pub fn gas_price<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionGasPrice,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.gas_price = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_price: {}", e));
                self
            }
            pub fn max_fee_per_gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.max_fee_per_gas = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_fee_per_gas: {}", e)
                });
                self
            }
            pub fn max_priority_fee_per_gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.max_priority_fee_per_gas = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_priority_fee_per_gas: {}",
                        e
                    )
                });
                self
            }
            pub fn nonce<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionNonce,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.nonce = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nonce: {}", e));
                self
            }
            pub fn to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionType,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionValue,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcInputParamsTransaction>
            for super::EthereumSendTransactionRpcInputParamsTransaction
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcInputParamsTransaction,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chain_id: value.chain_id?,
                    data: value.data?,
                    from: value.from?,
                    gas_limit: value.gas_limit?,
                    gas_price: value.gas_price?,
                    max_fee_per_gas: value.max_fee_per_gas?,
                    max_priority_fee_per_gas: value.max_priority_fee_per_gas?,
                    nonce: value.nonce?,
                    to: value.to?,
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcInputParamsTransaction>
            for EthereumSendTransactionRpcInputParamsTransaction
        {
            fn from(value: super::EthereumSendTransactionRpcInputParamsTransaction) -> Self {
                Self {
                    chain_id: Ok(value.chain_id),
                    data: Ok(value.data),
                    from: Ok(value.from),
                    gas_limit: Ok(value.gas_limit),
                    gas_price: Ok(value.gas_price),
                    max_fee_per_gas: Ok(value.max_fee_per_gas),
                    max_priority_fee_per_gas: Ok(value.max_priority_fee_per_gas),
                    nonce: Ok(value.nonce),
                    to: Ok(value.to),
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcInputParamsTransactionType {
            subtype_0: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0,
                >,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1,
                >,
                ::std::string::String,
            >,
            subtype_2: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcInputParamsTransactionType {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                    subtype_2: Ok(Default::default()),
                }
            }
        }
        impl EthereumSendTransactionRpcInputParamsTransactionType {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionTypeSubtype0,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionTypeSubtype1,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
            pub fn subtype_2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcInputParamsTransactionTypeSubtype2,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcInputParamsTransactionType>
            for super::EthereumSendTransactionRpcInputParamsTransactionType
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcInputParamsTransactionType,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                    subtype_2: value.subtype_2?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcInputParamsTransactionType>
            for EthereumSendTransactionRpcInputParamsTransactionType
        {
            fn from(value: super::EthereumSendTransactionRpcInputParamsTransactionType) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                    subtype_2: Ok(value.subtype_2),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcResponse {
            data: ::std::result::Result<
                ::std::option::Option<super::EthereumSendTransactionRpcResponseData>,
                ::std::string::String,
            >,
            error: ::std::result::Result<
                ::std::option::Option<super::EthereumSendTransactionRpcResponseError>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSendTransactionRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcResponse {
            fn default() -> Self {
                Self {
                    data: Ok(Default::default()),
                    error: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl EthereumSendTransactionRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSendTransactionRpcResponseData>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSendTransactionRpcResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSendTransactionRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcResponse>
            for super::EthereumSendTransactionRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    error: value.error?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcResponse>
            for EthereumSendTransactionRpcResponse
        {
            fn from(value: super::EthereumSendTransactionRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    error: Ok(value.error),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcResponseData {
            caip2: ::std::result::Result<
                super::EthereumSendTransactionRpcResponseDataCaip2,
                ::std::string::String,
            >,
            hash: ::std::result::Result<::std::string::String, ::std::string::String>,
            transaction_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            transaction_request: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcResponseDataTransactionRequest,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcResponseData {
            fn default() -> Self {
                Self {
                    caip2: Err("no value supplied for caip2".to_string()),
                    hash: Err("no value supplied for hash".to_string()),
                    transaction_id: Ok(Default::default()),
                    transaction_request: Ok(Default::default()),
                }
            }
        }
        impl EthereumSendTransactionRpcResponseData {
            pub fn caip2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSendTransactionRpcResponseDataCaip2>,
                T::Error: ::std::fmt::Display,
            {
                self.caip2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for caip2: {}", e));
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hash: {}", e));
                self
            }
            pub fn transaction_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for transaction_id: {}", e)
                });
                self
            }
            pub fn transaction_request<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequest,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_request = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_request: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcResponseData>
            for super::EthereumSendTransactionRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    caip2: value.caip2?,
                    hash: value.hash?,
                    transaction_id: value.transaction_id?,
                    transaction_request: value.transaction_request?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcResponseData>
            for EthereumSendTransactionRpcResponseData
        {
            fn from(value: super::EthereumSendTransactionRpcResponseData) -> Self {
                Self {
                    caip2: Ok(value.caip2),
                    hash: Ok(value.hash),
                    transaction_id: Ok(value.transaction_id),
                    transaction_request: Ok(value.transaction_request),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcResponseDataTransactionRequest { chain_id : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestChainId > , :: std :: string :: String > , data : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , from : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , gas_limit : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit > , :: std :: string :: String > , gas_price : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice > , :: std :: string :: String > , max_fee_per_gas : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas > , :: std :: string :: String > , max_priority_fee_per_gas : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas > , :: std :: string :: String > , nonce : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestNonce > , :: std :: string :: String > , to : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , type_ : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestType > , :: std :: string :: String > , value : :: std :: result :: Result < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestValue > , :: std :: string :: String > , }
        impl ::std::default::Default for EthereumSendTransactionRpcResponseDataTransactionRequest {
            fn default() -> Self {
                Self {
                    chain_id: Ok(Default::default()),
                    data: Ok(Default::default()),
                    from: Ok(Default::default()),
                    gas_limit: Ok(Default::default()),
                    gas_price: Ok(Default::default()),
                    max_fee_per_gas: Ok(Default::default()),
                    max_priority_fee_per_gas: Ok(Default::default()),
                    nonce: Ok(Default::default()),
                    to: Ok(Default::default()),
                    type_: Ok(Default::default()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl EthereumSendTransactionRpcResponseDataTransactionRequest {
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestChainId,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn from<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.from = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from: {}", e));
                self
            }
            pub fn gas_limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.gas_limit = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_limit: {}", e));
                self
            }
            pub fn gas_price<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.gas_price = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_price: {}", e));
                self
            }
            pub fn max_fee_per_gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.max_fee_per_gas = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_fee_per_gas: {}", e)
                });
                self
            }            pub fn max_priority_fee_per_gas < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < super :: EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas > > , T :: Error : :: std :: fmt :: Display ,{
                self.max_priority_fee_per_gas = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_priority_fee_per_gas: {}",
                        e
                    )
                });
                self
            }
            pub fn nonce<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestNonce,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.nonce = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nonce: {}", e));
                self
            }
            pub fn to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestType,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestValue,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcResponseDataTransactionRequest>
            for super::EthereumSendTransactionRpcResponseDataTransactionRequest
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcResponseDataTransactionRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chain_id: value.chain_id?,
                    data: value.data?,
                    from: value.from?,
                    gas_limit: value.gas_limit?,
                    gas_price: value.gas_price?,
                    max_fee_per_gas: value.max_fee_per_gas?,
                    max_priority_fee_per_gas: value.max_priority_fee_per_gas?,
                    nonce: value.nonce?,
                    to: value.to?,
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcResponseDataTransactionRequest>
            for EthereumSendTransactionRpcResponseDataTransactionRequest
        {
            fn from(
                value: super::EthereumSendTransactionRpcResponseDataTransactionRequest,
            ) -> Self {
                Self {
                    chain_id: Ok(value.chain_id),
                    data: Ok(value.data),
                    from: Ok(value.from),
                    gas_limit: Ok(value.gas_limit),
                    gas_price: Ok(value.gas_price),
                    max_fee_per_gas: Ok(value.max_fee_per_gas),
                    max_priority_fee_per_gas: Ok(value.max_priority_fee_per_gas),
                    nonce: Ok(value.nonce),
                    to: Ok(value.to),
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcResponseDataTransactionRequestType {
            subtype_0: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0,
                >,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1,
                >,
                ::std::string::String,
            >,
            subtype_2: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcResponseDataTransactionRequestType {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                    subtype_2: Ok(Default::default()),
                }
            }
        }
        impl EthereumSendTransactionRpcResponseDataTransactionRequestType {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype0,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype1,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
            pub fn subtype_2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSendTransactionRpcResponseDataTransactionRequestTypeSubtype2,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcResponseDataTransactionRequestType>
            for super::EthereumSendTransactionRpcResponseDataTransactionRequestType
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcResponseDataTransactionRequestType,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                    subtype_2: value.subtype_2?,
                })
            }
        }
        impl
            ::std::convert::From<
                super::EthereumSendTransactionRpcResponseDataTransactionRequestType,
            > for EthereumSendTransactionRpcResponseDataTransactionRequestType
        {
            fn from(
                value: super::EthereumSendTransactionRpcResponseDataTransactionRequestType,
            ) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                    subtype_2: Ok(value.subtype_2),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSendTransactionRpcResponseError {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSendTransactionRpcResponseError {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl EthereumSendTransactionRpcResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSendTransactionRpcResponseError>
            for super::EthereumSendTransactionRpcResponseError
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSendTransactionRpcResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSendTransactionRpcResponseError>
            for EthereumSendTransactionRpcResponseError
        {
            fn from(value: super::EthereumSendTransactionRpcResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSign7702AuthorizationRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::EthereumSign7702AuthorizationRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSign7702AuthorizationRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::EthereumSign7702AuthorizationRpcInputParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSign7702AuthorizationRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl EthereumSign7702AuthorizationRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSign7702AuthorizationRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSign7702AuthorizationRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSign7702AuthorizationRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSign7702AuthorizationRpcInput>
            for super::EthereumSign7702AuthorizationRpcInput
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSign7702AuthorizationRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSign7702AuthorizationRpcInput>
            for EthereumSign7702AuthorizationRpcInput
        {
            fn from(value: super::EthereumSign7702AuthorizationRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSign7702AuthorizationRpcInputParams {
            chain_id: ::std::result::Result<
                super::EthereumSign7702AuthorizationRpcInputParamsChainId,
                ::std::string::String,
            >,
            contract: ::std::result::Result<::std::string::String, ::std::string::String>,
            nonce: ::std::result::Result<
                ::std::option::Option<super::EthereumSign7702AuthorizationRpcInputParamsNonce>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSign7702AuthorizationRpcInputParams {
            fn default() -> Self {
                Self {
                    chain_id: Err("no value supplied for chain_id".to_string()),
                    contract: Err("no value supplied for contract".to_string()),
                    nonce: Ok(Default::default()),
                }
            }
        }
        impl EthereumSign7702AuthorizationRpcInputParams {
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::EthereumSign7702AuthorizationRpcInputParamsChainId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn contract<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.contract = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for contract: {}", e));
                self
            }
            pub fn nonce<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSign7702AuthorizationRpcInputParamsNonce>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.nonce = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nonce: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSign7702AuthorizationRpcInputParams>
            for super::EthereumSign7702AuthorizationRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSign7702AuthorizationRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chain_id: value.chain_id?,
                    contract: value.contract?,
                    nonce: value.nonce?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSign7702AuthorizationRpcInputParams>
            for EthereumSign7702AuthorizationRpcInputParams
        {
            fn from(value: super::EthereumSign7702AuthorizationRpcInputParams) -> Self {
                Self {
                    chain_id: Ok(value.chain_id),
                    contract: Ok(value.contract),
                    nonce: Ok(value.nonce),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSign7702AuthorizationRpcResponse {
            data: ::std::result::Result<
                ::std::option::Option<super::EthereumSign7702AuthorizationRpcResponseData>,
                ::std::string::String,
            >,
            error: ::std::result::Result<
                ::std::option::Option<super::EthereumSign7702AuthorizationRpcResponseError>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSign7702AuthorizationRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSign7702AuthorizationRpcResponse {
            fn default() -> Self {
                Self {
                    data: Ok(Default::default()),
                    error: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl EthereumSign7702AuthorizationRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSign7702AuthorizationRpcResponseData>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSign7702AuthorizationRpcResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSign7702AuthorizationRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSign7702AuthorizationRpcResponse>
            for super::EthereumSign7702AuthorizationRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSign7702AuthorizationRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    error: value.error?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSign7702AuthorizationRpcResponse>
            for EthereumSign7702AuthorizationRpcResponse
        {
            fn from(value: super::EthereumSign7702AuthorizationRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    error: Ok(value.error),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSign7702AuthorizationRpcResponseData {
            authorization: ::std::result::Result<
                super::EthereumSign7702AuthorizationRpcResponseDataAuthorization,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSign7702AuthorizationRpcResponseData {
            fn default() -> Self {
                Self {
                    authorization: Err("no value supplied for authorization".to_string()),
                }
            }
        }
        impl EthereumSign7702AuthorizationRpcResponseData {
            pub fn authorization<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::EthereumSign7702AuthorizationRpcResponseDataAuthorization,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.authorization = value.try_into().map_err(|e| {
                    format!("error converting supplied value for authorization: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSign7702AuthorizationRpcResponseData>
            for super::EthereumSign7702AuthorizationRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSign7702AuthorizationRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    authorization: value.authorization?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSign7702AuthorizationRpcResponseData>
            for EthereumSign7702AuthorizationRpcResponseData
        {
            fn from(value: super::EthereumSign7702AuthorizationRpcResponseData) -> Self {
                Self {
                    authorization: Ok(value.authorization),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSign7702AuthorizationRpcResponseDataAuthorization {
            chain_id: ::std::result::Result<
                super::EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId,
                ::std::string::String,
            >,
            contract: ::std::result::Result<::std::string::String, ::std::string::String>,
            nonce: ::std::result::Result<
                super::EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce,
                ::std::string::String,
            >,
            r: ::std::result::Result<::std::string::String, ::std::string::String>,
            s: ::std::result::Result<::std::string::String, ::std::string::String>,
            y_parity: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSign7702AuthorizationRpcResponseDataAuthorization {
            fn default() -> Self {
                Self {
                    chain_id: Err("no value supplied for chain_id".to_string()),
                    contract: Err("no value supplied for contract".to_string()),
                    nonce: Err("no value supplied for nonce".to_string()),
                    r: Err("no value supplied for r".to_string()),
                    s: Err("no value supplied for s".to_string()),
                    y_parity: Err("no value supplied for y_parity".to_string()),
                }
            }
        }
        impl EthereumSign7702AuthorizationRpcResponseDataAuthorization {
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn contract<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.contract = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for contract: {}", e));
                self
            }
            pub fn nonce<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.nonce = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nonce: {}", e));
                self
            }
            pub fn r<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.r = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for r: {}", e));
                self
            }
            pub fn s<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.s = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for s: {}", e));
                self
            }
            pub fn y_parity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.y_parity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for y_parity: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSign7702AuthorizationRpcResponseDataAuthorization>
            for super::EthereumSign7702AuthorizationRpcResponseDataAuthorization
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSign7702AuthorizationRpcResponseDataAuthorization,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chain_id: value.chain_id?,
                    contract: value.contract?,
                    nonce: value.nonce?,
                    r: value.r?,
                    s: value.s?,
                    y_parity: value.y_parity?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSign7702AuthorizationRpcResponseDataAuthorization>
            for EthereumSign7702AuthorizationRpcResponseDataAuthorization
        {
            fn from(
                value: super::EthereumSign7702AuthorizationRpcResponseDataAuthorization,
            ) -> Self {
                Self {
                    chain_id: Ok(value.chain_id),
                    contract: Ok(value.contract),
                    nonce: Ok(value.nonce),
                    r: Ok(value.r),
                    s: Ok(value.s),
                    y_parity: Ok(value.y_parity),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSign7702AuthorizationRpcResponseError {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSign7702AuthorizationRpcResponseError {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl EthereumSign7702AuthorizationRpcResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSign7702AuthorizationRpcResponseError>
            for super::EthereumSign7702AuthorizationRpcResponseError
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSign7702AuthorizationRpcResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSign7702AuthorizationRpcResponseError>
            for EthereumSign7702AuthorizationRpcResponseError
        {
            fn from(value: super::EthereumSign7702AuthorizationRpcResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTransactionRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::EthereumSignTransactionRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSignTransactionRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::EthereumSignTransactionRpcInputParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTransactionRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl EthereumSignTransactionRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSignTransactionRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTransactionRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTransactionRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTransactionRpcInput>
            for super::EthereumSignTransactionRpcInput
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTransactionRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTransactionRpcInput>
            for EthereumSignTransactionRpcInput
        {
            fn from(value: super::EthereumSignTransactionRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTransactionRpcInputParams {
            transaction: ::std::result::Result<
                super::EthereumSignTransactionRpcInputParamsTransaction,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTransactionRpcInputParams {
            fn default() -> Self {
                Self {
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl EthereumSignTransactionRpcInputParams {
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTransactionRpcInputParamsTransaction>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTransactionRpcInputParams>
            for super::EthereumSignTransactionRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTransactionRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTransactionRpcInputParams>
            for EthereumSignTransactionRpcInputParams
        {
            fn from(value: super::EthereumSignTransactionRpcInputParams) -> Self {
                Self {
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTransactionRpcInputParamsTransaction {
            chain_id: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionChainId,
                >,
                ::std::string::String,
            >,
            data: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            from: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            gas_limit: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionGasLimit,
                >,
                ::std::string::String,
            >,
            gas_price: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionGasPrice,
                >,
                ::std::string::String,
            >,
            max_fee_per_gas: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas,
                >,
                ::std::string::String,
            >,
            max_priority_fee_per_gas: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
                >,
                ::std::string::String,
            >,
            nonce: ::std::result::Result<
                ::std::option::Option<super::EthereumSignTransactionRpcInputParamsTransactionNonce>,
                ::std::string::String,
            >,
            to: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                ::std::option::Option<super::EthereumSignTransactionRpcInputParamsTransactionType>,
                ::std::string::String,
            >,
            value: ::std::result::Result<
                ::std::option::Option<super::EthereumSignTransactionRpcInputParamsTransactionValue>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTransactionRpcInputParamsTransaction {
            fn default() -> Self {
                Self {
                    chain_id: Ok(Default::default()),
                    data: Ok(Default::default()),
                    from: Ok(Default::default()),
                    gas_limit: Ok(Default::default()),
                    gas_price: Ok(Default::default()),
                    max_fee_per_gas: Ok(Default::default()),
                    max_priority_fee_per_gas: Ok(Default::default()),
                    nonce: Ok(Default::default()),
                    to: Ok(Default::default()),
                    type_: Ok(Default::default()),
                    value: Ok(Default::default()),
                }
            }
        }
        impl EthereumSignTransactionRpcInputParamsTransaction {
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionChainId,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn from<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.from = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for from: {}", e));
                self
            }
            pub fn gas_limit<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionGasLimit,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.gas_limit = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_limit: {}", e));
                self
            }
            pub fn gas_price<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionGasPrice,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.gas_price = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gas_price: {}", e));
                self
            }
            pub fn max_fee_per_gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.max_fee_per_gas = value.try_into().map_err(|e| {
                    format!("error converting supplied value for max_fee_per_gas: {}", e)
                });
                self
            }
            pub fn max_priority_fee_per_gas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.max_priority_fee_per_gas = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for max_priority_fee_per_gas: {}",
                        e
                    )
                });
                self
            }
            pub fn nonce<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionNonce,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.nonce = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nonce: {}", e));
                self
            }
            pub fn to<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.to = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionType,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionValue,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTransactionRpcInputParamsTransaction>
            for super::EthereumSignTransactionRpcInputParamsTransaction
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTransactionRpcInputParamsTransaction,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chain_id: value.chain_id?,
                    data: value.data?,
                    from: value.from?,
                    gas_limit: value.gas_limit?,
                    gas_price: value.gas_price?,
                    max_fee_per_gas: value.max_fee_per_gas?,
                    max_priority_fee_per_gas: value.max_priority_fee_per_gas?,
                    nonce: value.nonce?,
                    to: value.to?,
                    type_: value.type_?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTransactionRpcInputParamsTransaction>
            for EthereumSignTransactionRpcInputParamsTransaction
        {
            fn from(value: super::EthereumSignTransactionRpcInputParamsTransaction) -> Self {
                Self {
                    chain_id: Ok(value.chain_id),
                    data: Ok(value.data),
                    from: Ok(value.from),
                    gas_limit: Ok(value.gas_limit),
                    gas_price: Ok(value.gas_price),
                    max_fee_per_gas: Ok(value.max_fee_per_gas),
                    max_priority_fee_per_gas: Ok(value.max_priority_fee_per_gas),
                    nonce: Ok(value.nonce),
                    to: Ok(value.to),
                    type_: Ok(value.type_),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTransactionRpcInputParamsTransactionType {
            subtype_0: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0,
                >,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1,
                >,
                ::std::string::String,
            >,
            subtype_2: ::std::result::Result<
                ::std::option::Option<
                    super::EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTransactionRpcInputParamsTransactionType {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                    subtype_2: Ok(Default::default()),
                }
            }
        }
        impl EthereumSignTransactionRpcInputParamsTransactionType {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionTypeSubtype0,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionTypeSubtype1,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
            pub fn subtype_2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        super::EthereumSignTransactionRpcInputParamsTransactionTypeSubtype2,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTransactionRpcInputParamsTransactionType>
            for super::EthereumSignTransactionRpcInputParamsTransactionType
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTransactionRpcInputParamsTransactionType,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                    subtype_2: value.subtype_2?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTransactionRpcInputParamsTransactionType>
            for EthereumSignTransactionRpcInputParamsTransactionType
        {
            fn from(value: super::EthereumSignTransactionRpcInputParamsTransactionType) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                    subtype_2: Ok(value.subtype_2),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTransactionRpcResponse {
            data: ::std::result::Result<
                super::EthereumSignTransactionRpcResponseData,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSignTransactionRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTransactionRpcResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl EthereumSignTransactionRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTransactionRpcResponseData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTransactionRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTransactionRpcResponse>
            for super::EthereumSignTransactionRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTransactionRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTransactionRpcResponse>
            for EthereumSignTransactionRpcResponse
        {
            fn from(value: super::EthereumSignTransactionRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTransactionRpcResponseData {
            encoding: ::std::result::Result<
                super::EthereumSignTransactionRpcResponseDataEncoding,
                ::std::string::String,
            >,
            signed_transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSignTransactionRpcResponseData {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    signed_transaction: Err("no value supplied for signed_transaction".to_string()),
                }
            }
        }
        impl EthereumSignTransactionRpcResponseData {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTransactionRpcResponseDataEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn signed_transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signed_transaction = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for signed_transaction: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTransactionRpcResponseData>
            for super::EthereumSignTransactionRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTransactionRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    signed_transaction: value.signed_transaction?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTransactionRpcResponseData>
            for EthereumSignTransactionRpcResponseData
        {
            fn from(value: super::EthereumSignTransactionRpcResponseData) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    signed_transaction: Ok(value.signed_transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTypedDataRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::EthereumSignTypedDataRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSignTypedDataRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::EthereumSignTypedDataRpcInputParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTypedDataRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl EthereumSignTypedDataRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::EthereumSignTypedDataRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTypedDataRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTypedDataRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTypedDataRpcInput>
            for super::EthereumSignTypedDataRpcInput
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTypedDataRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTypedDataRpcInput> for EthereumSignTypedDataRpcInput {
            fn from(value: super::EthereumSignTypedDataRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTypedDataRpcInputParams {
            typed_data: ::std::result::Result<
                super::EthereumSignTypedDataRpcInputParamsTypedData,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTypedDataRpcInputParams {
            fn default() -> Self {
                Self {
                    typed_data: Err("no value supplied for typed_data".to_string()),
                }
            }
        }
        impl EthereumSignTypedDataRpcInputParams {
            pub fn typed_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTypedDataRpcInputParamsTypedData>,
                T::Error: ::std::fmt::Display,
            {
                self.typed_data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for typed_data: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTypedDataRpcInputParams>
            for super::EthereumSignTypedDataRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTypedDataRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    typed_data: value.typed_data?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTypedDataRpcInputParams>
            for EthereumSignTypedDataRpcInputParams
        {
            fn from(value: super::EthereumSignTypedDataRpcInputParams) -> Self {
                Self {
                    typed_data: Ok(value.typed_data),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTypedDataRpcInputParamsTypedData {
            domain: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            message: ::std::result::Result<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                ::std::string::String,
            >,
            primary_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            types: ::std::result::Result<
                ::std::collections::HashMap<
                    ::std::string::String,
                    ::std::vec::Vec<
                        super::EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem,
                    >,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTypedDataRpcInputParamsTypedData {
            fn default() -> Self {
                Self {
                    domain: Err("no value supplied for domain".to_string()),
                    message: Err("no value supplied for message".to_string()),
                    primary_type: Err("no value supplied for primary_type".to_string()),
                    types: Err("no value supplied for types".to_string()),
                }
            }
        }
        impl EthereumSignTypedDataRpcInputParamsTypedData {
            pub fn domain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.domain = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for domain: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::serde_json::Map<::std::string::String, ::serde_json::Value>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
            pub fn primary_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.primary_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for primary_type: {}", e)
                });
                self
            }
            pub fn types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::std::vec::Vec<
                            super::EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem,
                        >,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for types: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTypedDataRpcInputParamsTypedData>
            for super::EthereumSignTypedDataRpcInputParamsTypedData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTypedDataRpcInputParamsTypedData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    domain: value.domain?,
                    message: value.message?,
                    primary_type: value.primary_type?,
                    types: value.types?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTypedDataRpcInputParamsTypedData>
            for EthereumSignTypedDataRpcInputParamsTypedData
        {
            fn from(value: super::EthereumSignTypedDataRpcInputParamsTypedData) -> Self {
                Self {
                    domain: Ok(value.domain),
                    message: Ok(value.message),
                    primary_type: Ok(value.primary_type),
                    types: Ok(value.types),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem>
            for super::EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem>
            for EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem
        {
            fn from(
                value: super::EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem,
            ) -> Self {
                Self {
                    name: Ok(value.name),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTypedDataRpcResponse {
            data: ::std::result::Result<
                super::EthereumSignTypedDataRpcResponseData,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::EthereumSignTypedDataRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumSignTypedDataRpcResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl EthereumSignTypedDataRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTypedDataRpcResponseData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTypedDataRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTypedDataRpcResponse>
            for super::EthereumSignTypedDataRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTypedDataRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTypedDataRpcResponse>
            for EthereumSignTypedDataRpcResponse
        {
            fn from(value: super::EthereumSignTypedDataRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumSignTypedDataRpcResponseData {
            encoding: ::std::result::Result<
                super::EthereumSignTypedDataRpcResponseDataEncoding,
                ::std::string::String,
            >,
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumSignTypedDataRpcResponseData {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl EthereumSignTypedDataRpcResponseData {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumSignTypedDataRpcResponseDataEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumSignTypedDataRpcResponseData>
            for super::EthereumSignTypedDataRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumSignTypedDataRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumSignTypedDataRpcResponseData>
            for EthereumSignTypedDataRpcResponseData
        {
            fn from(value: super::EthereumSignTypedDataRpcResponseData) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumTransactionCondition {
            field: ::std::result::Result<
                super::EthereumTransactionConditionField,
                ::std::string::String,
            >,
            field_source: ::std::result::Result<
                super::EthereumTransactionConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumTransactionCondition {
            fn default() -> Self {
                Self {
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EthereumTransactionCondition {
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumTransactionConditionField>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumTransactionConditionFieldSource>,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumTransactionCondition> for super::EthereumTransactionCondition {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumTransactionCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumTransactionCondition> for EthereumTransactionCondition {
            fn from(value: super::EthereumTransactionCondition) -> Self {
                Self {
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumTypedDataDomainCondition {
            field: ::std::result::Result<
                super::EthereumTypedDataDomainConditionField,
                ::std::string::String,
            >,
            field_source: ::std::result::Result<
                super::EthereumTypedDataDomainConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumTypedDataDomainCondition {
            fn default() -> Self {
                Self {
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EthereumTypedDataDomainCondition {
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumTypedDataDomainConditionField>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumTypedDataDomainConditionFieldSource>,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumTypedDataDomainCondition>
            for super::EthereumTypedDataDomainCondition
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumTypedDataDomainCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumTypedDataDomainCondition>
            for EthereumTypedDataDomainCondition
        {
            fn from(value: super::EthereumTypedDataDomainCondition) -> Self {
                Self {
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumTypedDataMessageCondition {
            field: ::std::result::Result<::std::string::String, ::std::string::String>,
            field_source: ::std::result::Result<
                super::EthereumTypedDataMessageConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            typed_data: ::std::result::Result<
                super::EthereumTypedDataMessageConditionTypedData,
                ::std::string::String,
            >,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumTypedDataMessageCondition {
            fn default() -> Self {
                Self {
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    typed_data: Err("no value supplied for typed_data".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl EthereumTypedDataMessageCondition {
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumTypedDataMessageConditionFieldSource>,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn typed_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::EthereumTypedDataMessageConditionTypedData>,
                T::Error: ::std::fmt::Display,
            {
                self.typed_data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for typed_data: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumTypedDataMessageCondition>
            for super::EthereumTypedDataMessageCondition
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumTypedDataMessageCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    typed_data: value.typed_data?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumTypedDataMessageCondition>
            for EthereumTypedDataMessageCondition
        {
            fn from(value: super::EthereumTypedDataMessageCondition) -> Self {
                Self {
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    typed_data: Ok(value.typed_data),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumTypedDataMessageConditionTypedData {
            primary_type: ::std::result::Result<::std::string::String, ::std::string::String>,
            types: ::std::result::Result<
                ::std::collections::HashMap<
                    ::std::string::String,
                    ::std::vec::Vec<
                        super::EthereumTypedDataMessageConditionTypedDataTypesValueItem,
                    >,
                >,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for EthereumTypedDataMessageConditionTypedData {
            fn default() -> Self {
                Self {
                    primary_type: Err("no value supplied for primary_type".to_string()),
                    types: Err("no value supplied for types".to_string()),
                }
            }
        }
        impl EthereumTypedDataMessageConditionTypedData {
            pub fn primary_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.primary_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for primary_type: {}", e)
                });
                self
            }
            pub fn types<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::std::vec::Vec<
                            super::EthereumTypedDataMessageConditionTypedDataTypesValueItem,
                        >,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.types = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for types: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumTypedDataMessageConditionTypedData>
            for super::EthereumTypedDataMessageConditionTypedData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumTypedDataMessageConditionTypedData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    primary_type: value.primary_type?,
                    types: value.types?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumTypedDataMessageConditionTypedData>
            for EthereumTypedDataMessageConditionTypedData
        {
            fn from(value: super::EthereumTypedDataMessageConditionTypedData) -> Self {
                Self {
                    primary_type: Ok(value.primary_type),
                    types: Ok(value.types),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct EthereumTypedDataMessageConditionTypedDataTypesValueItem {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for EthereumTypedDataMessageConditionTypedDataTypesValueItem {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl EthereumTypedDataMessageConditionTypedDataTypesValueItem {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<EthereumTypedDataMessageConditionTypedDataTypesValueItem>
            for super::EthereumTypedDataMessageConditionTypedDataTypesValueItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EthereumTypedDataMessageConditionTypedDataTypesValueItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::EthereumTypedDataMessageConditionTypedDataTypesValueItem>
            for EthereumTypedDataMessageConditionTypedDataTypesValueItem
        {
            fn from(
                value: super::EthereumTypedDataMessageConditionTypedDataTypesValueItem,
            ) -> Self {
                Self {
                    name: Ok(value.name),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetUsersResponse {
            data: ::std::result::Result<::std::vec::Vec<super::User>, ::std::string::String>,
            next_cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetUsersResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    next_cursor: Ok(Default::default()),
                }
            }
        }
        impl GetUsersResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::User>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetUsersResponse> for super::GetUsersResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetUsersResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    next_cursor: value.next_cursor?,
                })
            }
        }
        impl ::std::convert::From<super::GetUsersResponse> for GetUsersResponse {
            fn from(value: super::GetUsersResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    next_cursor: Ok(value.next_cursor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetWalletBalanceResponse {
            balances: ::std::result::Result<
                ::std::vec::Vec<super::GetWalletBalanceResponseBalancesItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetWalletBalanceResponse {
            fn default() -> Self {
                Self {
                    balances: Err("no value supplied for balances".to_string()),
                }
            }
        }
        impl GetWalletBalanceResponse {
            pub fn balances<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::GetWalletBalanceResponseBalancesItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.balances = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for balances: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetWalletBalanceResponse> for super::GetWalletBalanceResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetWalletBalanceResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    balances: value.balances?,
                })
            }
        }
        impl ::std::convert::From<super::GetWalletBalanceResponse> for GetWalletBalanceResponse {
            fn from(value: super::GetWalletBalanceResponse) -> Self {
                Self {
                    balances: Ok(value.balances),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetWalletBalanceResponseBalancesItem {
            asset: ::std::result::Result<
                super::GetWalletBalanceResponseBalancesItemAsset,
                ::std::string::String,
            >,
            chain: ::std::result::Result<
                super::GetWalletBalanceResponseBalancesItemChain,
                ::std::string::String,
            >,
            display_values: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                ::std::string::String,
            >,
            raw_value: ::std::result::Result<::std::string::String, ::std::string::String>,
            raw_value_decimals: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for GetWalletBalanceResponseBalancesItem {
            fn default() -> Self {
                Self {
                    asset: Err("no value supplied for asset".to_string()),
                    chain: Err("no value supplied for chain".to_string()),
                    display_values: Err("no value supplied for display_values".to_string()),
                    raw_value: Err("no value supplied for raw_value".to_string()),
                    raw_value_decimals: Err("no value supplied for raw_value_decimals".to_string()),
                }
            }
        }
        impl GetWalletBalanceResponseBalancesItem {
            pub fn asset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetWalletBalanceResponseBalancesItemAsset>,
                T::Error: ::std::fmt::Display,
            {
                self.asset = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for asset: {}", e));
                self
            }
            pub fn chain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::GetWalletBalanceResponseBalancesItemChain>,
                T::Error: ::std::fmt::Display,
            {
                self.chain = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain: {}", e));
                self
            }
            pub fn display_values<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.display_values = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_values: {}", e)
                });
                self
            }
            pub fn raw_value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.raw_value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for raw_value: {}", e));
                self
            }
            pub fn raw_value_decimals<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.raw_value_decimals = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for raw_value_decimals: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<GetWalletBalanceResponseBalancesItem>
            for super::GetWalletBalanceResponseBalancesItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetWalletBalanceResponseBalancesItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    asset: value.asset?,
                    chain: value.chain?,
                    display_values: value.display_values?,
                    raw_value: value.raw_value?,
                    raw_value_decimals: value.raw_value_decimals?,
                })
            }
        }
        impl ::std::convert::From<super::GetWalletBalanceResponseBalancesItem>
            for GetWalletBalanceResponseBalancesItem
        {
            fn from(value: super::GetWalletBalanceResponseBalancesItem) -> Self {
                Self {
                    asset: Ok(value.asset),
                    chain: Ok(value.chain),
                    display_values: Ok(value.display_values),
                    raw_value: Ok(value.raw_value),
                    raw_value_decimals: Ok(value.raw_value_decimals),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetWalletsChainType {
            subtype_0: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype0>,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype1>,
                ::std::string::String,
            >,
            subtype_2: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype2>,
                ::std::string::String,
            >,
            subtype_3: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype3>,
                ::std::string::String,
            >,
            subtype_4: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype4>,
                ::std::string::String,
            >,
            subtype_5: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype5>,
                ::std::string::String,
            >,
            subtype_6: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype6>,
                ::std::string::String,
            >,
            subtype_7: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype7>,
                ::std::string::String,
            >,
            subtype_8: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype8>,
                ::std::string::String,
            >,
            subtype_9: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype9>,
                ::std::string::String,
            >,
            subtype_10: ::std::result::Result<
                ::std::option::Option<super::GetWalletsChainTypeSubtype10>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetWalletsChainType {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                    subtype_2: Ok(Default::default()),
                    subtype_3: Ok(Default::default()),
                    subtype_4: Ok(Default::default()),
                    subtype_5: Ok(Default::default()),
                    subtype_6: Ok(Default::default()),
                    subtype_7: Ok(Default::default()),
                    subtype_8: Ok(Default::default()),
                    subtype_9: Ok(Default::default()),
                    subtype_10: Ok(Default::default()),
                }
            }
        }
        impl GetWalletsChainType {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype0>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype1>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
            pub fn subtype_2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype2>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
                self
            }
            pub fn subtype_3<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype3>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_3 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_3: {}", e));
                self
            }
            pub fn subtype_4<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype4>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_4 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_4: {}", e));
                self
            }
            pub fn subtype_5<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype5>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_5 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_5: {}", e));
                self
            }
            pub fn subtype_6<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype6>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_6 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_6: {}", e));
                self
            }
            pub fn subtype_7<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype7>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_7 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_7: {}", e));
                self
            }
            pub fn subtype_8<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype8>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_8 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_8: {}", e));
                self
            }
            pub fn subtype_9<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype9>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_9 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_9: {}", e));
                self
            }
            pub fn subtype_10<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::GetWalletsChainTypeSubtype10>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_10 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_10: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetWalletsChainType> for super::GetWalletsChainType {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetWalletsChainType,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                    subtype_2: value.subtype_2?,
                    subtype_3: value.subtype_3?,
                    subtype_4: value.subtype_4?,
                    subtype_5: value.subtype_5?,
                    subtype_6: value.subtype_6?,
                    subtype_7: value.subtype_7?,
                    subtype_8: value.subtype_8?,
                    subtype_9: value.subtype_9?,
                    subtype_10: value.subtype_10?,
                })
            }
        }
        impl ::std::convert::From<super::GetWalletsChainType> for GetWalletsChainType {
            fn from(value: super::GetWalletsChainType) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                    subtype_2: Ok(value.subtype_2),
                    subtype_3: Ok(value.subtype_3),
                    subtype_4: Ok(value.subtype_4),
                    subtype_5: Ok(value.subtype_5),
                    subtype_6: Ok(value.subtype_6),
                    subtype_7: Ok(value.subtype_7),
                    subtype_8: Ok(value.subtype_8),
                    subtype_9: Ok(value.subtype_9),
                    subtype_10: Ok(value.subtype_10),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct GetWalletsResponse {
            data: ::std::result::Result<::std::vec::Vec<super::Wallet>, ::std::string::String>,
            next_cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for GetWalletsResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    next_cursor: Ok(Default::default()),
                }
            }
        }
        impl GetWalletsResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Wallet>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<GetWalletsResponse> for super::GetWalletsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GetWalletsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    next_cursor: value.next_cursor?,
                })
            }
        }
        impl ::std::convert::From<super::GetWalletsResponse> for GetWalletsResponse {
            fn from(value: super::GetWalletsResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    next_cursor: Ok(value.next_cursor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct HdInitInput {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type:
                ::std::result::Result<super::WalletImportSupportedChains, ::std::string::String>,
            encryption_type: ::std::result::Result<super::HpkeEncryption, ::std::string::String>,
            entropy_type:
                ::std::result::Result<super::HdInitInputEntropyType, ::std::string::String>,
            index: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for HdInitInput {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                    entropy_type: Err("no value supplied for entropy_type".to_string()),
                    index: Err("no value supplied for index".to_string()),
                }
            }
        }
        impl HdInitInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletImportSupportedChains>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HpkeEncryption>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
            pub fn entropy_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HdInitInputEntropyType>,
                T::Error: ::std::fmt::Display,
            {
                self.entropy_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for entropy_type: {}", e)
                });
                self
            }
            pub fn index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.index = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for index: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<HdInitInput> for super::HdInitInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: HdInitInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    encryption_type: value.encryption_type?,
                    entropy_type: value.entropy_type?,
                    index: value.index?,
                })
            }
        }
        impl ::std::convert::From<super::HdInitInput> for HdInitInput {
            fn from(value: super::HdInitInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    encryption_type: Ok(value.encryption_type),
                    entropy_type: Ok(value.entropy_type),
                    index: Ok(value.index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct HdSubmitInput {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type:
                ::std::result::Result<super::WalletImportSupportedChains, ::std::string::String>,
            ciphertext: ::std::result::Result<::std::string::String, ::std::string::String>,
            encapsulated_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            encryption_type: ::std::result::Result<super::HpkeEncryption, ::std::string::String>,
            entropy_type:
                ::std::result::Result<super::HdSubmitInputEntropyType, ::std::string::String>,
            index: ::std::result::Result<u64, ::std::string::String>,
        }
        impl ::std::default::Default for HdSubmitInput {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    ciphertext: Err("no value supplied for ciphertext".to_string()),
                    encapsulated_key: Err("no value supplied for encapsulated_key".to_string()),
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                    entropy_type: Err("no value supplied for entropy_type".to_string()),
                    index: Err("no value supplied for index".to_string()),
                }
            }
        }
        impl HdSubmitInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletImportSupportedChains>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn ciphertext<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.ciphertext = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ciphertext: {}", e));
                self
            }
            pub fn encapsulated_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encapsulated_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encapsulated_key: {}",
                        e
                    )
                });
                self
            }
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HpkeEncryption>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
            pub fn entropy_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HdSubmitInputEntropyType>,
                T::Error: ::std::fmt::Display,
            {
                self.entropy_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for entropy_type: {}", e)
                });
                self
            }
            pub fn index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.index = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for index: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<HdSubmitInput> for super::HdSubmitInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: HdSubmitInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    ciphertext: value.ciphertext?,
                    encapsulated_key: value.encapsulated_key?,
                    encryption_type: value.encryption_type?,
                    entropy_type: value.entropy_type?,
                    index: value.index?,
                })
            }
        }
        impl ::std::convert::From<super::HdSubmitInput> for HdSubmitInput {
            fn from(value: super::HdSubmitInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    ciphertext: Ok(value.ciphertext),
                    encapsulated_key: Ok(value.encapsulated_key),
                    encryption_type: Ok(value.encryption_type),
                    entropy_type: Ok(value.entropy_type),
                    index: Ok(value.index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct KeyQuorum {
            authorization_keys: ::std::result::Result<
                ::std::vec::Vec<super::KeyQuorumAuthorizationKeysItem>,
                ::std::string::String,
            >,
            authorization_threshold:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            display_name: ::std::result::Result<
                ::std::option::Option<super::KeyQuorumDisplayName>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            user_ids: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for KeyQuorum {
            fn default() -> Self {
                Self {
                    authorization_keys: Err("no value supplied for authorization_keys".to_string()),
                    authorization_threshold: Ok(Default::default()),
                    display_name: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    user_ids: Ok(Default::default()),
                }
            }
        }
        impl KeyQuorum {
            pub fn authorization_keys<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::KeyQuorumAuthorizationKeysItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.authorization_keys = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for authorization_keys: {}",
                        e
                    )
                });
                self
            }
            pub fn authorization_threshold<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.authorization_threshold = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for authorization_threshold: {}",
                        e
                    )
                });
                self
            }
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::KeyQuorumDisplayName>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn user_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.user_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_ids: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<KeyQuorum> for super::KeyQuorum {
            type Error = super::error::ConversionError;
            fn try_from(
                value: KeyQuorum,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    authorization_keys: value.authorization_keys?,
                    authorization_threshold: value.authorization_threshold?,
                    display_name: value.display_name?,
                    id: value.id?,
                    user_ids: value.user_ids?,
                })
            }
        }
        impl ::std::convert::From<super::KeyQuorum> for KeyQuorum {
            fn from(value: super::KeyQuorum) -> Self {
                Self {
                    authorization_keys: Ok(value.authorization_keys),
                    authorization_threshold: Ok(value.authorization_threshold),
                    display_name: Ok(value.display_name),
                    id: Ok(value.id),
                    user_ids: Ok(value.user_ids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct KeyQuorumAuthorizationKeysItem {
            display_name: ::std::result::Result<
                ::std::option::Option<super::KeyQuorumAuthorizationKeysItemDisplayName>,
                ::std::string::String,
            >,
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for KeyQuorumAuthorizationKeysItem {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                }
            }
        }
        impl KeyQuorumAuthorizationKeysItem {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::KeyQuorumAuthorizationKeysItemDisplayName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<KeyQuorumAuthorizationKeysItem>
            for super::KeyQuorumAuthorizationKeysItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: KeyQuorumAuthorizationKeysItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    public_key: value.public_key?,
                })
            }
        }
        impl ::std::convert::From<super::KeyQuorumAuthorizationKeysItem>
            for KeyQuorumAuthorizationKeysItem
        {
            fn from(value: super::KeyQuorumAuthorizationKeysItem) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    public_key: Ok(value.public_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct KycStatus {
            provider_user_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            status: ::std::result::Result<super::KycStatusStatus, ::std::string::String>,
            user_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for KycStatus {
            fn default() -> Self {
                Self {
                    provider_user_id: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    user_id: Err("no value supplied for user_id".to_string()),
                }
            }
        }
        impl KycStatus {
            pub fn provider_user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.provider_user_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for provider_user_id: {}",
                        e
                    )
                });
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::KycStatusStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<KycStatus> for super::KycStatus {
            type Error = super::error::ConversionError;
            fn try_from(
                value: KycStatus,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    provider_user_id: value.provider_user_id?,
                    status: value.status?,
                    user_id: value.user_id?,
                })
            }
        }
        impl ::std::convert::From<super::KycStatus> for KycStatus {
            fn from(value: super::KycStatus) -> Self {
                Self {
                    provider_user_id: Ok(value.provider_user_id),
                    status: Ok(value.status),
                    user_id: Ok(value.user_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountAppleInput {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject:
                ::std::result::Result<super::LinkedAccountAppleInputSubject, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountAppleInputType, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountAppleInput {
            fn default() -> Self {
                Self {
                    email: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountAppleInput {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountAppleInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountAppleInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountAppleInput> for super::LinkedAccountAppleInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountAppleInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    subject: value.subject?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountAppleInput> for LinkedAccountAppleInput {
            fn from(value: super::LinkedAccountAppleInput) -> Self {
                Self {
                    email: Ok(value.email),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountAppleOauth {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountAppleOauthType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountAppleOauth {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountAppleOauth {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountAppleOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountAppleOauth> for super::LinkedAccountAppleOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountAppleOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    subject: value.subject?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountAppleOauth> for LinkedAccountAppleOauth {
            fn from(value: super::LinkedAccountAppleOauth) -> Self {
                Self {
                    email: Ok(value.email),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountAuthorizationKey {
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<
                super::LinkedAccountAuthorizationKeyType,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountAuthorizationKey {
            fn default() -> Self {
                Self {
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountAuthorizationKey {
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountAuthorizationKeyType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountAuthorizationKey>
            for super::LinkedAccountAuthorizationKey
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountAuthorizationKey,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    public_key: value.public_key?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountAuthorizationKey> for LinkedAccountAuthorizationKey {
            fn from(value: super::LinkedAccountAuthorizationKey) -> Self {
                Self {
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    public_key: Ok(value.public_key),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountBitcoinSegwitEmbeddedWallet {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type: ::std::result::Result<
                super::LinkedAccountBitcoinSegwitEmbeddedWalletChainType,
                ::std::string::String,
            >,
            connector_type: ::std::result::Result<
                super::LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType,
                ::std::string::String,
            >,
            delegated: ::std::result::Result<bool, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            imported: ::std::result::Result<bool, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            recovery_method: ::std::result::Result<
                super::LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::LinkedAccountBitcoinSegwitEmbeddedWalletType,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
            wallet_client: ::std::result::Result<
                super::LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient,
                ::std::string::String,
            >,
            wallet_client_type: ::std::result::Result<
                super::LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType,
                ::std::string::String,
            >,
            wallet_index: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountBitcoinSegwitEmbeddedWallet {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_id: Err("no value supplied for chain_id".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    connector_type: Err("no value supplied for connector_type".to_string()),
                    delegated: Err("no value supplied for delegated".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    imported: Err("no value supplied for imported".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                    recovery_method: Err("no value supplied for recovery_method".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                    wallet_client: Err("no value supplied for wallet_client".to_string()),
                    wallet_client_type: Err("no value supplied for wallet_client_type".to_string()),
                    wallet_index: Err("no value supplied for wallet_index".to_string()),
                }
            }
        }
        impl LinkedAccountBitcoinSegwitEmbeddedWallet {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinSegwitEmbeddedWalletChainType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn connector_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.connector_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for connector_type: {}", e)
                });
                self
            }
            pub fn delegated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.delegated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for delegated: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn imported<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.imported = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for imported: {}", e));
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn recovery_method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.recovery_method = value.try_into().map_err(|e| {
                    format!("error converting supplied value for recovery_method: {}", e)
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountBitcoinSegwitEmbeddedWalletType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
            pub fn wallet_client<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_client: {}", e)
                });
                self
            }
            pub fn wallet_client_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for wallet_client_type: {}",
                        e
                    )
                });
                self
            }
            pub fn wallet_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_index = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_index: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountBitcoinSegwitEmbeddedWallet>
            for super::LinkedAccountBitcoinSegwitEmbeddedWallet
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountBitcoinSegwitEmbeddedWallet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_id: value.chain_id?,
                    chain_type: value.chain_type?,
                    connector_type: value.connector_type?,
                    delegated: value.delegated?,
                    first_verified_at: value.first_verified_at?,
                    id: value.id?,
                    imported: value.imported?,
                    latest_verified_at: value.latest_verified_at?,
                    public_key: value.public_key?,
                    recovery_method: value.recovery_method?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                    wallet_client: value.wallet_client?,
                    wallet_client_type: value.wallet_client_type?,
                    wallet_index: value.wallet_index?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountBitcoinSegwitEmbeddedWallet>
            for LinkedAccountBitcoinSegwitEmbeddedWallet
        {
            fn from(value: super::LinkedAccountBitcoinSegwitEmbeddedWallet) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_id: Ok(value.chain_id),
                    chain_type: Ok(value.chain_type),
                    connector_type: Ok(value.connector_type),
                    delegated: Ok(value.delegated),
                    first_verified_at: Ok(value.first_verified_at),
                    id: Ok(value.id),
                    imported: Ok(value.imported),
                    latest_verified_at: Ok(value.latest_verified_at),
                    public_key: Ok(value.public_key),
                    recovery_method: Ok(value.recovery_method),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                    wallet_client: Ok(value.wallet_client),
                    wallet_client_type: Ok(value.wallet_client_type),
                    wallet_index: Ok(value.wallet_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountBitcoinTaprootEmbeddedWallet {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type: ::std::result::Result<
                super::LinkedAccountBitcoinTaprootEmbeddedWalletChainType,
                ::std::string::String,
            >,
            connector_type: ::std::result::Result<
                super::LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType,
                ::std::string::String,
            >,
            delegated: ::std::result::Result<bool, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            imported: ::std::result::Result<bool, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            recovery_method: ::std::result::Result<
                super::LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::LinkedAccountBitcoinTaprootEmbeddedWalletType,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
            wallet_client: ::std::result::Result<
                super::LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient,
                ::std::string::String,
            >,
            wallet_client_type: ::std::result::Result<
                super::LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType,
                ::std::string::String,
            >,
            wallet_index: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountBitcoinTaprootEmbeddedWallet {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_id: Err("no value supplied for chain_id".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    connector_type: Err("no value supplied for connector_type".to_string()),
                    delegated: Err("no value supplied for delegated".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    imported: Err("no value supplied for imported".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                    recovery_method: Err("no value supplied for recovery_method".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                    wallet_client: Err("no value supplied for wallet_client".to_string()),
                    wallet_client_type: Err("no value supplied for wallet_client_type".to_string()),
                    wallet_index: Err("no value supplied for wallet_index".to_string()),
                }
            }
        }
        impl LinkedAccountBitcoinTaprootEmbeddedWallet {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinTaprootEmbeddedWalletChainType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn connector_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.connector_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for connector_type: {}", e)
                });
                self
            }
            pub fn delegated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.delegated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for delegated: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn imported<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.imported = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for imported: {}", e));
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn recovery_method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.recovery_method = value.try_into().map_err(|e| {
                    format!("error converting supplied value for recovery_method: {}", e)
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountBitcoinTaprootEmbeddedWalletType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
            pub fn wallet_client<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_client: {}", e)
                });
                self
            }
            pub fn wallet_client_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for wallet_client_type: {}",
                        e
                    )
                });
                self
            }
            pub fn wallet_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_index = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_index: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountBitcoinTaprootEmbeddedWallet>
            for super::LinkedAccountBitcoinTaprootEmbeddedWallet
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountBitcoinTaprootEmbeddedWallet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_id: value.chain_id?,
                    chain_type: value.chain_type?,
                    connector_type: value.connector_type?,
                    delegated: value.delegated?,
                    first_verified_at: value.first_verified_at?,
                    id: value.id?,
                    imported: value.imported?,
                    latest_verified_at: value.latest_verified_at?,
                    public_key: value.public_key?,
                    recovery_method: value.recovery_method?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                    wallet_client: value.wallet_client?,
                    wallet_client_type: value.wallet_client_type?,
                    wallet_index: value.wallet_index?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountBitcoinTaprootEmbeddedWallet>
            for LinkedAccountBitcoinTaprootEmbeddedWallet
        {
            fn from(value: super::LinkedAccountBitcoinTaprootEmbeddedWallet) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_id: Ok(value.chain_id),
                    chain_type: Ok(value.chain_type),
                    connector_type: Ok(value.connector_type),
                    delegated: Ok(value.delegated),
                    first_verified_at: Ok(value.first_verified_at),
                    id: Ok(value.id),
                    imported: Ok(value.imported),
                    latest_verified_at: Ok(value.latest_verified_at),
                    public_key: Ok(value.public_key),
                    recovery_method: Ok(value.recovery_method),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                    wallet_client: Ok(value.wallet_client),
                    wallet_client_type: Ok(value.wallet_client_type),
                    wallet_index: Ok(value.wallet_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountCrossApp {
            embedded_wallets: ::std::result::Result<
                ::std::vec::Vec<super::LinkedAccountCrossAppEmbeddedWalletsItem>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            provider_app_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            smart_wallets: ::std::result::Result<
                ::std::vec::Vec<super::LinkedAccountCrossAppSmartWalletsItem>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountCrossAppType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountCrossApp {
            fn default() -> Self {
                Self {
                    embedded_wallets: Err("no value supplied for embedded_wallets".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    provider_app_id: Err("no value supplied for provider_app_id".to_string()),
                    smart_wallets: Err("no value supplied for smart_wallets".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountCrossApp {
            pub fn embedded_wallets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::LinkedAccountCrossAppEmbeddedWalletsItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.embedded_wallets = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for embedded_wallets: {}",
                        e
                    )
                });
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn provider_app_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.provider_app_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for provider_app_id: {}", e)
                });
                self
            }
            pub fn smart_wallets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::LinkedAccountCrossAppSmartWalletsItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.smart_wallets = value.try_into().map_err(|e| {
                    format!("error converting supplied value for smart_wallets: {}", e)
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountCrossAppType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountCrossApp> for super::LinkedAccountCrossApp {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountCrossApp,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    embedded_wallets: value.embedded_wallets?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    provider_app_id: value.provider_app_id?,
                    smart_wallets: value.smart_wallets?,
                    subject: value.subject?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountCrossApp> for LinkedAccountCrossApp {
            fn from(value: super::LinkedAccountCrossApp) -> Self {
                Self {
                    embedded_wallets: Ok(value.embedded_wallets),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    provider_app_id: Ok(value.provider_app_id),
                    smart_wallets: Ok(value.smart_wallets),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountCrossAppEmbeddedWalletsItem {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountCrossAppEmbeddedWalletsItem {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                }
            }
        }
        impl LinkedAccountCrossAppEmbeddedWalletsItem {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountCrossAppEmbeddedWalletsItem>
            for super::LinkedAccountCrossAppEmbeddedWalletsItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountCrossAppEmbeddedWalletsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountCrossAppEmbeddedWalletsItem>
            for LinkedAccountCrossAppEmbeddedWalletsItem
        {
            fn from(value: super::LinkedAccountCrossAppEmbeddedWalletsItem) -> Self {
                Self {
                    address: Ok(value.address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountCrossAppSmartWalletsItem {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountCrossAppSmartWalletsItem {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                }
            }
        }
        impl LinkedAccountCrossAppSmartWalletsItem {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountCrossAppSmartWalletsItem>
            for super::LinkedAccountCrossAppSmartWalletsItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountCrossAppSmartWalletsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountCrossAppSmartWalletsItem>
            for LinkedAccountCrossAppSmartWalletsItem
        {
            fn from(value: super::LinkedAccountCrossAppSmartWalletsItem) -> Self {
                Self {
                    address: Ok(value.address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountCustomJwt {
            custom_user_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountCustomJwtType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountCustomJwt {
            fn default() -> Self {
                Self {
                    custom_user_id: Err("no value supplied for custom_user_id".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountCustomJwt {
            pub fn custom_user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.custom_user_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for custom_user_id: {}", e)
                });
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountCustomJwtType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountCustomJwt> for super::LinkedAccountCustomJwt {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountCustomJwt,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    custom_user_id: value.custom_user_id?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountCustomJwt> for LinkedAccountCustomJwt {
            fn from(value: super::LinkedAccountCustomJwt) -> Self {
                Self {
                    custom_user_id: Ok(value.custom_user_id),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountCustomJwtInput {
            custom_user_id: ::std::result::Result<
                super::LinkedAccountCustomJwtInputCustomUserId,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::LinkedAccountCustomJwtInputType,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountCustomJwtInput {
            fn default() -> Self {
                Self {
                    custom_user_id: Err("no value supplied for custom_user_id".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountCustomJwtInput {
            pub fn custom_user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountCustomJwtInputCustomUserId>,
                T::Error: ::std::fmt::Display,
            {
                self.custom_user_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for custom_user_id: {}", e)
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountCustomJwtInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountCustomJwtInput> for super::LinkedAccountCustomJwtInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountCustomJwtInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    custom_user_id: value.custom_user_id?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountCustomJwtInput> for LinkedAccountCustomJwtInput {
            fn from(value: super::LinkedAccountCustomJwtInput) -> Self {
                Self {
                    custom_user_id: Ok(value.custom_user_id),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountDiscordInput {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<
                super::LinkedAccountDiscordInputSubject,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountDiscordInputType, ::std::string::String>,
            username: ::std::result::Result<
                super::LinkedAccountDiscordInputUsername,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountDiscordInput {
            fn default() -> Self {
                Self {
                    email: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl LinkedAccountDiscordInput {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountDiscordInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountDiscordInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountDiscordInputUsername>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountDiscordInput> for super::LinkedAccountDiscordInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountDiscordInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountDiscordInput> for LinkedAccountDiscordInput {
            fn from(value: super::LinkedAccountDiscordInput) -> Self {
                Self {
                    email: Ok(value.email),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountDiscordOauth {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountDiscordOauthType, ::std::string::String>,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountDiscordOauth {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountDiscordOauth {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountDiscordOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountDiscordOauth> for super::LinkedAccountDiscordOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountDiscordOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountDiscordOauth> for LinkedAccountDiscordOauth {
            fn from(value: super::LinkedAccountDiscordOauth) -> Self {
                Self {
                    email: Ok(value.email),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountEmail {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountEmailType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountEmail {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountEmail {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEmailType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountEmail> for super::LinkedAccountEmail {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountEmail,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountEmail> for LinkedAccountEmail {
            fn from(value: super::LinkedAccountEmail) -> Self {
                Self {
                    address: Ok(value.address),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountEmailInput {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountEmailInputType, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountEmailInput {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountEmailInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEmailInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountEmailInput> for super::LinkedAccountEmailInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountEmailInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountEmailInput> for LinkedAccountEmailInput {
            fn from(value: super::LinkedAccountEmailInput) -> Self {
                Self {
                    address: Ok(value.address),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountEthereum {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type:
                ::std::result::Result<super::LinkedAccountEthereumChainType, ::std::string::String>,
            connector_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountEthereumType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
            wallet_client: ::std::result::Result<
                super::LinkedAccountEthereumWalletClient,
                ::std::string::String,
            >,
            wallet_client_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountEthereum {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_id: Ok(Default::default()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    connector_type: Ok(Default::default()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                    wallet_client: Err("no value supplied for wallet_client".to_string()),
                    wallet_client_type: Ok(Default::default()),
                }
            }
        }
        impl LinkedAccountEthereum {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEthereumChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn connector_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.connector_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for connector_type: {}", e)
                });
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEthereumType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
            pub fn wallet_client<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEthereumWalletClient>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_client: {}", e)
                });
                self
            }
            pub fn wallet_client_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for wallet_client_type: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountEthereum> for super::LinkedAccountEthereum {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountEthereum,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_id: value.chain_id?,
                    chain_type: value.chain_type?,
                    connector_type: value.connector_type?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                    wallet_client: value.wallet_client?,
                    wallet_client_type: value.wallet_client_type?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountEthereum> for LinkedAccountEthereum {
            fn from(value: super::LinkedAccountEthereum) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_id: Ok(value.chain_id),
                    chain_type: Ok(value.chain_type),
                    connector_type: Ok(value.connector_type),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                    wallet_client: Ok(value.wallet_client),
                    wallet_client_type: Ok(value.wallet_client_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountEthereumEmbeddedWallet {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type: ::std::result::Result<
                super::LinkedAccountEthereumEmbeddedWalletChainType,
                ::std::string::String,
            >,
            connector_type: ::std::result::Result<
                super::LinkedAccountEthereumEmbeddedWalletConnectorType,
                ::std::string::String,
            >,
            delegated: ::std::result::Result<bool, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            imported: ::std::result::Result<bool, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            recovery_method: ::std::result::Result<
                super::LinkedAccountEthereumEmbeddedWalletRecoveryMethod,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::LinkedAccountEthereumEmbeddedWalletType,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
            wallet_client: ::std::result::Result<
                super::LinkedAccountEthereumEmbeddedWalletWalletClient,
                ::std::string::String,
            >,
            wallet_client_type: ::std::result::Result<
                super::LinkedAccountEthereumEmbeddedWalletWalletClientType,
                ::std::string::String,
            >,
            wallet_index: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountEthereumEmbeddedWallet {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_id: Err("no value supplied for chain_id".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    connector_type: Err("no value supplied for connector_type".to_string()),
                    delegated: Err("no value supplied for delegated".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    imported: Err("no value supplied for imported".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    recovery_method: Err("no value supplied for recovery_method".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                    wallet_client: Err("no value supplied for wallet_client".to_string()),
                    wallet_client_type: Err("no value supplied for wallet_client_type".to_string()),
                    wallet_index: Err("no value supplied for wallet_index".to_string()),
                }
            }
        }
        impl LinkedAccountEthereumEmbeddedWallet {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEthereumEmbeddedWalletChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn connector_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEthereumEmbeddedWalletConnectorType>,
                T::Error: ::std::fmt::Display,
            {
                self.connector_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for connector_type: {}", e)
                });
                self
            }
            pub fn delegated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.delegated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for delegated: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn imported<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.imported = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for imported: {}", e));
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn recovery_method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountEthereumEmbeddedWalletRecoveryMethod,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.recovery_method = value.try_into().map_err(|e| {
                    format!("error converting supplied value for recovery_method: {}", e)
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEthereumEmbeddedWalletType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
            pub fn wallet_client<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountEthereumEmbeddedWalletWalletClient>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_client: {}", e)
                });
                self
            }
            pub fn wallet_client_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountEthereumEmbeddedWalletWalletClientType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for wallet_client_type: {}",
                        e
                    )
                });
                self
            }
            pub fn wallet_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_index = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_index: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountEthereumEmbeddedWallet>
            for super::LinkedAccountEthereumEmbeddedWallet
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountEthereumEmbeddedWallet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_id: value.chain_id?,
                    chain_type: value.chain_type?,
                    connector_type: value.connector_type?,
                    delegated: value.delegated?,
                    first_verified_at: value.first_verified_at?,
                    id: value.id?,
                    imported: value.imported?,
                    latest_verified_at: value.latest_verified_at?,
                    recovery_method: value.recovery_method?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                    wallet_client: value.wallet_client?,
                    wallet_client_type: value.wallet_client_type?,
                    wallet_index: value.wallet_index?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountEthereumEmbeddedWallet>
            for LinkedAccountEthereumEmbeddedWallet
        {
            fn from(value: super::LinkedAccountEthereumEmbeddedWallet) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_id: Ok(value.chain_id),
                    chain_type: Ok(value.chain_type),
                    connector_type: Ok(value.connector_type),
                    delegated: Ok(value.delegated),
                    first_verified_at: Ok(value.first_verified_at),
                    id: Ok(value.id),
                    imported: Ok(value.imported),
                    latest_verified_at: Ok(value.latest_verified_at),
                    recovery_method: Ok(value.recovery_method),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                    wallet_client: Ok(value.wallet_client),
                    wallet_client_type: Ok(value.wallet_client_type),
                    wallet_index: Ok(value.wallet_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountFarcaster {
            bio: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            display_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            fid: ::std::result::Result<f64, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            homepage_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            owner_address: ::std::result::Result<::std::string::String, ::std::string::String>,
            profile_picture: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            profile_picture_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            signer_public_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<super::LinkedAccountFarcasterType, ::std::string::String>,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountFarcaster {
            fn default() -> Self {
                Self {
                    bio: Ok(Default::default()),
                    display_name: Ok(Default::default()),
                    fid: Err("no value supplied for fid".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    homepage_url: Ok(Default::default()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    owner_address: Err("no value supplied for owner_address".to_string()),
                    profile_picture: Ok(Default::default()),
                    profile_picture_url: Ok(Default::default()),
                    signer_public_key: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Ok(Default::default()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountFarcaster {
            pub fn bio<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bio = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bio: {}", e));
                self
            }
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn fid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.fid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fid: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn homepage_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.homepage_url = value.try_into().map_err(|e| {
                    format!("error converting supplied value for homepage_url: {}", e)
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn owner_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.owner_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for owner_address: {}", e)
                });
                self
            }
            pub fn profile_picture<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.profile_picture = value.try_into().map_err(|e| {
                    format!("error converting supplied value for profile_picture: {}", e)
                });
                self
            }
            pub fn profile_picture_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.profile_picture_url = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for profile_picture_url: {}",
                        e
                    )
                });
                self
            }
            pub fn signer_public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.signer_public_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for signer_public_key: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountFarcasterType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountFarcaster> for super::LinkedAccountFarcaster {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountFarcaster,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bio: value.bio?,
                    display_name: value.display_name?,
                    fid: value.fid?,
                    first_verified_at: value.first_verified_at?,
                    homepage_url: value.homepage_url?,
                    latest_verified_at: value.latest_verified_at?,
                    owner_address: value.owner_address?,
                    profile_picture: value.profile_picture?,
                    profile_picture_url: value.profile_picture_url?,
                    signer_public_key: value.signer_public_key?,
                    type_: value.type_?,
                    username: value.username?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountFarcaster> for LinkedAccountFarcaster {
            fn from(value: super::LinkedAccountFarcaster) -> Self {
                Self {
                    bio: Ok(value.bio),
                    display_name: Ok(value.display_name),
                    fid: Ok(value.fid),
                    first_verified_at: Ok(value.first_verified_at),
                    homepage_url: Ok(value.homepage_url),
                    latest_verified_at: Ok(value.latest_verified_at),
                    owner_address: Ok(value.owner_address),
                    profile_picture: Ok(value.profile_picture),
                    profile_picture_url: Ok(value.profile_picture_url),
                    signer_public_key: Ok(value.signer_public_key),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountFarcasterInput {
            bio: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountFarcasterInputBio>,
                ::std::string::String,
            >,
            display_name: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountFarcasterInputDisplayName>,
                ::std::string::String,
            >,
            fid: ::std::result::Result<i64, ::std::string::String>,
            homepage_url: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountFarcasterInputHomepageUrl>,
                ::std::string::String,
            >,
            owner_address: ::std::result::Result<::std::string::String, ::std::string::String>,
            profile_picture_url: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountFarcasterInputProfilePictureUrl>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::LinkedAccountFarcasterInputType,
                ::std::string::String,
            >,
            username: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountFarcasterInputUsername>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountFarcasterInput {
            fn default() -> Self {
                Self {
                    bio: Ok(Default::default()),
                    display_name: Ok(Default::default()),
                    fid: Err("no value supplied for fid".to_string()),
                    homepage_url: Ok(Default::default()),
                    owner_address: Err("no value supplied for owner_address".to_string()),
                    profile_picture_url: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Ok(Default::default()),
                }
            }
        }
        impl LinkedAccountFarcasterInput {
            pub fn bio<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountFarcasterInputBio>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.bio = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bio: {}", e));
                self
            }
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountFarcasterInputDisplayName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn fid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.fid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fid: {}", e));
                self
            }
            pub fn homepage_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountFarcasterInputHomepageUrl>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.homepage_url = value.try_into().map_err(|e| {
                    format!("error converting supplied value for homepage_url: {}", e)
                });
                self
            }
            pub fn owner_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.owner_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for owner_address: {}", e)
                });
                self
            }
            pub fn profile_picture_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountFarcasterInputProfilePictureUrl>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.profile_picture_url = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for profile_picture_url: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountFarcasterInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountFarcasterInputUsername>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountFarcasterInput> for super::LinkedAccountFarcasterInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountFarcasterInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bio: value.bio?,
                    display_name: value.display_name?,
                    fid: value.fid?,
                    homepage_url: value.homepage_url?,
                    owner_address: value.owner_address?,
                    profile_picture_url: value.profile_picture_url?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountFarcasterInput> for LinkedAccountFarcasterInput {
            fn from(value: super::LinkedAccountFarcasterInput) -> Self {
                Self {
                    bio: Ok(value.bio),
                    display_name: Ok(value.display_name),
                    fid: Ok(value.fid),
                    homepage_url: Ok(value.homepage_url),
                    owner_address: Ok(value.owner_address),
                    profile_picture_url: Ok(value.profile_picture_url),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountGithubInput {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<
                super::LinkedAccountGithubInputSubject,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountGithubInputType, ::std::string::String>,
            username: ::std::result::Result<
                super::LinkedAccountGithubInputUsername,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountGithubInput {
            fn default() -> Self {
                Self {
                    email: Ok(Default::default()),
                    name: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl LinkedAccountGithubInput {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountGithubInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountGithubInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountGithubInputUsername>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountGithubInput> for super::LinkedAccountGithubInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountGithubInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountGithubInput> for LinkedAccountGithubInput {
            fn from(value: super::LinkedAccountGithubInput) -> Self {
                Self {
                    email: Ok(value.email),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountGithubOauth {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountGithubOauthType, ::std::string::String>,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountGithubOauth {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountGithubOauth {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountGithubOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountGithubOauth> for super::LinkedAccountGithubOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountGithubOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountGithubOauth> for LinkedAccountGithubOauth {
            fn from(value: super::LinkedAccountGithubOauth) -> Self {
                Self {
                    email: Ok(value.email),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountGoogleInput {
            email: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            subject: ::std::result::Result<
                super::LinkedAccountGoogleInputSubject,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountGoogleInputType, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountGoogleInput {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountGoogleInput {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountGoogleInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountGoogleInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountGoogleInput> for super::LinkedAccountGoogleInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountGoogleInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountGoogleInput> for LinkedAccountGoogleInput {
            fn from(value: super::LinkedAccountGoogleInput) -> Self {
                Self {
                    email: Ok(value.email),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountGoogleOauth {
            email: ::std::result::Result<::std::string::String, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountGoogleOauthType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountGoogleOauth {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountGoogleOauth {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountGoogleOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountGoogleOauth> for super::LinkedAccountGoogleOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountGoogleOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountGoogleOauth> for LinkedAccountGoogleOauth {
            fn from(value: super::LinkedAccountGoogleOauth) -> Self {
                Self {
                    email: Ok(value.email),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountInstagramInput {
            subject: ::std::result::Result<
                super::LinkedAccountInstagramInputSubject,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::LinkedAccountInstagramInputType,
                ::std::string::String,
            >,
            username: ::std::result::Result<
                super::LinkedAccountInstagramInputUsername,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountInstagramInput {
            fn default() -> Self {
                Self {
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl LinkedAccountInstagramInput {
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountInstagramInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountInstagramInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountInstagramInputUsername>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountInstagramInput> for super::LinkedAccountInstagramInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountInstagramInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountInstagramInput> for LinkedAccountInstagramInput {
            fn from(value: super::LinkedAccountInstagramInput) -> Self {
                Self {
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountInstagramOauth {
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<
                super::LinkedAccountInstagramOauthType,
                ::std::string::String,
            >,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountInstagramOauth {
            fn default() -> Self {
                Self {
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountInstagramOauth {
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountInstagramOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountInstagramOauth> for super::LinkedAccountInstagramOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountInstagramOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountInstagramOauth> for LinkedAccountInstagramOauth {
            fn from(value: super::LinkedAccountInstagramOauth) -> Self {
                Self {
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountLineInput {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountLineInputName>,
                ::std::string::String,
            >,
            profile_picture_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject:
                ::std::result::Result<super::LinkedAccountLineInputSubject, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountLineInputType, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountLineInput {
            fn default() -> Self {
                Self {
                    email: Ok(Default::default()),
                    name: Ok(Default::default()),
                    profile_picture_url: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountLineInput {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountLineInputName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn profile_picture_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.profile_picture_url = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for profile_picture_url: {}",
                        e
                    )
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountLineInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountLineInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountLineInput> for super::LinkedAccountLineInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountLineInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    name: value.name?,
                    profile_picture_url: value.profile_picture_url?,
                    subject: value.subject?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountLineInput> for LinkedAccountLineInput {
            fn from(value: super::LinkedAccountLineInput) -> Self {
                Self {
                    email: Ok(value.email),
                    name: Ok(value.name),
                    profile_picture_url: Ok(value.profile_picture_url),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountLineOauth {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            profile_picture_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountLineOauthType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountLineOauth {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    profile_picture_url: Err(
                        "no value supplied for profile_picture_url".to_string()
                    ),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountLineOauth {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn profile_picture_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.profile_picture_url = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for profile_picture_url: {}",
                        e
                    )
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountLineOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountLineOauth> for super::LinkedAccountLineOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountLineOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    name: value.name?,
                    profile_picture_url: value.profile_picture_url?,
                    subject: value.subject?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountLineOauth> for LinkedAccountLineOauth {
            fn from(value: super::LinkedAccountLineOauth) -> Self {
                Self {
                    email: Ok(value.email),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    name: Ok(value.name),
                    profile_picture_url: Ok(value.profile_picture_url),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountLinkedInInput {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<
                super::LinkedAccountLinkedInInputSubject,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountLinkedInInputType, ::std::string::String>,
            vanity_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountLinkedInInput {
            fn default() -> Self {
                Self {
                    email: Ok(Default::default()),
                    name: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    vanity_name: Ok(Default::default()),
                }
            }
        }
        impl LinkedAccountLinkedInInput {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountLinkedInInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountLinkedInInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn vanity_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vanity_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vanity_name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountLinkedInInput> for super::LinkedAccountLinkedInInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountLinkedInInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    vanity_name: value.vanity_name?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountLinkedInInput> for LinkedAccountLinkedInInput {
            fn from(value: super::LinkedAccountLinkedInInput) -> Self {
                Self {
                    email: Ok(value.email),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    vanity_name: Ok(value.vanity_name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountLinkedInOauth {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountLinkedInOauthType, ::std::string::String>,
            vanity_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountLinkedInOauth {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    name: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    vanity_name: Ok(Default::default()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountLinkedInOauth {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountLinkedInOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn vanity_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vanity_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vanity_name: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountLinkedInOauth> for super::LinkedAccountLinkedInOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountLinkedInOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    vanity_name: value.vanity_name?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountLinkedInOauth> for LinkedAccountLinkedInOauth {
            fn from(value: super::LinkedAccountLinkedInOauth) -> Self {
                Self {
                    email: Ok(value.email),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    vanity_name: Ok(value.vanity_name),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountPasskey {
            authenticator_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            created_with_browser: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            created_with_device: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            created_with_os: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            credential_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            enrolled_in_mfa: ::std::result::Result<bool, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            public_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_: ::std::result::Result<super::LinkedAccountPasskeyType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountPasskey {
            fn default() -> Self {
                Self {
                    authenticator_name: Ok(Default::default()),
                    created_with_browser: Ok(Default::default()),
                    created_with_device: Ok(Default::default()),
                    created_with_os: Ok(Default::default()),
                    credential_id: Err("no value supplied for credential_id".to_string()),
                    enrolled_in_mfa: Err("no value supplied for enrolled_in_mfa".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    public_key: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountPasskey {
            pub fn authenticator_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.authenticator_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for authenticator_name: {}",
                        e
                    )
                });
                self
            }
            pub fn created_with_browser<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_with_browser = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for created_with_browser: {}",
                        e
                    )
                });
                self
            }
            pub fn created_with_device<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_with_device = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for created_with_device: {}",
                        e
                    )
                });
                self
            }
            pub fn created_with_os<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.created_with_os = value.try_into().map_err(|e| {
                    format!("error converting supplied value for created_with_os: {}", e)
                });
                self
            }
            pub fn credential_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.credential_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for credential_id: {}", e)
                });
                self
            }
            pub fn enrolled_in_mfa<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enrolled_in_mfa = value.try_into().map_err(|e| {
                    format!("error converting supplied value for enrolled_in_mfa: {}", e)
                });
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountPasskeyType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountPasskey> for super::LinkedAccountPasskey {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountPasskey,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    authenticator_name: value.authenticator_name?,
                    created_with_browser: value.created_with_browser?,
                    created_with_device: value.created_with_device?,
                    created_with_os: value.created_with_os?,
                    credential_id: value.credential_id?,
                    enrolled_in_mfa: value.enrolled_in_mfa?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    public_key: value.public_key?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountPasskey> for LinkedAccountPasskey {
            fn from(value: super::LinkedAccountPasskey) -> Self {
                Self {
                    authenticator_name: Ok(value.authenticator_name),
                    created_with_browser: Ok(value.created_with_browser),
                    created_with_device: Ok(value.created_with_device),
                    created_with_os: Ok(value.created_with_os),
                    credential_id: Ok(value.credential_id),
                    enrolled_in_mfa: Ok(value.enrolled_in_mfa),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    public_key: Ok(value.public_key),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountPhone {
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            number: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            phone_number: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountPhoneType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountPhone {
            fn default() -> Self {
                Self {
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    number: Ok(Default::default()),
                    phone_number: Err("no value supplied for phone_number".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountPhone {
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.number = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for number: {}", e));
                self
            }
            pub fn phone_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.phone_number = value.try_into().map_err(|e| {
                    format!("error converting supplied value for phone_number: {}", e)
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountPhoneType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountPhone> for super::LinkedAccountPhone {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountPhone,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    number: value.number?,
                    phone_number: value.phone_number?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountPhone> for LinkedAccountPhone {
            fn from(value: super::LinkedAccountPhone) -> Self {
                Self {
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    number: Ok(value.number),
                    phone_number: Ok(value.phone_number),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountPhoneInput {
            number: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountPhoneInputType, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountPhoneInput {
            fn default() -> Self {
                Self {
                    number: Err("no value supplied for number".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountPhoneInput {
            pub fn number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.number = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for number: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountPhoneInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountPhoneInput> for super::LinkedAccountPhoneInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountPhoneInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    number: value.number?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountPhoneInput> for LinkedAccountPhoneInput {
            fn from(value: super::LinkedAccountPhoneInput) -> Self {
                Self {
                    number: Ok(value.number),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountSmartWallet {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            smart_wallet_type: ::std::result::Result<
                super::LinkedAccountSmartWalletSmartWalletType,
                ::std::string::String,
            >,
            smart_wallet_version: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountSmartWalletType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountSmartWallet {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    smart_wallet_type: Err("no value supplied for smart_wallet_type".to_string()),
                    smart_wallet_version: Ok(Default::default()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountSmartWallet {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn smart_wallet_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSmartWalletSmartWalletType>,
                T::Error: ::std::fmt::Display,
            {
                self.smart_wallet_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for smart_wallet_type: {}",
                        e
                    )
                });
                self
            }
            pub fn smart_wallet_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.smart_wallet_version = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for smart_wallet_version: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSmartWalletType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountSmartWallet> for super::LinkedAccountSmartWallet {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountSmartWallet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    smart_wallet_type: value.smart_wallet_type?,
                    smart_wallet_version: value.smart_wallet_version?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountSmartWallet> for LinkedAccountSmartWallet {
            fn from(value: super::LinkedAccountSmartWallet) -> Self {
                Self {
                    address: Ok(value.address),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    smart_wallet_type: Ok(value.smart_wallet_type),
                    smart_wallet_version: Ok(value.smart_wallet_version),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountSolana {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type:
                ::std::result::Result<super::LinkedAccountSolanaChainType, ::std::string::String>,
            connector_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            type_: ::std::result::Result<super::LinkedAccountSolanaType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
            wallet_client: ::std::result::Result<
                super::LinkedAccountSolanaWalletClient,
                ::std::string::String,
            >,
            wallet_client_type: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountSolana {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    connector_type: Ok(Default::default()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                    wallet_client: Err("no value supplied for wallet_client".to_string()),
                    wallet_client_type: Ok(Default::default()),
                }
            }
        }
        impl LinkedAccountSolana {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn connector_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.connector_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for connector_type: {}", e)
                });
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
            pub fn wallet_client<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaWalletClient>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_client: {}", e)
                });
                self
            }
            pub fn wallet_client_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for wallet_client_type: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountSolana> for super::LinkedAccountSolana {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountSolana,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    connector_type: value.connector_type?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                    wallet_client: value.wallet_client?,
                    wallet_client_type: value.wallet_client_type?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountSolana> for LinkedAccountSolana {
            fn from(value: super::LinkedAccountSolana) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    connector_type: Ok(value.connector_type),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                    wallet_client: Ok(value.wallet_client),
                    wallet_client_type: Ok(value.wallet_client_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountSolanaEmbeddedWallet {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type: ::std::result::Result<
                super::LinkedAccountSolanaEmbeddedWalletChainType,
                ::std::string::String,
            >,
            connector_type: ::std::result::Result<
                super::LinkedAccountSolanaEmbeddedWalletConnectorType,
                ::std::string::String,
            >,
            delegated: ::std::result::Result<bool, ::std::string::String>,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            imported: ::std::result::Result<bool, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            recovery_method: ::std::result::Result<
                super::LinkedAccountSolanaEmbeddedWalletRecoveryMethod,
                ::std::string::String,
            >,
            type_: ::std::result::Result<
                super::LinkedAccountSolanaEmbeddedWalletType,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
            wallet_client: ::std::result::Result<
                super::LinkedAccountSolanaEmbeddedWalletWalletClient,
                ::std::string::String,
            >,
            wallet_client_type: ::std::result::Result<
                super::LinkedAccountSolanaEmbeddedWalletWalletClientType,
                ::std::string::String,
            >,
            wallet_index: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountSolanaEmbeddedWallet {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_id: Err("no value supplied for chain_id".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    connector_type: Err("no value supplied for connector_type".to_string()),
                    delegated: Err("no value supplied for delegated".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    imported: Err("no value supplied for imported".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                    recovery_method: Err("no value supplied for recovery_method".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                    wallet_client: Err("no value supplied for wallet_client".to_string()),
                    wallet_client_type: Err("no value supplied for wallet_client_type".to_string()),
                    wallet_index: Err("no value supplied for wallet_index".to_string()),
                }
            }
        }
        impl LinkedAccountSolanaEmbeddedWallet {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_id: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaEmbeddedWalletChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn connector_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaEmbeddedWalletConnectorType>,
                T::Error: ::std::fmt::Display,
            {
                self.connector_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for connector_type: {}", e)
                });
                self
            }
            pub fn delegated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.delegated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for delegated: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn imported<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.imported = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for imported: {}", e));
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn recovery_method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaEmbeddedWalletRecoveryMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.recovery_method = value.try_into().map_err(|e| {
                    format!("error converting supplied value for recovery_method: {}", e)
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaEmbeddedWalletType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
            pub fn wallet_client<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSolanaEmbeddedWalletWalletClient>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_client: {}", e)
                });
                self
            }
            pub fn wallet_client_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::LinkedAccountSolanaEmbeddedWalletWalletClientType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_client_type = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for wallet_client_type: {}",
                        e
                    )
                });
                self
            }
            pub fn wallet_index<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_index = value.try_into().map_err(|e| {
                    format!("error converting supplied value for wallet_index: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountSolanaEmbeddedWallet>
            for super::LinkedAccountSolanaEmbeddedWallet
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountSolanaEmbeddedWallet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_id: value.chain_id?,
                    chain_type: value.chain_type?,
                    connector_type: value.connector_type?,
                    delegated: value.delegated?,
                    first_verified_at: value.first_verified_at?,
                    id: value.id?,
                    imported: value.imported?,
                    latest_verified_at: value.latest_verified_at?,
                    public_key: value.public_key?,
                    recovery_method: value.recovery_method?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                    wallet_client: value.wallet_client?,
                    wallet_client_type: value.wallet_client_type?,
                    wallet_index: value.wallet_index?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountSolanaEmbeddedWallet>
            for LinkedAccountSolanaEmbeddedWallet
        {
            fn from(value: super::LinkedAccountSolanaEmbeddedWallet) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_id: Ok(value.chain_id),
                    chain_type: Ok(value.chain_type),
                    connector_type: Ok(value.connector_type),
                    delegated: Ok(value.delegated),
                    first_verified_at: Ok(value.first_verified_at),
                    id: Ok(value.id),
                    imported: Ok(value.imported),
                    latest_verified_at: Ok(value.latest_verified_at),
                    public_key: Ok(value.public_key),
                    recovery_method: Ok(value.recovery_method),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                    wallet_client: Ok(value.wallet_client),
                    wallet_client_type: Ok(value.wallet_client_type),
                    wallet_index: Ok(value.wallet_index),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountSpotifyInput {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountSpotifyInputType, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountSpotifyInput {
            fn default() -> Self {
                Self {
                    email: Ok(Default::default()),
                    name: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountSpotifyInput {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSpotifyInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountSpotifyInput> for super::LinkedAccountSpotifyInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountSpotifyInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountSpotifyInput> for LinkedAccountSpotifyInput {
            fn from(value: super::LinkedAccountSpotifyInput) -> Self {
                Self {
                    email: Ok(value.email),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountSpotifyOauth {
            email: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountSpotifyOauthType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountSpotifyOauth {
            fn default() -> Self {
                Self {
                    email: Err("no value supplied for email".to_string()),
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountSpotifyOauth {
            pub fn email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.email = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for email: {}", e));
                self
            }
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountSpotifyOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountSpotifyOauth> for super::LinkedAccountSpotifyOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountSpotifyOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    email: value.email?,
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountSpotifyOauth> for LinkedAccountSpotifyOauth {
            fn from(value: super::LinkedAccountSpotifyOauth) -> Self {
                Self {
                    email: Ok(value.email),
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountTelegramInput {
            first_name: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountTelegramInputFirstName>,
                ::std::string::String,
            >,
            last_name: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountTelegramInputLastName>,
                ::std::string::String,
            >,
            photo_url: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountTelegramInputPhotoUrl>,
                ::std::string::String,
            >,
            telegram_user_id: ::std::result::Result<
                super::LinkedAccountTelegramInputTelegramUserId,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountTelegramInputType, ::std::string::String>,
            username: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountTelegramInputUsername>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountTelegramInput {
            fn default() -> Self {
                Self {
                    first_name: Ok(Default::default()),
                    last_name: Ok(Default::default()),
                    photo_url: Ok(Default::default()),
                    telegram_user_id: Err("no value supplied for telegram_user_id".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Ok(Default::default()),
                }
            }
        }
        impl LinkedAccountTelegramInput {
            pub fn first_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountTelegramInputFirstName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.first_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first_name: {}", e));
                self
            }
            pub fn last_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountTelegramInputLastName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.last_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_name: {}", e));
                self
            }
            pub fn photo_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountTelegramInputPhotoUrl>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.photo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for photo_url: {}", e));
                self
            }
            pub fn telegram_user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTelegramInputTelegramUserId>,
                T::Error: ::std::fmt::Display,
            {
                self.telegram_user_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for telegram_user_id: {}",
                        e
                    )
                });
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTelegramInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountTelegramInputUsername>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountTelegramInput> for super::LinkedAccountTelegramInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountTelegramInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_name: value.first_name?,
                    last_name: value.last_name?,
                    photo_url: value.photo_url?,
                    telegram_user_id: value.telegram_user_id?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountTelegramInput> for LinkedAccountTelegramInput {
            fn from(value: super::LinkedAccountTelegramInput) -> Self {
                Self {
                    first_name: Ok(value.first_name),
                    last_name: Ok(value.last_name),
                    photo_url: Ok(value.photo_url),
                    telegram_user_id: Ok(value.telegram_user_id),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountTiktokInput {
            name: ::std::result::Result<
                ::std::option::Option<super::LinkedAccountTiktokInputName>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<
                super::LinkedAccountTiktokInputSubject,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountTiktokInputType, ::std::string::String>,
            username: ::std::result::Result<
                super::LinkedAccountTiktokInputUsername,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountTiktokInput {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl LinkedAccountTiktokInput {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::LinkedAccountTiktokInputName>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTiktokInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTiktokInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTiktokInputUsername>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountTiktokInput> for super::LinkedAccountTiktokInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountTiktokInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountTiktokInput> for LinkedAccountTiktokInput {
            fn from(value: super::LinkedAccountTiktokInput) -> Self {
                Self {
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountTiktokOauth {
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountTiktokOauthType, ::std::string::String>,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountTiktokOauth {
            fn default() -> Self {
                Self {
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountTiktokOauth {
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTiktokOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountTiktokOauth> for super::LinkedAccountTiktokOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountTiktokOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    name: value.name?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountTiktokOauth> for LinkedAccountTiktokOauth {
            fn from(value: super::LinkedAccountTiktokOauth) -> Self {
                Self {
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    name: Ok(value.name),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountTwitterInput {
            name:
                ::std::result::Result<super::LinkedAccountTwitterInputName, ::std::string::String>,
            profile_picture_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<
                super::LinkedAccountTwitterInputSubject,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountTwitterInputType, ::std::string::String>,
            username: ::std::result::Result<
                super::LinkedAccountTwitterInputUsername,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountTwitterInput {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    profile_picture_url: Ok(Default::default()),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }
        impl LinkedAccountTwitterInput {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTwitterInputName>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn profile_picture_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.profile_picture_url = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for profile_picture_url: {}",
                        e
                    )
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTwitterInputSubject>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTwitterInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTwitterInputUsername>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountTwitterInput> for super::LinkedAccountTwitterInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountTwitterInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    profile_picture_url: value.profile_picture_url?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountTwitterInput> for LinkedAccountTwitterInput {
            fn from(value: super::LinkedAccountTwitterInput) -> Self {
                Self {
                    name: Ok(value.name),
                    profile_picture_url: Ok(value.profile_picture_url),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountTwitterOauth {
            first_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            latest_verified_at:
                ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            profile_picture_url: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subject: ::std::result::Result<::std::string::String, ::std::string::String>,
            type_:
                ::std::result::Result<super::LinkedAccountTwitterOauthType, ::std::string::String>,
            username: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountTwitterOauth {
            fn default() -> Self {
                Self {
                    first_verified_at: Err("no value supplied for first_verified_at".to_string()),
                    latest_verified_at: Err("no value supplied for latest_verified_at".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    profile_picture_url: Err(
                        "no value supplied for profile_picture_url".to_string()
                    ),
                    subject: Err("no value supplied for subject".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                    username: Err("no value supplied for username".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl LinkedAccountTwitterOauth {
            pub fn first_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for first_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn latest_verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.latest_verified_at = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for latest_verified_at: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn profile_picture_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.profile_picture_url = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for profile_picture_url: {}",
                        e
                    )
                });
                self
            }
            pub fn subject<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.subject = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subject: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountTwitterOauthType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountTwitterOauth> for super::LinkedAccountTwitterOauth {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountTwitterOauth,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_verified_at: value.first_verified_at?,
                    latest_verified_at: value.latest_verified_at?,
                    name: value.name?,
                    profile_picture_url: value.profile_picture_url?,
                    subject: value.subject?,
                    type_: value.type_?,
                    username: value.username?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountTwitterOauth> for LinkedAccountTwitterOauth {
            fn from(value: super::LinkedAccountTwitterOauth) -> Self {
                Self {
                    first_verified_at: Ok(value.first_verified_at),
                    latest_verified_at: Ok(value.latest_verified_at),
                    name: Ok(value.name),
                    profile_picture_url: Ok(value.profile_picture_url),
                    subject: Ok(value.subject),
                    type_: Ok(value.type_),
                    username: Ok(value.username),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountWalletInput {
            address: ::std::result::Result<
                super::LinkedAccountWalletInputAddress,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                super::LinkedAccountWalletInputChainType,
                ::std::string::String,
            >,
            type_:
                ::std::result::Result<super::LinkedAccountWalletInputType, ::std::string::String>,
        }
        impl ::std::default::Default for LinkedAccountWalletInput {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    type_: Err("no value supplied for type_".to_string()),
                }
            }
        }
        impl LinkedAccountWalletInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountWalletInputAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountWalletInputChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkedAccountWalletInputType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountWalletInput> for super::LinkedAccountWalletInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountWalletInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    type_: value.type_?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountWalletInput> for LinkedAccountWalletInput {
            fn from(value: super::LinkedAccountWalletInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    type_: Ok(value.type_),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct LinkedAccountWalletInputAddress {
            subtype_0: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for LinkedAccountWalletInputAddress {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                }
            }
        }
        impl LinkedAccountWalletInputAddress {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<LinkedAccountWalletInputAddress>
            for super::LinkedAccountWalletInputAddress
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkedAccountWalletInputAddress,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                })
            }
        }
        impl ::std::convert::From<super::LinkedAccountWalletInputAddress>
            for LinkedAccountWalletInputAddress
        {
            fn from(value: super::LinkedAccountWalletInputAddress) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Offramp {
            deposit_instructions:
                ::std::result::Result<super::OfframpDepositInstructions, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<super::OfframpStatus, ::std::string::String>,
        }
        impl ::std::default::Default for Offramp {
            fn default() -> Self {
                Self {
                    deposit_instructions: Err(
                        "no value supplied for deposit_instructions".to_string()
                    ),
                    id: Err("no value supplied for id".to_string()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl Offramp {
            pub fn deposit_instructions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OfframpDepositInstructions>,
                T::Error: ::std::fmt::Display,
            {
                self.deposit_instructions = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for deposit_instructions: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OfframpStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Offramp> for super::Offramp {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Offramp,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    deposit_instructions: value.deposit_instructions?,
                    id: value.id?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::Offramp> for Offramp {
            fn from(value: super::Offramp) -> Self {
                Self {
                    deposit_instructions: Ok(value.deposit_instructions),
                    id: Ok(value.id),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OfframpDepositInstructions {
            amount: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain: ::std::result::Result<
                super::OfframpDepositInstructionsChain,
                ::std::string::String,
            >,
            currency: ::std::result::Result<
                super::OfframpDepositInstructionsCurrency,
                ::std::string::String,
            >,
            from_address: ::std::result::Result<::std::string::String, ::std::string::String>,
            to_address: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for OfframpDepositInstructions {
            fn default() -> Self {
                Self {
                    amount: Err("no value supplied for amount".to_string()),
                    chain: Err("no value supplied for chain".to_string()),
                    currency: Err("no value supplied for currency".to_string()),
                    from_address: Err("no value supplied for from_address".to_string()),
                    to_address: Err("no value supplied for to_address".to_string()),
                }
            }
        }
        impl OfframpDepositInstructions {
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn chain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OfframpDepositInstructionsChain>,
                T::Error: ::std::fmt::Display,
            {
                self.chain = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain: {}", e));
                self
            }
            pub fn currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OfframpDepositInstructionsCurrency>,
                T::Error: ::std::fmt::Display,
            {
                self.currency = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for currency: {}", e));
                self
            }
            pub fn from_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.from_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for from_address: {}", e)
                });
                self
            }
            pub fn to_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.to_address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for to_address: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OfframpDepositInstructions> for super::OfframpDepositInstructions {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OfframpDepositInstructions,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    amount: value.amount?,
                    chain: value.chain?,
                    currency: value.currency?,
                    from_address: value.from_address?,
                    to_address: value.to_address?,
                })
            }
        }
        impl ::std::convert::From<super::OfframpDepositInstructions> for OfframpDepositInstructions {
            fn from(value: super::OfframpDepositInstructions) -> Self {
                Self {
                    amount: Ok(value.amount),
                    chain: Ok(value.chain),
                    currency: Ok(value.currency),
                    from_address: Ok(value.from_address),
                    to_address: Ok(value.to_address),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Onramp {
            deposit_instructions:
                ::std::result::Result<super::OnrampDepositInstructions, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            status: ::std::result::Result<super::OnrampStatus, ::std::string::String>,
        }
        impl ::std::default::Default for Onramp {
            fn default() -> Self {
                Self {
                    deposit_instructions: Err(
                        "no value supplied for deposit_instructions".to_string()
                    ),
                    id: Err("no value supplied for id".to_string()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }
        impl Onramp {
            pub fn deposit_instructions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampDepositInstructions>,
                T::Error: ::std::fmt::Display,
            {
                self.deposit_instructions = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for deposit_instructions: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Onramp> for super::Onramp {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Onramp,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    deposit_instructions: value.deposit_instructions?,
                    id: value.id?,
                    status: value.status?,
                })
            }
        }
        impl ::std::convert::From<super::Onramp> for Onramp {
            fn from(value: super::Onramp) -> Self {
                Self {
                    deposit_instructions: Ok(value.deposit_instructions),
                    id: Ok(value.id),
                    status: Ok(value.status),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OnrampDepositInstructions {
            account_holder_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            amount: ::std::result::Result<::std::string::String, ::std::string::String>,
            bank_account_number: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bank_address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bank_beneficiary_address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bank_beneficiary_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bank_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bank_routing_number: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            bic: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            currency: ::std::result::Result<
                super::OnrampDepositInstructionsCurrency,
                ::std::string::String,
            >,
            deposit_message: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            iban: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            payment_rail: ::std::result::Result<
                super::OnrampDepositInstructionsPaymentRail,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OnrampDepositInstructions {
            fn default() -> Self {
                Self {
                    account_holder_name: Ok(Default::default()),
                    amount: Err("no value supplied for amount".to_string()),
                    bank_account_number: Ok(Default::default()),
                    bank_address: Ok(Default::default()),
                    bank_beneficiary_address: Ok(Default::default()),
                    bank_beneficiary_name: Ok(Default::default()),
                    bank_name: Ok(Default::default()),
                    bank_routing_number: Ok(Default::default()),
                    bic: Ok(Default::default()),
                    currency: Err("no value supplied for currency".to_string()),
                    deposit_message: Ok(Default::default()),
                    iban: Ok(Default::default()),
                    payment_rail: Err("no value supplied for payment_rail".to_string()),
                }
            }
        }
        impl OnrampDepositInstructions {
            pub fn account_holder_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.account_holder_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for account_holder_name: {}",
                        e
                    )
                });
                self
            }
            pub fn amount<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.amount = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for amount: {}", e));
                self
            }
            pub fn bank_account_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bank_account_number = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for bank_account_number: {}",
                        e
                    )
                });
                self
            }
            pub fn bank_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bank_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for bank_address: {}", e)
                });
                self
            }
            pub fn bank_beneficiary_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bank_beneficiary_address = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for bank_beneficiary_address: {}",
                        e
                    )
                });
                self
            }
            pub fn bank_beneficiary_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bank_beneficiary_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for bank_beneficiary_name: {}",
                        e
                    )
                });
                self
            }
            pub fn bank_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bank_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bank_name: {}", e));
                self
            }
            pub fn bank_routing_number<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bank_routing_number = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for bank_routing_number: {}",
                        e
                    )
                });
                self
            }
            pub fn bic<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.bic = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bic: {}", e));
                self
            }
            pub fn currency<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampDepositInstructionsCurrency>,
                T::Error: ::std::fmt::Display,
            {
                self.currency = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for currency: {}", e));
                self
            }
            pub fn deposit_message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.deposit_message = value.try_into().map_err(|e| {
                    format!("error converting supplied value for deposit_message: {}", e)
                });
                self
            }
            pub fn iban<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.iban = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for iban: {}", e));
                self
            }
            pub fn payment_rail<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::OnrampDepositInstructionsPaymentRail>,
                T::Error: ::std::fmt::Display,
            {
                self.payment_rail = value.try_into().map_err(|e| {
                    format!("error converting supplied value for payment_rail: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<OnrampDepositInstructions> for super::OnrampDepositInstructions {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OnrampDepositInstructions,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    account_holder_name: value.account_holder_name?,
                    amount: value.amount?,
                    bank_account_number: value.bank_account_number?,
                    bank_address: value.bank_address?,
                    bank_beneficiary_address: value.bank_beneficiary_address?,
                    bank_beneficiary_name: value.bank_beneficiary_name?,
                    bank_name: value.bank_name?,
                    bank_routing_number: value.bank_routing_number?,
                    bic: value.bic?,
                    currency: value.currency?,
                    deposit_message: value.deposit_message?,
                    iban: value.iban?,
                    payment_rail: value.payment_rail?,
                })
            }
        }
        impl ::std::convert::From<super::OnrampDepositInstructions> for OnrampDepositInstructions {
            fn from(value: super::OnrampDepositInstructions) -> Self {
                Self {
                    account_holder_name: Ok(value.account_holder_name),
                    amount: Ok(value.amount),
                    bank_account_number: Ok(value.bank_account_number),
                    bank_address: Ok(value.bank_address),
                    bank_beneficiary_address: Ok(value.bank_beneficiary_address),
                    bank_beneficiary_name: Ok(value.bank_beneficiary_name),
                    bank_name: Ok(value.bank_name),
                    bank_routing_number: Ok(value.bank_routing_number),
                    bic: Ok(value.bic),
                    currency: Ok(value.currency),
                    deposit_message: Ok(value.deposit_message),
                    iban: Ok(value.iban),
                    payment_rail: Ok(value.payment_rail),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct OwnerInput {
            subtype_0: ::std::result::Result<
                ::std::option::Option<super::PublicKeyOwner>,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<super::UserOwner>,
                ::std::string::String,
            >,
            subtype_2: ::std::result::Result<
                ::std::option::Option<::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for OwnerInput {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                    subtype_2: Ok(Default::default()),
                }
            }
        }
        impl OwnerInput {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::PublicKeyOwner>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::UserOwner>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
            pub fn subtype_2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<OwnerInput> for super::OwnerInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OwnerInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                    subtype_2: value.subtype_2?,
                })
            }
        }
        impl ::std::convert::From<super::OwnerInput> for OwnerInput {
            fn from(value: super::OwnerInput) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                    subtype_2: Ok(value.subtype_2),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PasskeyMfaMethod {
            type_: ::std::result::Result<super::PasskeyMfaMethodType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for PasskeyMfaMethod {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl PasskeyMfaMethod {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PasskeyMfaMethodType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<PasskeyMfaMethod> for super::PasskeyMfaMethod {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PasskeyMfaMethod,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::PasskeyMfaMethod> for PasskeyMfaMethod {
            fn from(value: super::PasskeyMfaMethod) -> Self {
                Self {
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Policy {
            chain_type: ::std::result::Result<super::PolicyChainType, ::std::string::String>,
            created_at: ::std::result::Result<f64, ::std::string::String>,
            id: ::std::result::Result<super::PolicyId, ::std::string::String>,
            name: ::std::result::Result<super::PolicyName, ::std::string::String>,
            owner_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            rules: ::std::result::Result<::std::vec::Vec<super::PolicyRule>, ::std::string::String>,
            version: ::std::result::Result<super::PolicyVersion, ::std::string::String>,
        }
        impl ::std::default::Default for Policy {
            fn default() -> Self {
                Self {
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    owner_id: Err("no value supplied for owner_id".to_string()),
                    rules: Err("no value supplied for rules".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }
        impl Policy {
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyId>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyName>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn owner_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.owner_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner_id: {}", e));
                self
            }
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PolicyRule>>,
                T::Error: ::std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyVersion>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Policy> for super::Policy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Policy,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chain_type: value.chain_type?,
                    created_at: value.created_at?,
                    id: value.id?,
                    name: value.name?,
                    owner_id: value.owner_id?,
                    rules: value.rules?,
                    version: value.version?,
                })
            }
        }
        impl ::std::convert::From<super::Policy> for Policy {
            fn from(value: super::Policy) -> Self {
                Self {
                    chain_type: Ok(value.chain_type),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    owner_id: Ok(value.owner_id),
                    rules: Ok(value.rules),
                    version: Ok(value.version),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PolicyRule {
            action: ::std::result::Result<super::PolicyRuleAction, ::std::string::String>,
            conditions:
                ::std::result::Result<::std::vec::Vec<super::Condition>, ::std::string::String>,
            method: ::std::result::Result<super::PolicyRuleMethod, ::std::string::String>,
            name: ::std::result::Result<super::PolicyRuleName, ::std::string::String>,
        }
        impl ::std::default::Default for PolicyRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    conditions: Err("no value supplied for conditions".to_string()),
                    method: Err("no value supplied for method".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl PolicyRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn conditions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Condition>>,
                T::Error: ::std::fmt::Display,
            {
                self.conditions = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for conditions: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyRuleMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PolicyRuleName>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<PolicyRule> for super::PolicyRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PolicyRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    conditions: value.conditions?,
                    method: value.method?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::PolicyRule> for PolicyRule {
            fn from(value: super::PolicyRule) -> Self {
                Self {
                    action: Ok(value.action),
                    conditions: Ok(value.conditions),
                    method: Ok(value.method),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PrivateKeyInitInput {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type:
                ::std::result::Result<super::WalletImportSupportedChains, ::std::string::String>,
            encryption_type: ::std::result::Result<super::HpkeEncryption, ::std::string::String>,
            entropy_type:
                ::std::result::Result<super::PrivateKeyInitInputEntropyType, ::std::string::String>,
        }
        impl ::std::default::Default for PrivateKeyInitInput {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                    entropy_type: Err("no value supplied for entropy_type".to_string()),
                }
            }
        }
        impl PrivateKeyInitInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletImportSupportedChains>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HpkeEncryption>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
            pub fn entropy_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PrivateKeyInitInputEntropyType>,
                T::Error: ::std::fmt::Display,
            {
                self.entropy_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for entropy_type: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PrivateKeyInitInput> for super::PrivateKeyInitInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PrivateKeyInitInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    encryption_type: value.encryption_type?,
                    entropy_type: value.entropy_type?,
                })
            }
        }
        impl ::std::convert::From<super::PrivateKeyInitInput> for PrivateKeyInitInput {
            fn from(value: super::PrivateKeyInitInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    encryption_type: Ok(value.encryption_type),
                    entropy_type: Ok(value.entropy_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PrivateKeySubmitInput {
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type:
                ::std::result::Result<super::WalletImportSupportedChains, ::std::string::String>,
            ciphertext: ::std::result::Result<::std::string::String, ::std::string::String>,
            encapsulated_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            encryption_type: ::std::result::Result<super::HpkeEncryption, ::std::string::String>,
            entropy_type: ::std::result::Result<
                super::PrivateKeySubmitInputEntropyType,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for PrivateKeySubmitInput {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    ciphertext: Err("no value supplied for ciphertext".to_string()),
                    encapsulated_key: Err("no value supplied for encapsulated_key".to_string()),
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                    entropy_type: Err("no value supplied for entropy_type".to_string()),
                }
            }
        }
        impl PrivateKeySubmitInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletImportSupportedChains>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn ciphertext<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.ciphertext = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ciphertext: {}", e));
                self
            }
            pub fn encapsulated_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encapsulated_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encapsulated_key: {}",
                        e
                    )
                });
                self
            }
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HpkeEncryption>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
            pub fn entropy_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PrivateKeySubmitInputEntropyType>,
                T::Error: ::std::fmt::Display,
            {
                self.entropy_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for entropy_type: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<PrivateKeySubmitInput> for super::PrivateKeySubmitInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PrivateKeySubmitInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    ciphertext: value.ciphertext?,
                    encapsulated_key: value.encapsulated_key?,
                    encryption_type: value.encryption_type?,
                    entropy_type: value.entropy_type?,
                })
            }
        }
        impl ::std::convert::From<super::PrivateKeySubmitInput> for PrivateKeySubmitInput {
            fn from(value: super::PrivateKeySubmitInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    ciphertext: Ok(value.ciphertext),
                    encapsulated_key: Ok(value.encapsulated_key),
                    encryption_type: Ok(value.encryption_type),
                    entropy_type: Ok(value.entropy_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct PublicKeyOwner {
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for PublicKeyOwner {
            fn default() -> Self {
                Self {
                    public_key: Err("no value supplied for public_key".to_string()),
                }
            }
        }
        impl PublicKeyOwner {
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<PublicKeyOwner> for super::PublicKeyOwner {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PublicKeyOwner,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    public_key: value.public_key?,
                })
            }
        }
        impl ::std::convert::From<super::PublicKeyOwner> for PublicKeyOwner {
            fn from(value: super::PublicKeyOwner) -> Self {
                Self {
                    public_key: Ok(value.public_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RawSign {
            params: ::std::result::Result<super::RawSignParams, ::std::string::String>,
        }
        impl ::std::default::Default for RawSign {
            fn default() -> Self {
                Self {
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl RawSign {
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RawSignParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<RawSign> for super::RawSign {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RawSign,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::RawSign> for RawSign {
            fn from(value: super::RawSign) -> Self {
                Self {
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RawSignParams {
            hash: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for RawSignParams {
            fn default() -> Self {
                Self {
                    hash: Ok(Default::default()),
                }
            }
        }
        impl RawSignParams {
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hash: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<RawSignParams> for super::RawSignParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RawSignParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { hash: value.hash? })
            }
        }
        impl ::std::convert::From<super::RawSignParams> for RawSignParams {
            fn from(value: super::RawSignParams) -> Self {
                Self {
                    hash: Ok(value.hash),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RawSignResponse {
            data: ::std::result::Result<super::RawSignResponseData, ::std::string::String>,
        }
        impl ::std::default::Default for RawSignResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                }
            }
        }
        impl RawSignResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RawSignResponseData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<RawSignResponse> for super::RawSignResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RawSignResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { data: value.data? })
            }
        }
        impl ::std::convert::From<super::RawSignResponse> for RawSignResponse {
            fn from(value: super::RawSignResponse) -> Self {
                Self {
                    data: Ok(value.data),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct RawSignResponseData {
            encoding:
                ::std::result::Result<super::RawSignResponseDataEncoding, ::std::string::String>,
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for RawSignResponseData {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl RawSignResponseData {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RawSignResponseDataEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<RawSignResponseData> for super::RawSignResponseData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RawSignResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::RawSignResponseData> for RawSignResponseData {
            fn from(value: super::RawSignResponseData) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SearchUsersBodyVariant1WalletAddressesItem {
            subtype_0: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SearchUsersBodyVariant1WalletAddressesItem {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                }
            }
        }
        impl SearchUsersBodyVariant1WalletAddressesItem {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SearchUsersBodyVariant1WalletAddressesItem>
            for super::SearchUsersBodyVariant1WalletAddressesItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SearchUsersBodyVariant1WalletAddressesItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                })
            }
        }
        impl ::std::convert::From<super::SearchUsersBodyVariant1WalletAddressesItem>
            for SearchUsersBodyVariant1WalletAddressesItem
        {
            fn from(value: super::SearchUsersBodyVariant1WalletAddressesItem) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SmsMfaMethod {
            type_: ::std::result::Result<super::SmsMfaMethodType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for SmsMfaMethod {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl SmsMfaMethod {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SmsMfaMethodType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SmsMfaMethod> for super::SmsMfaMethod {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SmsMfaMethod,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::SmsMfaMethod> for SmsMfaMethod {
            fn from(value: super::SmsMfaMethod) -> Self {
                Self {
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaProgramInstructionCondition {
            field: ::std::result::Result<
                super::SolanaProgramInstructionConditionField,
                ::std::string::String,
            >,
            field_source: ::std::result::Result<
                super::SolanaProgramInstructionConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaProgramInstructionCondition {
            fn default() -> Self {
                Self {
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl SolanaProgramInstructionCondition {
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaProgramInstructionConditionField>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaProgramInstructionConditionFieldSource>,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaProgramInstructionCondition>
            for super::SolanaProgramInstructionCondition
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaProgramInstructionCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaProgramInstructionCondition>
            for SolanaProgramInstructionCondition
        {
            fn from(value: super::SolanaProgramInstructionCondition) -> Self {
                Self {
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignAndSendTransactionRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            caip2: ::std::result::Result<
                super::SolanaSignAndSendTransactionRpcInputCaip2,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::SolanaSignAndSendTransactionRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::SolanaSignAndSendTransactionRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::SolanaSignAndSendTransactionRpcInputParams,
                ::std::string::String,
            >,
            sponsor: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSignAndSendTransactionRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    caip2: Err("no value supplied for caip2".to_string()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                    sponsor: Ok(Default::default()),
                }
            }
        }
        impl SolanaSignAndSendTransactionRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn caip2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignAndSendTransactionRpcInputCaip2>,
                T::Error: ::std::fmt::Display,
            {
                self.caip2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for caip2: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SolanaSignAndSendTransactionRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignAndSendTransactionRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignAndSendTransactionRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
            pub fn sponsor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sponsor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sponsor: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignAndSendTransactionRpcInput>
            for super::SolanaSignAndSendTransactionRpcInput
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignAndSendTransactionRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    caip2: value.caip2?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                    sponsor: value.sponsor?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignAndSendTransactionRpcInput>
            for SolanaSignAndSendTransactionRpcInput
        {
            fn from(value: super::SolanaSignAndSendTransactionRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    caip2: Ok(value.caip2),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                    sponsor: Ok(value.sponsor),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignAndSendTransactionRpcInputParams {
            encoding: ::std::result::Result<
                super::SolanaSignAndSendTransactionRpcInputParamsEncoding,
                ::std::string::String,
            >,
            transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSignAndSendTransactionRpcInputParams {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl SolanaSignAndSendTransactionRpcInputParams {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::SolanaSignAndSendTransactionRpcInputParamsEncoding,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignAndSendTransactionRpcInputParams>
            for super::SolanaSignAndSendTransactionRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignAndSendTransactionRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignAndSendTransactionRpcInputParams>
            for SolanaSignAndSendTransactionRpcInputParams
        {
            fn from(value: super::SolanaSignAndSendTransactionRpcInputParams) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignAndSendTransactionRpcResponse {
            data: ::std::result::Result<
                ::std::option::Option<super::SolanaSignAndSendTransactionRpcResponseData>,
                ::std::string::String,
            >,
            error: ::std::result::Result<
                ::std::option::Option<super::SolanaSignAndSendTransactionRpcResponseError>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::SolanaSignAndSendTransactionRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaSignAndSendTransactionRpcResponse {
            fn default() -> Self {
                Self {
                    data: Ok(Default::default()),
                    error: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl SolanaSignAndSendTransactionRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SolanaSignAndSendTransactionRpcResponseData>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SolanaSignAndSendTransactionRpcResponseError>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignAndSendTransactionRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignAndSendTransactionRpcResponse>
            for super::SolanaSignAndSendTransactionRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignAndSendTransactionRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    error: value.error?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignAndSendTransactionRpcResponse>
            for SolanaSignAndSendTransactionRpcResponse
        {
            fn from(value: super::SolanaSignAndSendTransactionRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    error: Ok(value.error),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignAndSendTransactionRpcResponseData {
            caip2: ::std::result::Result<
                super::SolanaSignAndSendTransactionRpcResponseDataCaip2,
                ::std::string::String,
            >,
            hash: ::std::result::Result<::std::string::String, ::std::string::String>,
            transaction_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaSignAndSendTransactionRpcResponseData {
            fn default() -> Self {
                Self {
                    caip2: Err("no value supplied for caip2".to_string()),
                    hash: Err("no value supplied for hash".to_string()),
                    transaction_id: Ok(Default::default()),
                }
            }
        }
        impl SolanaSignAndSendTransactionRpcResponseData {
            pub fn caip2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignAndSendTransactionRpcResponseDataCaip2>,
                T::Error: ::std::fmt::Display,
            {
                self.caip2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for caip2: {}", e));
                self
            }
            pub fn hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.hash = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hash: {}", e));
                self
            }
            pub fn transaction_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for transaction_id: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignAndSendTransactionRpcResponseData>
            for super::SolanaSignAndSendTransactionRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignAndSendTransactionRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    caip2: value.caip2?,
                    hash: value.hash?,
                    transaction_id: value.transaction_id?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignAndSendTransactionRpcResponseData>
            for SolanaSignAndSendTransactionRpcResponseData
        {
            fn from(value: super::SolanaSignAndSendTransactionRpcResponseData) -> Self {
                Self {
                    caip2: Ok(value.caip2),
                    hash: Ok(value.hash),
                    transaction_id: Ok(value.transaction_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignAndSendTransactionRpcResponseError {
            code: ::std::result::Result<::std::string::String, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSignAndSendTransactionRpcResponseError {
            fn default() -> Self {
                Self {
                    code: Err("no value supplied for code".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl SolanaSignAndSendTransactionRpcResponseError {
            pub fn code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for code: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignAndSendTransactionRpcResponseError>
            for super::SolanaSignAndSendTransactionRpcResponseError
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignAndSendTransactionRpcResponseError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    code: value.code?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignAndSendTransactionRpcResponseError>
            for SolanaSignAndSendTransactionRpcResponseError
        {
            fn from(value: super::SolanaSignAndSendTransactionRpcResponseError) -> Self {
                Self {
                    code: Ok(value.code),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignMessageRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::SolanaSignMessageRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::SolanaSignMessageRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::SolanaSignMessageRpcInputParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaSignMessageRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl SolanaSignMessageRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SolanaSignMessageRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignMessageRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignMessageRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignMessageRpcInput> for super::SolanaSignMessageRpcInput {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignMessageRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignMessageRpcInput> for SolanaSignMessageRpcInput {
            fn from(value: super::SolanaSignMessageRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignMessageRpcInputParams {
            encoding: ::std::result::Result<
                super::SolanaSignMessageRpcInputParamsEncoding,
                ::std::string::String,
            >,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSignMessageRpcInputParams {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl SolanaSignMessageRpcInputParams {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignMessageRpcInputParamsEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignMessageRpcInputParams>
            for super::SolanaSignMessageRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignMessageRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignMessageRpcInputParams>
            for SolanaSignMessageRpcInputParams
        {
            fn from(value: super::SolanaSignMessageRpcInputParams) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignMessageRpcResponse {
            data: ::std::result::Result<
                super::SolanaSignMessageRpcResponseData,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::SolanaSignMessageRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaSignMessageRpcResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl SolanaSignMessageRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignMessageRpcResponseData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignMessageRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignMessageRpcResponse> for super::SolanaSignMessageRpcResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignMessageRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignMessageRpcResponse> for SolanaSignMessageRpcResponse {
            fn from(value: super::SolanaSignMessageRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignMessageRpcResponseData {
            encoding: ::std::result::Result<
                super::SolanaSignMessageRpcResponseDataEncoding,
                ::std::string::String,
            >,
            signature: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSignMessageRpcResponseData {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    signature: Err("no value supplied for signature".to_string()),
                }
            }
        }
        impl SolanaSignMessageRpcResponseData {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignMessageRpcResponseDataEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn signature<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signature = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signature: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignMessageRpcResponseData>
            for super::SolanaSignMessageRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignMessageRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    signature: value.signature?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignMessageRpcResponseData>
            for SolanaSignMessageRpcResponseData
        {
            fn from(value: super::SolanaSignMessageRpcResponseData) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    signature: Ok(value.signature),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignTransactionRpcInput {
            address: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            chain_type: ::std::result::Result<
                ::std::option::Option<super::SolanaSignTransactionRpcInputChainType>,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::SolanaSignTransactionRpcInputMethod,
                ::std::string::String,
            >,
            params: ::std::result::Result<
                super::SolanaSignTransactionRpcInputParams,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaSignTransactionRpcInput {
            fn default() -> Self {
                Self {
                    address: Ok(Default::default()),
                    chain_type: Ok(Default::default()),
                    method: Err("no value supplied for method".to_string()),
                    params: Err("no value supplied for params".to_string()),
                }
            }
        }
        impl SolanaSignTransactionRpcInput {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::SolanaSignTransactionRpcInputChainType>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignTransactionRpcInputMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
            pub fn params<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignTransactionRpcInputParams>,
                T::Error: ::std::fmt::Display,
            {
                self.params = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for params: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignTransactionRpcInput>
            for super::SolanaSignTransactionRpcInput
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignTransactionRpcInput,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    chain_type: value.chain_type?,
                    method: value.method?,
                    params: value.params?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignTransactionRpcInput> for SolanaSignTransactionRpcInput {
            fn from(value: super::SolanaSignTransactionRpcInput) -> Self {
                Self {
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    method: Ok(value.method),
                    params: Ok(value.params),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignTransactionRpcInputParams {
            encoding: ::std::result::Result<
                super::SolanaSignTransactionRpcInputParamsEncoding,
                ::std::string::String,
            >,
            transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSignTransactionRpcInputParams {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    transaction: Err("no value supplied for transaction".to_string()),
                }
            }
        }
        impl SolanaSignTransactionRpcInputParams {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignTransactionRpcInputParamsEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transaction: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignTransactionRpcInputParams>
            for super::SolanaSignTransactionRpcInputParams
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignTransactionRpcInputParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    transaction: value.transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignTransactionRpcInputParams>
            for SolanaSignTransactionRpcInputParams
        {
            fn from(value: super::SolanaSignTransactionRpcInputParams) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    transaction: Ok(value.transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignTransactionRpcResponse {
            data: ::std::result::Result<
                super::SolanaSignTransactionRpcResponseData,
                ::std::string::String,
            >,
            method: ::std::result::Result<
                super::SolanaSignTransactionRpcResponseMethod,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for SolanaSignTransactionRpcResponse {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    method: Err("no value supplied for method".to_string()),
                }
            }
        }
        impl SolanaSignTransactionRpcResponse {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignTransactionRpcResponseData>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn method<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignTransactionRpcResponseMethod>,
                T::Error: ::std::fmt::Display,
            {
                self.method = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for method: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignTransactionRpcResponse>
            for super::SolanaSignTransactionRpcResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignTransactionRpcResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    method: value.method?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignTransactionRpcResponse>
            for SolanaSignTransactionRpcResponse
        {
            fn from(value: super::SolanaSignTransactionRpcResponse) -> Self {
                Self {
                    data: Ok(value.data),
                    method: Ok(value.method),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSignTransactionRpcResponseData {
            encoding: ::std::result::Result<
                super::SolanaSignTransactionRpcResponseDataEncoding,
                ::std::string::String,
            >,
            signed_transaction: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSignTransactionRpcResponseData {
            fn default() -> Self {
                Self {
                    encoding: Err("no value supplied for encoding".to_string()),
                    signed_transaction: Err("no value supplied for signed_transaction".to_string()),
                }
            }
        }
        impl SolanaSignTransactionRpcResponseData {
            pub fn encoding<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSignTransactionRpcResponseDataEncoding>,
                T::Error: ::std::fmt::Display,
            {
                self.encoding = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for encoding: {}", e));
                self
            }
            pub fn signed_transaction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signed_transaction = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for signed_transaction: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSignTransactionRpcResponseData>
            for super::SolanaSignTransactionRpcResponseData
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSignTransactionRpcResponseData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encoding: value.encoding?,
                    signed_transaction: value.signed_transaction?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSignTransactionRpcResponseData>
            for SolanaSignTransactionRpcResponseData
        {
            fn from(value: super::SolanaSignTransactionRpcResponseData) -> Self {
                Self {
                    encoding: Ok(value.encoding),
                    signed_transaction: Ok(value.signed_transaction),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaSystemProgramInstructionCondition {
            field: ::std::result::Result<
                super::SolanaSystemProgramInstructionConditionField,
                ::std::string::String,
            >,
            field_source: ::std::result::Result<
                super::SolanaSystemProgramInstructionConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaSystemProgramInstructionCondition {
            fn default() -> Self {
                Self {
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl SolanaSystemProgramInstructionCondition {
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaSystemProgramInstructionConditionField>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::SolanaSystemProgramInstructionConditionFieldSource,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaSystemProgramInstructionCondition>
            for super::SolanaSystemProgramInstructionCondition
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaSystemProgramInstructionCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaSystemProgramInstructionCondition>
            for SolanaSystemProgramInstructionCondition
        {
            fn from(value: super::SolanaSystemProgramInstructionCondition) -> Self {
                Self {
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct SolanaTokenProgramInstructionCondition {
            field: ::std::result::Result<
                super::SolanaTokenProgramInstructionConditionField,
                ::std::string::String,
            >,
            field_source: ::std::result::Result<
                super::SolanaTokenProgramInstructionConditionFieldSource,
                ::std::string::String,
            >,
            operator: ::std::result::Result<super::ConditionOperator, ::std::string::String>,
            value: ::std::result::Result<super::ConditionValue, ::std::string::String>,
        }
        impl ::std::default::Default for SolanaTokenProgramInstructionCondition {
            fn default() -> Self {
                Self {
                    field: Err("no value supplied for field".to_string()),
                    field_source: Err("no value supplied for field_source".to_string()),
                    operator: Err("no value supplied for operator".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }
        impl SolanaTokenProgramInstructionCondition {
            pub fn field<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SolanaTokenProgramInstructionConditionField>,
                T::Error: ::std::fmt::Display,
            {
                self.field = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field: {}", e));
                self
            }
            pub fn field_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::SolanaTokenProgramInstructionConditionFieldSource,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.field_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_source: {}", e)
                });
                self
            }
            pub fn operator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionOperator>,
                T::Error: ::std::fmt::Display,
            {
                self.operator = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for operator: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ConditionValue>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<SolanaTokenProgramInstructionCondition>
            for super::SolanaTokenProgramInstructionCondition
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SolanaTokenProgramInstructionCondition,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    field: value.field?,
                    field_source: value.field_source?,
                    operator: value.operator?,
                    value: value.value?,
                })
            }
        }
        impl ::std::convert::From<super::SolanaTokenProgramInstructionCondition>
            for SolanaTokenProgramInstructionCondition
        {
            fn from(value: super::SolanaTokenProgramInstructionCondition) -> Self {
                Self {
                    field: Ok(value.field),
                    field_source: Ok(value.field_source),
                    operator: Ok(value.operator),
                    value: Ok(value.value),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TotpMfaMethod {
            type_: ::std::result::Result<super::TotpMfaMethodType, ::std::string::String>,
            verified_at: ::std::result::Result<f64, ::std::string::String>,
        }
        impl ::std::default::Default for TotpMfaMethod {
            fn default() -> Self {
                Self {
                    type_: Err("no value supplied for type_".to_string()),
                    verified_at: Err("no value supplied for verified_at".to_string()),
                }
            }
        }
        impl TotpMfaMethod {
            pub fn type_<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TotpMfaMethodType>,
                T::Error: ::std::fmt::Display,
            {
                self.type_ = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for type_: {}", e));
                self
            }
            pub fn verified_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.verified_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for verified_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<TotpMfaMethod> for super::TotpMfaMethod {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TotpMfaMethod,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    type_: value.type_?,
                    verified_at: value.verified_at?,
                })
            }
        }
        impl ::std::convert::From<super::TotpMfaMethod> for TotpMfaMethod {
            fn from(value: super::TotpMfaMethod) -> Self {
                Self {
                    type_: Ok(value.type_),
                    verified_at: Ok(value.verified_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Transaction {
            caip2: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<f64, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            sponsored: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            status: ::std::result::Result<super::TransactionStatus, ::std::string::String>,
            transaction_hash: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            wallet_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for Transaction {
            fn default() -> Self {
                Self {
                    caip2: Err("no value supplied for caip2".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    sponsored: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    transaction_hash: Err("no value supplied for transaction_hash".to_string()),
                    wallet_id: Err("no value supplied for wallet_id".to_string()),
                }
            }
        }
        impl Transaction {
            pub fn caip2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.caip2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for caip2: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn sponsored<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sponsored = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sponsored: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TransactionStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn transaction_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_hash = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_hash: {}",
                        e
                    )
                });
                self
            }
            pub fn wallet_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for wallet_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Transaction> for super::Transaction {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Transaction,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    caip2: value.caip2?,
                    created_at: value.created_at?,
                    id: value.id?,
                    sponsored: value.sponsored?,
                    status: value.status?,
                    transaction_hash: value.transaction_hash?,
                    wallet_id: value.wallet_id?,
                })
            }
        }
        impl ::std::convert::From<super::Transaction> for Transaction {
            fn from(value: super::Transaction) -> Self {
                Self {
                    caip2: Ok(value.caip2),
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    sponsored: Ok(value.sponsored),
                    status: Ok(value.status),
                    transaction_hash: Ok(value.transaction_hash),
                    wallet_id: Ok(value.wallet_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateWalletBody {
            additional_signers: ::std::result::Result<
                ::std::option::Option<super::WalletAdditionalSigner>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                ::std::option::Option<super::OwnerInput>,
                ::std::string::String,
            >,
            owner_id: ::std::result::Result<
                ::std::option::Option<super::OwnerIdInput>,
                ::std::string::String,
            >,
            policy_ids: ::std::result::Result<
                ::std::vec::Vec<super::UpdateWalletBodyPolicyIdsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateWalletBody {
            fn default() -> Self {
                Self {
                    additional_signers: Ok(Default::default()),
                    owner: Ok(Default::default()),
                    owner_id: Ok(Default::default()),
                    policy_ids: Ok(Default::default()),
                }
            }
        }
        impl UpdateWalletBody {
            pub fn additional_signers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::WalletAdditionalSigner>>,
                T::Error: ::std::fmt::Display,
            {
                self.additional_signers = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for additional_signers: {}",
                        e
                    )
                });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OwnerInput>>,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner: {}", e));
                self
            }
            pub fn owner_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::OwnerIdInput>>,
                T::Error: ::std::fmt::Display,
            {
                self.owner_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner_id: {}", e));
                self
            }
            pub fn policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::UpdateWalletBodyPolicyIdsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_ids: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateWalletBody> for super::UpdateWalletBody {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateWalletBody,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    additional_signers: value.additional_signers?,
                    owner: value.owner?,
                    owner_id: value.owner_id?,
                    policy_ids: value.policy_ids?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateWalletBody> for UpdateWalletBody {
            fn from(value: super::UpdateWalletBody) -> Self {
                Self {
                    additional_signers: Ok(value.additional_signers),
                    owner: Ok(value.owner),
                    owner_id: Ok(value.owner_id),
                    policy_ids: Ok(value.policy_ids),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct User {
            created_at: ::std::result::Result<f64, ::std::string::String>,
            custom_metadata: ::std::result::Result<
                ::std::option::Option<super::CustomMetadata>,
                ::std::string::String,
            >,
            has_accepted_terms: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            is_guest: ::std::result::Result<bool, ::std::string::String>,
            linked_accounts: ::std::result::Result<
                ::std::vec::Vec<super::UserLinkedAccountsItem>,
                ::std::string::String,
            >,
            mfa_methods: ::std::result::Result<
                ::std::vec::Vec<super::UserMfaMethodsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for User {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    custom_metadata: Ok(Default::default()),
                    has_accepted_terms: Err("no value supplied for has_accepted_terms".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_guest: Err("no value supplied for is_guest".to_string()),
                    linked_accounts: Err("no value supplied for linked_accounts".to_string()),
                    mfa_methods: Err("no value supplied for mfa_methods".to_string()),
                }
            }
        }
        impl User {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn custom_metadata<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::CustomMetadata>>,
                T::Error: ::std::fmt::Display,
            {
                self.custom_metadata = value.try_into().map_err(|e| {
                    format!("error converting supplied value for custom_metadata: {}", e)
                });
                self
            }
            pub fn has_accepted_terms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.has_accepted_terms = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for has_accepted_terms: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn is_guest<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_guest = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_guest: {}", e));
                self
            }
            pub fn linked_accounts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::UserLinkedAccountsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.linked_accounts = value.try_into().map_err(|e| {
                    format!("error converting supplied value for linked_accounts: {}", e)
                });
                self
            }
            pub fn mfa_methods<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::UserMfaMethodsItem>>,
                T::Error: ::std::fmt::Display,
            {
                self.mfa_methods = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mfa_methods: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<User> for super::User {
            type Error = super::error::ConversionError;
            fn try_from(value: User) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    custom_metadata: value.custom_metadata?,
                    has_accepted_terms: value.has_accepted_terms?,
                    id: value.id?,
                    is_guest: value.is_guest?,
                    linked_accounts: value.linked_accounts?,
                    mfa_methods: value.mfa_methods?,
                })
            }
        }
        impl ::std::convert::From<super::User> for User {
            fn from(value: super::User) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    custom_metadata: Ok(value.custom_metadata),
                    has_accepted_terms: Ok(value.has_accepted_terms),
                    id: Ok(value.id),
                    is_guest: Ok(value.is_guest),
                    linked_accounts: Ok(value.linked_accounts),
                    mfa_methods: Ok(value.mfa_methods),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UserOwner {
            user_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for UserOwner {
            fn default() -> Self {
                Self {
                    user_id: Err("no value supplied for user_id".to_string()),
                }
            }
        }
        impl UserOwner {
            pub fn user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UserOwner> for super::UserOwner {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserOwner,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    user_id: value.user_id?,
                })
            }
        }
        impl ::std::convert::From<super::UserOwner> for UserOwner {
            fn from(value: super::UserOwner) -> Self {
                Self {
                    user_id: Ok(value.user_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct Wallet {
            additional_signers:
                ::std::result::Result<super::WalletAdditionalSigner, ::std::string::String>,
            address: ::std::result::Result<::std::string::String, ::std::string::String>,
            chain_type: ::std::result::Result<super::WalletChainType, ::std::string::String>,
            created_at: ::std::result::Result<f64, ::std::string::String>,
            exported_at: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            imported_at: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            owner_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            policy_ids: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            public_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for Wallet {
            fn default() -> Self {
                Self {
                    additional_signers: Err("no value supplied for additional_signers".to_string()),
                    address: Err("no value supplied for address".to_string()),
                    chain_type: Err("no value supplied for chain_type".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    exported_at: Err("no value supplied for exported_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    imported_at: Err("no value supplied for imported_at".to_string()),
                    owner_id: Ok(Default::default()),
                    policy_ids: Err("no value supplied for policy_ids".to_string()),
                    public_key: Ok(Default::default()),
                }
            }
        }
        impl Wallet {
            pub fn additional_signers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletAdditionalSigner>,
                T::Error: ::std::fmt::Display,
            {
                self.additional_signers = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for additional_signers: {}",
                        e
                    )
                });
                self
            }
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn chain_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletChainType>,
                T::Error: ::std::fmt::Display,
            {
                self.chain_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chain_type: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn exported_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.exported_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for exported_at: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn imported_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.imported_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for imported_at: {}", e));
                self
            }
            pub fn owner_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.owner_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner_id: {}", e));
                self
            }
            pub fn policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_ids: {}", e));
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<Wallet> for super::Wallet {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Wallet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    additional_signers: value.additional_signers?,
                    address: value.address?,
                    chain_type: value.chain_type?,
                    created_at: value.created_at?,
                    exported_at: value.exported_at?,
                    id: value.id?,
                    imported_at: value.imported_at?,
                    owner_id: value.owner_id?,
                    policy_ids: value.policy_ids?,
                    public_key: value.public_key?,
                })
            }
        }
        impl ::std::convert::From<super::Wallet> for Wallet {
            fn from(value: super::Wallet) -> Self {
                Self {
                    additional_signers: Ok(value.additional_signers),
                    address: Ok(value.address),
                    chain_type: Ok(value.chain_type),
                    created_at: Ok(value.created_at),
                    exported_at: Ok(value.exported_at),
                    id: Ok(value.id),
                    imported_at: Ok(value.imported_at),
                    owner_id: Ok(value.owner_id),
                    policy_ids: Ok(value.policy_ids),
                    public_key: Ok(value.public_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletAdditionalSignerItem {
            override_policy_ids: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            signer_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WalletAdditionalSignerItem {
            fn default() -> Self {
                Self {
                    override_policy_ids: Err(
                        "no value supplied for override_policy_ids".to_string()
                    ),
                    signer_id: Err("no value supplied for signer_id".to_string()),
                }
            }
        }
        impl WalletAdditionalSignerItem {
            pub fn override_policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.override_policy_ids = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for override_policy_ids: {}",
                        e
                    )
                });
                self
            }
            pub fn signer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signer_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WalletAdditionalSignerItem> for super::WalletAdditionalSignerItem {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletAdditionalSignerItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    override_policy_ids: value.override_policy_ids?,
                    signer_id: value.signer_id?,
                })
            }
        }
        impl ::std::convert::From<super::WalletAdditionalSignerItem> for WalletAdditionalSignerItem {
            fn from(value: super::WalletAdditionalSignerItem) -> Self {
                Self {
                    override_policy_ids: Ok(value.override_policy_ids),
                    signer_id: Ok(value.signer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletExportRequest {
            encryption_type: ::std::result::Result<super::HpkeEncryption, ::std::string::String>,
            recipient_public_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WalletExportRequest {
            fn default() -> Self {
                Self {
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                    recipient_public_key: Err(
                        "no value supplied for recipient_public_key".to_string()
                    ),
                }
            }
        }
        impl WalletExportRequest {
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HpkeEncryption>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
            pub fn recipient_public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.recipient_public_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for recipient_public_key: {}",
                        e
                    )
                });
                self
            }
        }
        impl ::std::convert::TryFrom<WalletExportRequest> for super::WalletExportRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletExportRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encryption_type: value.encryption_type?,
                    recipient_public_key: value.recipient_public_key?,
                })
            }
        }
        impl ::std::convert::From<super::WalletExportRequest> for WalletExportRequest {
            fn from(value: super::WalletExportRequest) -> Self {
                Self {
                    encryption_type: Ok(value.encryption_type),
                    recipient_public_key: Ok(value.recipient_public_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletExportResponse {
            ciphertext: ::std::result::Result<::std::string::String, ::std::string::String>,
            encapsulated_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            encryption_type: ::std::result::Result<super::HpkeEncryption, ::std::string::String>,
        }
        impl ::std::default::Default for WalletExportResponse {
            fn default() -> Self {
                Self {
                    ciphertext: Err("no value supplied for ciphertext".to_string()),
                    encapsulated_key: Err("no value supplied for encapsulated_key".to_string()),
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                }
            }
        }
        impl WalletExportResponse {
            pub fn ciphertext<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.ciphertext = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ciphertext: {}", e));
                self
            }
            pub fn encapsulated_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encapsulated_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encapsulated_key: {}",
                        e
                    )
                });
                self
            }
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HpkeEncryption>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<WalletExportResponse> for super::WalletExportResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletExportResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ciphertext: value.ciphertext?,
                    encapsulated_key: value.encapsulated_key?,
                    encryption_type: value.encryption_type?,
                })
            }
        }
        impl ::std::convert::From<super::WalletExportResponse> for WalletExportResponse {
            fn from(value: super::WalletExportResponse) -> Self {
                Self {
                    ciphertext: Ok(value.ciphertext),
                    encapsulated_key: Ok(value.encapsulated_key),
                    encryption_type: Ok(value.encryption_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletImportInitializationResponse {
            encryption_public_key:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            encryption_type: ::std::result::Result<super::HpkeEncryption, ::std::string::String>,
        }
        impl ::std::default::Default for WalletImportInitializationResponse {
            fn default() -> Self {
                Self {
                    encryption_public_key: Err(
                        "no value supplied for encryption_public_key".to_string()
                    ),
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                }
            }
        }
        impl WalletImportInitializationResponse {
            pub fn encryption_public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_public_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encryption_public_key: {}",
                        e
                    )
                });
                self
            }
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::HpkeEncryption>,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<WalletImportInitializationResponse>
            for super::WalletImportInitializationResponse
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletImportInitializationResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    encryption_public_key: value.encryption_public_key?,
                    encryption_type: value.encryption_type?,
                })
            }
        }
        impl ::std::convert::From<super::WalletImportInitializationResponse>
            for WalletImportInitializationResponse
        {
            fn from(value: super::WalletImportInitializationResponse) -> Self {
                Self {
                    encryption_public_key: Ok(value.encryption_public_key),
                    encryption_type: Ok(value.encryption_type),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletImportSubmissionRequest {
            additional_signers: ::std::result::Result<
                ::std::vec::Vec<super::WalletImportSubmissionRequestAdditionalSignersItem>,
                ::std::string::String,
            >,
            owner: ::std::result::Result<
                ::std::option::Option<super::WalletImportSubmissionRequestOwner>,
                ::std::string::String,
            >,
            owner_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            policy_ids: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            wallet: ::std::result::Result<
                super::WalletImportSubmissionRequestWallet,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for WalletImportSubmissionRequest {
            fn default() -> Self {
                Self {
                    additional_signers: Ok(Default::default()),
                    owner: Ok(Default::default()),
                    owner_id: Ok(Default::default()),
                    policy_ids: Ok(Default::default()),
                    wallet: Err("no value supplied for wallet".to_string()),
                }
            }
        }
        impl WalletImportSubmissionRequest {
            pub fn additional_signers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::WalletImportSubmissionRequestAdditionalSignersItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.additional_signers = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for additional_signers: {}",
                        e
                    )
                });
                self
            }
            pub fn owner<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::WalletImportSubmissionRequestOwner>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.owner = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner: {}", e));
                self
            }
            pub fn owner_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.owner_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for owner_id: {}", e));
                self
            }
            pub fn policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.policy_ids = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy_ids: {}", e));
                self
            }
            pub fn wallet<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletImportSubmissionRequestWallet>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for wallet: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WalletImportSubmissionRequest>
            for super::WalletImportSubmissionRequest
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletImportSubmissionRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    additional_signers: value.additional_signers?,
                    owner: value.owner?,
                    owner_id: value.owner_id?,
                    policy_ids: value.policy_ids?,
                    wallet: value.wallet?,
                })
            }
        }
        impl ::std::convert::From<super::WalletImportSubmissionRequest> for WalletImportSubmissionRequest {
            fn from(value: super::WalletImportSubmissionRequest) -> Self {
                Self {
                    additional_signers: Ok(value.additional_signers),
                    owner: Ok(value.owner),
                    owner_id: Ok(value.owner_id),
                    policy_ids: Ok(value.policy_ids),
                    wallet: Ok(value.wallet),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletImportSubmissionRequestAdditionalSignersItem {
            override_policy_ids: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            signer_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WalletImportSubmissionRequestAdditionalSignersItem {
            fn default() -> Self {
                Self {
                    override_policy_ids: Ok(Default::default()),
                    signer_id: Err("no value supplied for signer_id".to_string()),
                }
            }
        }
        impl WalletImportSubmissionRequestAdditionalSignersItem {
            pub fn override_policy_ids<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.override_policy_ids = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for override_policy_ids: {}",
                        e
                    )
                });
                self
            }
            pub fn signer_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.signer_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for signer_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WalletImportSubmissionRequestAdditionalSignersItem>
            for super::WalletImportSubmissionRequestAdditionalSignersItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletImportSubmissionRequestAdditionalSignersItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    override_policy_ids: value.override_policy_ids?,
                    signer_id: value.signer_id?,
                })
            }
        }
        impl ::std::convert::From<super::WalletImportSubmissionRequestAdditionalSignersItem>
            for WalletImportSubmissionRequestAdditionalSignersItem
        {
            fn from(value: super::WalletImportSubmissionRequestAdditionalSignersItem) -> Self {
                Self {
                    override_policy_ids: Ok(value.override_policy_ids),
                    signer_id: Ok(value.signer_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletImportSubmissionRequestOwner {
            subtype_0: ::std::result::Result<
                ::std::option::Option<super::WalletImportSubmissionRequestOwnerSubtype0>,
                ::std::string::String,
            >,
            subtype_1: ::std::result::Result<
                ::std::option::Option<super::WalletImportSubmissionRequestOwnerSubtype1>,
                ::std::string::String,
            >,
            subtype_2: ::std::result::Result<
                ::std::option::Option<::serde_json::Value>,
                ::std::string::String,
            >,
            subtype_3: ::std::result::Result<
                ::std::option::Option<::serde_json::Value>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for WalletImportSubmissionRequestOwner {
            fn default() -> Self {
                Self {
                    subtype_0: Ok(Default::default()),
                    subtype_1: Ok(Default::default()),
                    subtype_2: Ok(Default::default()),
                    subtype_3: Ok(Default::default()),
                }
            }
        }
        impl WalletImportSubmissionRequestOwner {
            pub fn subtype_0<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::WalletImportSubmissionRequestOwnerSubtype0>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_0 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
                self
            }
            pub fn subtype_1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<super::WalletImportSubmissionRequestOwnerSubtype1>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
                self
            }
            pub fn subtype_2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_2: {}", e));
                self
            }
            pub fn subtype_3<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
                T::Error: ::std::fmt::Display,
            {
                self.subtype_3 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subtype_3: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WalletImportSubmissionRequestOwner>
            for super::WalletImportSubmissionRequestOwner
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletImportSubmissionRequestOwner,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subtype_0: value.subtype_0?,
                    subtype_1: value.subtype_1?,
                    subtype_2: value.subtype_2?,
                    subtype_3: value.subtype_3?,
                })
            }
        }
        impl ::std::convert::From<super::WalletImportSubmissionRequestOwner>
            for WalletImportSubmissionRequestOwner
        {
            fn from(value: super::WalletImportSubmissionRequestOwner) -> Self {
                Self {
                    subtype_0: Ok(value.subtype_0),
                    subtype_1: Ok(value.subtype_1),
                    subtype_2: Ok(value.subtype_2),
                    subtype_3: Ok(value.subtype_3),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletImportSubmissionRequestOwnerSubtype0 {
            user_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WalletImportSubmissionRequestOwnerSubtype0 {
            fn default() -> Self {
                Self {
                    user_id: Err("no value supplied for user_id".to_string()),
                }
            }
        }
        impl WalletImportSubmissionRequestOwnerSubtype0 {
            pub fn user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WalletImportSubmissionRequestOwnerSubtype0>
            for super::WalletImportSubmissionRequestOwnerSubtype0
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletImportSubmissionRequestOwnerSubtype0,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    user_id: value.user_id?,
                })
            }
        }
        impl ::std::convert::From<super::WalletImportSubmissionRequestOwnerSubtype0>
            for WalletImportSubmissionRequestOwnerSubtype0
        {
            fn from(value: super::WalletImportSubmissionRequestOwnerSubtype0) -> Self {
                Self {
                    user_id: Ok(value.user_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletImportSubmissionRequestOwnerSubtype1 {
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WalletImportSubmissionRequestOwnerSubtype1 {
            fn default() -> Self {
                Self {
                    public_key: Err("no value supplied for public_key".to_string()),
                }
            }
        }
        impl WalletImportSubmissionRequestOwnerSubtype1 {
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WalletImportSubmissionRequestOwnerSubtype1>
            for super::WalletImportSubmissionRequestOwnerSubtype1
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletImportSubmissionRequestOwnerSubtype1,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    public_key: value.public_key?,
                })
            }
        }
        impl ::std::convert::From<super::WalletImportSubmissionRequestOwnerSubtype1>
            for WalletImportSubmissionRequestOwnerSubtype1
        {
            fn from(value: super::WalletImportSubmissionRequestOwnerSubtype1) -> Self {
                Self {
                    public_key: Ok(value.public_key),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletTransactionsResponse {
            next_cursor: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            transactions: ::std::result::Result<
                ::std::vec::Vec<super::WalletTransactionsResponseTransactionsItem>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for WalletTransactionsResponse {
            fn default() -> Self {
                Self {
                    next_cursor: Err("no value supplied for next_cursor".to_string()),
                    transactions: Err("no value supplied for transactions".to_string()),
                }
            }
        }
        impl WalletTransactionsResponse {
            pub fn next_cursor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_cursor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_cursor: {}", e));
                self
            }
            pub fn transactions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<super::WalletTransactionsResponseTransactionsItem>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.transactions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for transactions: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<WalletTransactionsResponse> for super::WalletTransactionsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletTransactionsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    next_cursor: value.next_cursor?,
                    transactions: value.transactions?,
                })
            }
        }
        impl ::std::convert::From<super::WalletTransactionsResponse> for WalletTransactionsResponse {
            fn from(value: super::WalletTransactionsResponse) -> Self {
                Self {
                    next_cursor: Ok(value.next_cursor),
                    transactions: Ok(value.transactions),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WalletTransactionsResponseTransactionsItem {
            caip2: ::std::result::Result<::std::string::String, ::std::string::String>,
            created_at: ::std::result::Result<f64, ::std::string::String>,
            details: ::std::result::Result<
                super::WalletTransactionsResponseTransactionsItemDetails,
                ::std::string::String,
            >,
            privy_transaction_id:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            sponsored: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
            status: ::std::result::Result<
                super::WalletTransactionsResponseTransactionsItemStatus,
                ::std::string::String,
            >,
            transaction_hash: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            wallet_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for WalletTransactionsResponseTransactionsItem {
            fn default() -> Self {
                Self {
                    caip2: Err("no value supplied for caip2".to_string()),
                    created_at: Err("no value supplied for created_at".to_string()),
                    details: Err("no value supplied for details".to_string()),
                    privy_transaction_id: Err(
                        "no value supplied for privy_transaction_id".to_string()
                    ),
                    sponsored: Ok(Default::default()),
                    status: Err("no value supplied for status".to_string()),
                    transaction_hash: Err("no value supplied for transaction_hash".to_string()),
                    wallet_id: Err("no value supplied for wallet_id".to_string()),
                }
            }
        }
        impl WalletTransactionsResponseTransactionsItem {
            pub fn caip2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.caip2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for caip2: {}", e));
                self
            }
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn details<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::WalletTransactionsResponseTransactionsItemDetails,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.details = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for details: {}", e));
                self
            }
            pub fn privy_transaction_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.privy_transaction_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for privy_transaction_id: {}",
                        e
                    )
                });
                self
            }
            pub fn sponsored<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<bool>>,
                T::Error: ::std::fmt::Display,
            {
                self.sponsored = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sponsored: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WalletTransactionsResponseTransactionsItemStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn transaction_hash<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.transaction_hash = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for transaction_hash: {}",
                        e
                    )
                });
                self
            }
            pub fn wallet_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.wallet_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for wallet_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<WalletTransactionsResponseTransactionsItem>
            for super::WalletTransactionsResponseTransactionsItem
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WalletTransactionsResponseTransactionsItem,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    caip2: value.caip2?,
                    created_at: value.created_at?,
                    details: value.details?,
                    privy_transaction_id: value.privy_transaction_id?,
                    sponsored: value.sponsored?,
                    status: value.status?,
                    transaction_hash: value.transaction_hash?,
                    wallet_id: value.wallet_id?,
                })
            }
        }
        impl ::std::convert::From<super::WalletTransactionsResponseTransactionsItem>
            for WalletTransactionsResponseTransactionsItem
        {
            fn from(value: super::WalletTransactionsResponseTransactionsItem) -> Self {
                Self {
                    caip2: Ok(value.caip2),
                    created_at: Ok(value.created_at),
                    details: Ok(value.details),
                    privy_transaction_id: Ok(value.privy_transaction_id),
                    sponsored: Ok(value.sponsored),
                    status: Ok(value.status),
                    transaction_hash: Ok(value.transaction_hash),
                    wallet_id: Ok(value.wallet_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct WithEncryptionEncryptedAuthorizationKey {
            ciphertext: ::std::result::Result<::std::string::String, ::std::string::String>,
            encapsulated_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            encryption_type: ::std::result::Result<
                super::WithEncryptionEncryptedAuthorizationKeyEncryptionType,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for WithEncryptionEncryptedAuthorizationKey {
            fn default() -> Self {
                Self {
                    ciphertext: Err("no value supplied for ciphertext".to_string()),
                    encapsulated_key: Err("no value supplied for encapsulated_key".to_string()),
                    encryption_type: Err("no value supplied for encryption_type".to_string()),
                }
            }
        }
        impl WithEncryptionEncryptedAuthorizationKey {
            pub fn ciphertext<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.ciphertext = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ciphertext: {}", e));
                self
            }
            pub fn encapsulated_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.encapsulated_key = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for encapsulated_key: {}",
                        e
                    )
                });
                self
            }
            pub fn encryption_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    super::WithEncryptionEncryptedAuthorizationKeyEncryptionType,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.encryption_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for encryption_type: {}", e)
                });
                self
            }
        }
        impl ::std::convert::TryFrom<WithEncryptionEncryptedAuthorizationKey>
            for super::WithEncryptionEncryptedAuthorizationKey
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WithEncryptionEncryptedAuthorizationKey,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ciphertext: value.ciphertext?,
                    encapsulated_key: value.encapsulated_key?,
                    encryption_type: value.encryption_type?,
                })
            }
        }
        impl ::std::convert::From<super::WithEncryptionEncryptedAuthorizationKey>
            for WithEncryptionEncryptedAuthorizationKey
        {
            fn from(value: super::WithEncryptionEncryptedAuthorizationKey) -> Self {
                Self {
                    ciphertext: Ok(value.ciphertext),
                    encapsulated_key: Ok(value.encapsulated_key),
                    encryption_type: Ok(value.encryption_type),
                }
            }
        }
    }
}
#[derive(Clone, Debug)]
#[doc = "Client for Privy API\n\nVersion: 0.0.1"]
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    #[doc = r" Create a new client."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    #[doc = r" Construct a new client with an existing `reqwest::Client`,"]
    #[doc = r" allowing more control over its configuration."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}
impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "0.0.1"
    }
    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }
    fn client(&self) -> &reqwest::Client {
        &self.client
    }
    fn inner(&self) -> &() {
        &()
    }
}
impl ClientHooks<()> for &Client {}
impl Client {
    #[doc = "Gets Users\n\nGet all users in your app.\n\nSends a `GET` request to `/v1/users`\n\n```ignore\nlet response = client.get_users()\n    .cursor(cursor)\n    .limit(limit)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn get_users(&self) -> builder::GetUsers<'_> {
        builder::GetUsers::new(self)
    }
    #[doc = "Create User\n\nCreate a new user with linked accounts. Optionally pre-generate embedded wallets for the user.\n\nSends a `POST` request to `/v1/users`\n\n```ignore\nlet response = client.create_user()\n    .privy_app_id(privy_app_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn create_user(&self) -> builder::CreateUser<'_> {
        builder::CreateUser::new(self)
    }
    #[doc = "Get User\n\nGet a user by user ID.\n\nSends a `GET` request to `/v1/users/{user_id}`\n\n```ignore\nlet response = client.get_user()\n    .user_id(user_id)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn get_user(&self) -> builder::GetUser<'_> {
        builder::GetUser::new(self)
    }
    #[doc = "Delete User\n\nDelete a user by user ID.\n\nSends a `DELETE` request to `/v1/users/{user_id}`\n\n```ignore\nlet response = client.delete_user()\n    .user_id(user_id)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn delete_user(&self) -> builder::DeleteUser<'_> {
        builder::DeleteUser::new(self)
    }
    #[doc = "Search Users by Search Term\n\nSearch users by search term, emails, phone numbers, or wallet addresses.\n\nSends a `POST` request to `/v1/users/search`\n\n```ignore\nlet response = client.search_users()\n    .privy_app_id(privy_app_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn search_users(&self) -> builder::SearchUsers<'_> {
        builder::SearchUsers::new(self)
    }
    #[doc = "Create Embedded Wallet\n\nCreates an embedded wallet for an existing user.\n\nSends a `POST` request to `/v1/users/{user_id}/wallets`\n\n```ignore\nlet response = client.create_user_wallet()\n    .user_id(user_id)\n    .privy_app_id(privy_app_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn create_user_wallet(&self) -> builder::CreateUserWallet<'_> {
        builder::CreateUserWallet::new(self)
    }
    #[doc = "Get all wallets\n\nGet all wallets in your app.\n\nSends a `GET` request to `/v1/wallets`\n\n```ignore\nlet response = client.get_wallets()\n    .chain_type(chain_type)\n    .cursor(cursor)\n    .limit(limit)\n    .user_id(user_id)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn get_wallets(&self) -> builder::GetWallets<'_> {
        builder::GetWallets::new(self)
    }
    #[doc = "Create wallet\n\nCreate a new wallet.\n\nSends a `POST` request to `/v1/wallets`\n\n```ignore\nlet response = client.create_wallet()\n    .privy_app_id(privy_app_id)\n    .privy_idempotency_key(privy_idempotency_key)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn create_wallet(&self) -> builder::CreateWallet<'_> {
        builder::CreateWallet::new(self)
    }
    #[doc = "Create a signature or transaction\n\nSign a message or transaction with a wallet by wallet ID.\n\nSends a `POST` request to `/v1/wallets/{wallet_id}/rpc`\n\n```ignore\nlet response = client.wallet_rpc()\n    .wallet_id(wallet_id)\n    .privy_app_id(privy_app_id)\n    .privy_authorization_signature(privy_authorization_signature)\n    .privy_idempotency_key(privy_idempotency_key)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn wallet_rpc(&self) -> builder::WalletRpc<'_> {
        builder::WalletRpc::new(self)
    }
    #[doc = "Get wallet\n\nGet a wallet by wallet ID.\n\nSends a `GET` request to `/v1/wallets/{wallet_id}`\n\n```ignore\nlet response = client.get_wallet()\n    .wallet_id(wallet_id)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn get_wallet(&self) -> builder::GetWallet<'_> {
        builder::GetWallet::new(self)
    }
    #[doc = "Update wallet\n\nUpdate a wallet's policies or authorization key configuration.\n\nSends a `PATCH` request to `/v1/wallets/{wallet_id}`\n\n```ignore\nlet response = client.update_wallet()\n    .wallet_id(wallet_id)\n    .privy_app_id(privy_app_id)\n    .privy_authorization_signature(privy_authorization_signature)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn update_wallet(&self) -> builder::UpdateWallet<'_> {
        builder::UpdateWallet::new(self)
    }
    #[doc = "Raw sign\n\nSign a message with a wallet by wallet ID.\n\nSends a `POST` request to `/v1/wallets/{wallet_id}/raw_sign`\n\n```ignore\nlet response = client.raw_sign()\n    .wallet_id(wallet_id)\n    .privy_app_id(privy_app_id)\n    .privy_authorization_signature(privy_authorization_signature)\n    .privy_idempotency_key(privy_idempotency_key)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn raw_sign(&self) -> builder::RawSign<'_> {
        builder::RawSign::new(self)
    }
    #[doc = "Get balance\n\nGet the balance of a wallet by wallet ID.\n\nSends a `GET` request to `/v1/wallets/{wallet_id}/balance`\n\n```ignore\nlet response = client.get_wallet_balance()\n    .wallet_id(wallet_id)\n    .asset(asset)\n    .chain(chain)\n    .include_currency(include_currency)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn get_wallet_balance(&self) -> builder::GetWalletBalance<'_> {
        builder::GetWalletBalance::new(self)
    }
    #[doc = "Get transactions\n\nGet incoming and outgoing transactions of a wallet by wallet ID.\n\nSends a `GET` request to `/v1/wallets/{wallet_id}/transactions`\n\n```ignore\nlet response = client.wallet_transactions()\n    .wallet_id(wallet_id)\n    .asset(asset)\n    .chain(chain)\n    .cursor(cursor)\n    .limit(limit)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn wallet_transactions(&self) -> builder::WalletTransactions<'_> {
        builder::WalletTransactions::new(self)
    }
    #[doc = "Obtain a session key to enable wallet access\n\nObtain a session key to enable wallet access.\n\nSends a `POST` request to `/v1/wallets/authenticate`\n\n```ignore\nlet response = client.authenticate()\n    .privy_app_id(privy_app_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn authenticate(&self) -> builder::Authenticate<'_> {
        builder::Authenticate::new(self)
    }
    #[doc = "Initialize import\n\nInitialize a wallet import. Complete by submitting the import.\n\nSends a `POST` request to `/v1/wallets/import/init`\n\n```ignore\nlet response = client.wallet_import_init()\n    .privy_app_id(privy_app_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn wallet_import_init(&self) -> builder::WalletImportInit<'_> {
        builder::WalletImportInit::new(self)
    }
    #[doc = "Submit import\n\nSubmit a wallet import request.\n\nSends a `POST` request to `/v1/wallets/import/submit`\n\n```ignore\nlet response = client.wallet_import_submit()\n    .privy_app_id(privy_app_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn wallet_import_submit(&self) -> builder::WalletImportSubmit<'_> {
        builder::WalletImportSubmit::new(self)
    }
    #[doc = "Export wallet\n\nExport a wallet's private key\n\nSends a `POST` request to `/v1/wallets/{wallet_id}/export`\n\n```ignore\nlet response = client.wallet_export()\n    .wallet_id(wallet_id)\n    .privy_app_id(privy_app_id)\n    .privy_authorization_signature(privy_authorization_signature)\n    .body(body)\n    .send()\n    .await;\n```"]
    pub fn wallet_export(&self) -> builder::WalletExport<'_> {
        builder::WalletExport::new(self)
    }
    #[doc = "Get Transaction\n\nGet a transaction by transaction ID.\n\nSends a `GET` request to `/v1/transactions/{transaction_id}`\n\n```ignore\nlet response = client.get_transaction()\n    .transaction_id(transaction_id)\n    .privy_app_id(privy_app_id)\n    .send()\n    .await;\n```"]
    pub fn get_transaction(&self) -> builder::GetTransaction<'_> {
        builder::GetTransaction::new(self)
    }
}
#[doc = r" Types for composing operation parameters."]
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, ClientHooks, ClientInfo, Error, OperationInfo, RequestBuilderExt,
        ResponseValue,
    };
    #[doc = "Builder for [`Client::get_users`]\n\n[`Client::get_users`]: super::Client::get_users"]
    #[derive(Debug, Clone)]
    pub struct GetUsers<'a> {
        client: &'a super::Client,
        cursor: Result<Option<types::GetUsersCursor>, String>,
        limit: Result<Option<f64>, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> GetUsers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                cursor: Ok(None),
                limit: Ok(None),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn cursor<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetUsersCursor>,
        {
            self.cursor = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `GetUsersCursor` for cursor failed".to_string());
            self
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<f64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `f64` for limit failed".to_string());
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/v1/users`"]
        pub async fn send(self) -> Result<ResponseValue<types::GetUsersResponse>, Error<()>> {
            let Self {
                client,
                cursor,
                limit,
                privy_app_id,
            } = self;
            let cursor = cursor.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("cursor", &cursor))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_users",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::create_user`]\n\n[`Client::create_user`]: super::Client::create_user"]
    #[derive(Debug, Clone)]
    pub struct CreateUser<'a> {
        client: &'a super::Client,
        privy_app_id: Result<::std::string::String, String>,
        body: Result<types::builder::CreateUserBody, String>,
    }
    impl<'a> CreateUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateUserBody>,
            <V as std::convert::TryInto<types::CreateUserBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateUserBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::CreateUserBody) -> types::builder::CreateUserBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/v1/users`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<()>> {
            let Self {
                client,
                privy_app_id,
                body,
            } = self;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateUserBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::get_user`]\n\n[`Client::get_user`]: super::Client::get_user"]
    #[derive(Debug, Clone)]
    pub struct GetUser<'a> {
        client: &'a super::Client,
        user_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> GetUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_id: Err("user_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.user_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for user_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/v1/users/{user_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<()>> {
            let Self {
                client,
                user_id,
                privy_app_id,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/users/{}",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::delete_user`]\n\n[`Client::delete_user`]: super::Client::delete_user"]
    #[derive(Debug, Clone)]
    pub struct DeleteUser<'a> {
        client: &'a super::Client,
        user_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> DeleteUser<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_id: Err("user_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.user_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for user_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `DELETE` request to `/v1/users/{user_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<ByteStream>> {
            let Self {
                client,
                user_id,
                privy_app_id,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/users/{}",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client.client.delete(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "delete_user",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(ResponseValue::stream(response))),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::search_users`]\n\n[`Client::search_users`]: super::Client::search_users"]
    #[derive(Debug, Clone)]
    pub struct SearchUsers<'a> {
        client: &'a super::Client,
        privy_app_id: Result<::std::string::String, String>,
        body: Result<types::SearchUsersBody, String>,
    }
    impl<'a> SearchUsers<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SearchUsersBody>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SearchUsersBody` for body failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/v1/users/search`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<()>> {
            let Self {
                client,
                privy_app_id,
                body,
            } = self;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/users/search", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "search_users",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::create_user_wallet`]\n\n[`Client::create_user_wallet`]: super::Client::create_user_wallet"]
    #[derive(Debug, Clone)]
    pub struct CreateUserWallet<'a> {
        client: &'a super::Client,
        user_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
        body: Result<types::builder::CreateUserWalletBody, String>,
    }
    impl<'a> CreateUserWallet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_id: Err("user_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.user_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for user_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateUserWalletBody>,
            <V as std::convert::TryInto<types::CreateUserWalletBody>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateUserWalletBody` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateUserWalletBody,
            ) -> types::builder::CreateUserWalletBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/v1/users/{user_id}/wallets`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<()>> {
            let Self {
                client,
                user_id,
                privy_app_id,
                body,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateUserWalletBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/users/{}/wallets",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_user_wallet",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::get_wallets`]\n\n[`Client::get_wallets`]: super::Client::get_wallets"]
    #[derive(Debug, Clone)]
    pub struct GetWallets<'a> {
        client: &'a super::Client,
        chain_type: Result<Option<types::GetWalletsChainType>, String>,
        cursor: Result<Option<types::GetWalletsCursor>, String>,
        limit: Result<Option<f64>, String>,
        user_id: Result<Option<::std::string::String>, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> GetWallets<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                chain_type: Ok(None),
                cursor: Ok(None),
                limit: Ok(None),
                user_id: Ok(None),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn chain_type<V>(self, _value: V) -> Self
        where
            V: std::convert::TryInto<types::GetWalletsChainType>,
        {
            todo!("optional body params not implemented")
        }
        pub fn cursor<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetWalletsCursor>,
        {
            self.cursor = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `GetWalletsCursor` for cursor failed".to_string());
            self
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<f64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `f64` for limit failed".to_string());
            self
        }
        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.user_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for user_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/v1/wallets`"]
        pub async fn send(self) -> Result<ResponseValue<types::GetWalletsResponse>, Error<()>> {
            let Self {
                client,
                chain_type,
                cursor,
                limit,
                user_id,
                privy_app_id,
            } = self;
            let chain_type = chain_type.map_err(Error::InvalidRequest)?;
            let cursor = cursor.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/wallets", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "chain_type",
                    &chain_type,
                ))
                .query(&progenitor_client::QueryParam::new("cursor", &cursor))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new("user_id", &user_id))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_wallets",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::create_wallet`]\n\n[`Client::create_wallet`]: super::Client::create_wallet"]
    #[derive(Debug, Clone)]
    pub struct CreateWallet<'a> {
        client: &'a super::Client,
        privy_app_id: Result<::std::string::String, String>,
        privy_idempotency_key: Result<Option<::std::string::String>, String>,
        body: Result<types::builder::CreateWalletBody, String>,
    }
    impl<'a> CreateWallet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                privy_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn privy_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateWalletBody>,
            <V as std::convert::TryInto<types::CreateWalletBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateWalletBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CreateWalletBody,
            ) -> types::builder::CreateWalletBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/v1/wallets`"]
        pub async fn send(self) -> Result<ResponseValue<types::Wallet>, Error<()>> {
            let Self {
                client,
                privy_app_id,
                privy_idempotency_key,
                body,
            } = self;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let privy_idempotency_key = privy_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateWalletBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/wallets", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            if let Some(value) = privy_idempotency_key {
                header_map.append("privy-idempotency-key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_wallet",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::wallet_rpc`]\n\n[`Client::wallet_rpc`]: super::Client::wallet_rpc"]
    #[derive(Debug, Clone)]
    pub struct WalletRpc<'a> {
        client: &'a super::Client,
        wallet_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
        privy_authorization_signature: Result<Option<::std::string::String>, String>,
        privy_idempotency_key: Result<Option<::std::string::String>, String>,
        body: Result<types::WalletRpcBody, String>,
    }
    impl<'a> WalletRpc<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                wallet_id: Err("wallet_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                privy_authorization_signature: Ok(None),
                privy_idempotency_key: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn wallet_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.wallet_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for wallet_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn privy_authorization_signature<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self . privy_authorization_signature = value . try_into () . map (Some) . map_err (| _ | "conversion to `:: std :: string :: String` for privy_authorization_signature failed" . to_string ()) ;
            self
        }
        pub fn privy_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WalletRpcBody>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `WalletRpcBody` for body failed".to_string());
            self
        }
        #[doc = "Sends a `POST` request to `/v1/wallets/{wallet_id}/rpc`"]
        pub async fn send(self) -> Result<ResponseValue<types::WalletRpcResponse>, Error<()>> {
            let Self {
                client,
                wallet_id,
                privy_app_id,
                privy_authorization_signature,
                privy_idempotency_key,
                body,
            } = self;
            let wallet_id = wallet_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let privy_authorization_signature =
                privy_authorization_signature.map_err(Error::InvalidRequest)?;
            let privy_idempotency_key = privy_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/wallets/{}/rpc",
                client.baseurl,
                encode_path(&wallet_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(4usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            if let Some(value) = privy_authorization_signature {
                header_map.append(
                    "privy-authorization-signature",
                    value.to_string().try_into()?,
                );
            }
            if let Some(value) = privy_idempotency_key {
                header_map.append("privy-idempotency-key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "wallet_rpc",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::get_wallet`]\n\n[`Client::get_wallet`]: super::Client::get_wallet"]
    #[derive(Debug, Clone)]
    pub struct GetWallet<'a> {
        client: &'a super::Client,
        wallet_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> GetWallet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                wallet_id: Err("wallet_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn wallet_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.wallet_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for wallet_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/v1/wallets/{wallet_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Wallet>, Error<()>> {
            let Self {
                client,
                wallet_id,
                privy_app_id,
            } = self;
            let wallet_id = wallet_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/wallets/{}",
                client.baseurl,
                encode_path(&wallet_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_wallet",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::update_wallet`]\n\n[`Client::update_wallet`]: super::Client::update_wallet"]
    #[derive(Debug, Clone)]
    pub struct UpdateWallet<'a> {
        client: &'a super::Client,
        wallet_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
        privy_authorization_signature: Result<Option<::std::string::String>, String>,
        body: Result<types::builder::UpdateWalletBody, String>,
    }
    impl<'a> UpdateWallet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                wallet_id: Err("wallet_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                privy_authorization_signature: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn wallet_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.wallet_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for wallet_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn privy_authorization_signature<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self . privy_authorization_signature = value . try_into () . map (Some) . map_err (| _ | "conversion to `:: std :: string :: String` for privy_authorization_signature failed" . to_string ()) ;
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateWalletBody>,
            <V as std::convert::TryInto<types::UpdateWalletBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdateWalletBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UpdateWalletBody,
            ) -> types::builder::UpdateWalletBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `PATCH` request to `/v1/wallets/{wallet_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Wallet>, Error<()>> {
            let Self {
                client,
                wallet_id,
                privy_app_id,
                privy_authorization_signature,
                body,
            } = self;
            let wallet_id = wallet_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let privy_authorization_signature =
                privy_authorization_signature.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateWalletBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/wallets/{}",
                client.baseurl,
                encode_path(&wallet_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            if let Some(value) = privy_authorization_signature {
                header_map.append(
                    "privy-authorization-signature",
                    value.to_string().try_into()?,
                );
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .patch(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_wallet",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::raw_sign`]\n\n[`Client::raw_sign`]: super::Client::raw_sign"]
    #[derive(Debug, Clone)]
    pub struct RawSign<'a> {
        client: &'a super::Client,
        wallet_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
        privy_authorization_signature: Result<Option<::std::string::String>, String>,
        privy_idempotency_key: Result<Option<::std::string::String>, String>,
        body: Result<types::builder::RawSign, String>,
    }
    impl<'a> RawSign<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                wallet_id: Err("wallet_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                privy_authorization_signature: Ok(None),
                privy_idempotency_key: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn wallet_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.wallet_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for wallet_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn privy_authorization_signature<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self . privy_authorization_signature = value . try_into () . map (Some) . map_err (| _ | "conversion to `:: std :: string :: String` for privy_authorization_signature failed" . to_string ()) ;
            self
        }
        pub fn privy_idempotency_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_idempotency_key = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_idempotency_key failed"
                    .to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RawSign>,
            <V as std::convert::TryInto<types::RawSign>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `RawSign` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::RawSign) -> types::builder::RawSign,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/v1/wallets/{wallet_id}/raw_sign`"]
        pub async fn send(self) -> Result<ResponseValue<types::RawSignResponse>, Error<()>> {
            let Self {
                client,
                wallet_id,
                privy_app_id,
                privy_authorization_signature,
                privy_idempotency_key,
                body,
            } = self;
            let wallet_id = wallet_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let privy_authorization_signature =
                privy_authorization_signature.map_err(Error::InvalidRequest)?;
            let privy_idempotency_key = privy_idempotency_key.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::RawSign::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/wallets/{}/raw_sign",
                client.baseurl,
                encode_path(&wallet_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(4usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            if let Some(value) = privy_authorization_signature {
                header_map.append(
                    "privy-authorization-signature",
                    value.to_string().try_into()?,
                );
            }
            if let Some(value) = privy_idempotency_key {
                header_map.append("privy-idempotency-key", value.to_string().try_into()?);
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "raw_sign",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::get_wallet_balance`]\n\n[`Client::get_wallet_balance`]: super::Client::get_wallet_balance"]
    #[derive(Debug, Clone)]
    pub struct GetWalletBalance<'a> {
        client: &'a super::Client,
        wallet_id: Result<::std::string::String, String>,
        asset: Result<types::GetWalletBalanceAsset, String>,
        chain: Result<types::GetWalletBalanceChain, String>,
        include_currency: Result<Option<types::GetWalletBalanceIncludeCurrency>, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> GetWalletBalance<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                wallet_id: Err("wallet_id was not initialized".to_string()),
                asset: Err("asset was not initialized".to_string()),
                chain: Err("chain was not initialized".to_string()),
                include_currency: Ok(None),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn wallet_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.wallet_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for wallet_id failed".to_string()
            });
            self
        }
        pub fn asset<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetWalletBalanceAsset>,
        {
            self.asset = value
                .try_into()
                .map_err(|_| "conversion to `GetWalletBalanceAsset` for asset failed".to_string());
            self
        }
        pub fn chain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetWalletBalanceChain>,
        {
            self.chain = value
                .try_into()
                .map_err(|_| "conversion to `GetWalletBalanceChain` for chain failed".to_string());
            self
        }
        pub fn include_currency<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GetWalletBalanceIncludeCurrency>,
        {
            self.include_currency = value.try_into().map(Some).map_err(|_| {
                "conversion to `GetWalletBalanceIncludeCurrency` for include_currency failed"
                    .to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/v1/wallets/{wallet_id}/balance`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GetWalletBalanceResponse>, Error<()>> {
            let Self {
                client,
                wallet_id,
                asset,
                chain,
                include_currency,
                privy_app_id,
            } = self;
            let wallet_id = wallet_id.map_err(Error::InvalidRequest)?;
            let asset = asset.map_err(Error::InvalidRequest)?;
            let chain = chain.map_err(Error::InvalidRequest)?;
            let include_currency = include_currency.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/wallets/{}/balance",
                client.baseurl,
                encode_path(&wallet_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("asset", &asset))
                .query(&progenitor_client::QueryParam::new("chain", &chain))
                .query(&progenitor_client::QueryParam::new(
                    "include_currency",
                    &include_currency,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_wallet_balance",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::wallet_transactions`]\n\n[`Client::wallet_transactions`]: super::Client::wallet_transactions"]
    #[derive(Debug, Clone)]
    pub struct WalletTransactions<'a> {
        client: &'a super::Client,
        wallet_id: Result<::std::string::String, String>,
        asset: Result<types::WalletTransactionsAsset, String>,
        chain: Result<types::WalletTransactionsChain, String>,
        cursor: Result<Option<types::WalletTransactionsCursor>, String>,
        limit: Result<Option<f64>, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> WalletTransactions<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                wallet_id: Err("wallet_id was not initialized".to_string()),
                asset: Err("asset was not initialized".to_string()),
                chain: Err("chain was not initialized".to_string()),
                cursor: Ok(None),
                limit: Ok(None),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn wallet_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.wallet_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for wallet_id failed".to_string()
            });
            self
        }
        pub fn asset<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WalletTransactionsAsset>,
        {
            self.asset = value.try_into().map_err(|_| {
                "conversion to `WalletTransactionsAsset` for asset failed".to_string()
            });
            self
        }
        pub fn chain<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WalletTransactionsChain>,
        {
            self.chain = value.try_into().map_err(|_| {
                "conversion to `WalletTransactionsChain` for chain failed".to_string()
            });
            self
        }
        pub fn cursor<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WalletTransactionsCursor>,
        {
            self.cursor = value.try_into().map(Some).map_err(|_| {
                "conversion to `WalletTransactionsCursor` for cursor failed".to_string()
            });
            self
        }
        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<f64>,
        {
            self.limit = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `f64` for limit failed".to_string());
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/v1/wallets/{wallet_id}/transactions`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WalletTransactionsResponse>, Error<()>> {
            let Self {
                client,
                wallet_id,
                asset,
                chain,
                cursor,
                limit,
                privy_app_id,
            } = self;
            let wallet_id = wallet_id.map_err(Error::InvalidRequest)?;
            let asset = asset.map_err(Error::InvalidRequest)?;
            let chain = chain.map_err(Error::InvalidRequest)?;
            let cursor = cursor.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/wallets/{}/transactions",
                client.baseurl,
                encode_path(&wallet_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("asset", &asset))
                .query(&progenitor_client::QueryParam::new("chain", &chain))
                .query(&progenitor_client::QueryParam::new("cursor", &cursor))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "wallet_transactions",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::authenticate`]\n\n[`Client::authenticate`]: super::Client::authenticate"]
    #[derive(Debug, Clone)]
    pub struct Authenticate<'a> {
        client: &'a super::Client,
        privy_app_id: Result<::std::string::String, String>,
        body: Result<types::builder::AuthenticateBody, String>,
    }
    impl<'a> Authenticate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AuthenticateBody>,
            <V as std::convert::TryInto<types::AuthenticateBody>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AuthenticateBody` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::AuthenticateBody,
            ) -> types::builder::AuthenticateBody,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/v1/wallets/authenticate`"]
        pub async fn send(self) -> Result<ResponseValue<types::AuthenticateResponse>, Error<()>> {
            let Self {
                client,
                privy_app_id,
                body,
            } = self;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AuthenticateBody::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/wallets/authenticate", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "authenticate",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::wallet_import_init`]\n\n[`Client::wallet_import_init`]: super::Client::wallet_import_init"]
    #[derive(Debug, Clone)]
    pub struct WalletImportInit<'a> {
        client: &'a super::Client,
        privy_app_id: Result<::std::string::String, String>,
        body: Result<types::WalletImportInitializationRequest, String>,
    }
    impl<'a> WalletImportInit<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WalletImportInitializationRequest>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `WalletImportInitializationRequest` for body failed".to_string()
            });
            self
        }
        #[doc = "Sends a `POST` request to `/v1/wallets/import/init`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WalletImportInitializationResponse>, Error<()>> {
            let Self {
                client,
                privy_app_id,
                body,
            } = self;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/wallets/import/init", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "wallet_import_init",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::wallet_import_submit`]\n\n[`Client::wallet_import_submit`]: super::Client::wallet_import_submit"]
    #[derive(Debug, Clone)]
    pub struct WalletImportSubmit<'a> {
        client: &'a super::Client,
        privy_app_id: Result<::std::string::String, String>,
        body: Result<types::builder::WalletImportSubmissionRequest, String>,
    }
    impl<'a> WalletImportSubmit<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WalletImportSubmissionRequest>,
            <V as std::convert::TryInto<types::WalletImportSubmissionRequest>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `WalletImportSubmissionRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WalletImportSubmissionRequest,
            ) -> types::builder::WalletImportSubmissionRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/v1/wallets/import/submit`"]
        pub async fn send(self) -> Result<ResponseValue<types::Wallet>, Error<()>> {
            let Self {
                client,
                privy_app_id,
                body,
            } = self;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::WalletImportSubmissionRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/wallets/import/submit", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "wallet_import_submit",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::wallet_export`]\n\n[`Client::wallet_export`]: super::Client::wallet_export"]
    #[derive(Debug, Clone)]
    pub struct WalletExport<'a> {
        client: &'a super::Client,
        wallet_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
        privy_authorization_signature: Result<Option<::std::string::String>, String>,
        body: Result<types::builder::WalletExportRequest, String>,
    }
    impl<'a> WalletExport<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                wallet_id: Err("wallet_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
                privy_authorization_signature: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn wallet_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.wallet_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for wallet_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        pub fn privy_authorization_signature<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self . privy_authorization_signature = value . try_into () . map (Some) . map_err (| _ | "conversion to `:: std :: string :: String` for privy_authorization_signature failed" . to_string ()) ;
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WalletExportRequest>,
            <V as std::convert::TryInto<types::WalletExportRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `WalletExportRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WalletExportRequest,
            ) -> types::builder::WalletExportRequest,
        {
            self.body = self.body.map(f);
            self
        }
        #[doc = "Sends a `POST` request to `/v1/wallets/{wallet_id}/export`"]
        pub async fn send(self) -> Result<ResponseValue<types::WalletExportResponse>, Error<()>> {
            let Self {
                client,
                wallet_id,
                privy_app_id,
                privy_authorization_signature,
                body,
            } = self;
            let wallet_id = wallet_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let privy_authorization_signature =
                privy_authorization_signature.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::WalletExportRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/wallets/{}/export",
                client.baseurl,
                encode_path(&wallet_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            if let Some(value) = privy_authorization_signature {
                header_map.append(
                    "privy-authorization-signature",
                    value.to_string().try_into()?,
                );
            }
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "wallet_export",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    #[doc = "Builder for [`Client::get_transaction`]\n\n[`Client::get_transaction`]: super::Client::get_transaction"]
    #[derive(Debug, Clone)]
    pub struct GetTransaction<'a> {
        client: &'a super::Client,
        transaction_id: Result<::std::string::String, String>,
        privy_app_id: Result<::std::string::String, String>,
    }
    impl<'a> GetTransaction<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                transaction_id: Err("transaction_id was not initialized".to_string()),
                privy_app_id: Err("privy_app_id was not initialized".to_string()),
            }
        }
        pub fn transaction_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.transaction_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for transaction_id failed".to_string()
            });
            self
        }
        pub fn privy_app_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.privy_app_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for privy_app_id failed".to_string()
            });
            self
        }
        #[doc = "Sends a `GET` request to `/v1/transactions/{transaction_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Transaction>, Error<()>> {
            let Self {
                client,
                transaction_id,
                privy_app_id,
            } = self;
            let transaction_id = transaction_id.map_err(Error::InvalidRequest)?;
            let privy_app_id = privy_app_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/transactions/{}",
                client.baseurl,
                encode_path(&transaction_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            header_map.append("privy-app-id", privy_app_id.to_string().try_into()?);
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_transaction",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}
#[doc = r" Items consumers will typically use such as the Client."]
pub mod prelude {
    pub use self::super::Client;
}
