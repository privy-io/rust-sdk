#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///The response body for initiating a passkey authentication ceremony.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyAuthenticationInitResponseBody",
    ///  "description": "The response body for initiating a passkey
    /// authentication ceremony.",
    ///  "type": "object",
    ///  "required": [
    ///    "options"
    ///  ],
    ///  "properties": {
    ///    "options": {
    ///      "$ref":
    /// "#/components/schemas/PasskeyAuthenticatorAuthenticationOptions"
    ///    },
    ///    "relying_party": {
    ///      "$ref": "#/components/schemas/PasskeyRelyingPartyUrl"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyAuthenticationInitResponseBody {
        pub options: PasskeyAuthenticatorAuthenticationOptions,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub relying_party: ::std::option::Option<PasskeyRelyingPartyUrl>,
    }

    impl ::std::convert::From<&AuthPasskeyAuthenticationInitResponseBody>
        for AuthPasskeyAuthenticationInitResponseBody
    {
        fn from(value: &AuthPasskeyAuthenticationInitResponseBody) -> Self {
            value.clone()
        }
    }

    ///The authenticator response for the authentication ceremony.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyAuthenticationRequestBody",
    ///  "description": "The authenticator response for the authentication
    /// ceremony.",
    ///  "type": "object",
    ///  "required": [
    ///    "authenticator_response",
    ///    "challenge"
    ///  ],
    ///  "properties": {
    ///    "authenticator_response": {
    ///      "$ref":
    /// "#/components/schemas/PasskeyAuthenticatorAuthenticationCredential"
    ///    },
    ///    "challenge": {
    ///      "type": "string"
    ///    },
    ///    "relying_party": {
    ///      "type": "string",
    ///      "format": "uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyAuthenticationRequestBody {
        pub authenticator_response: PasskeyAuthenticatorAuthenticationCredential,
        pub challenge: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub relying_party: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AuthPasskeyAuthenticationRequestBody>
        for AuthPasskeyAuthenticationRequestBody
    {
        fn from(value: &AuthPasskeyAuthenticationRequestBody) -> Self {
            value.clone()
        }
    }

    ///The request body for initiating a passkey ceremony.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyInitRequestBody",
    ///  "description": "The request body for initiating a passkey ceremony.",
    ///  "type": "object",
    ///  "properties": {
    ///    "relying_party": {
    ///      "$ref": "#/components/schemas/PasskeyRelyingPartyUrl"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyInitRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub relying_party: ::std::option::Option<PasskeyRelyingPartyUrl>,
    }

    impl ::std::convert::From<&AuthPasskeyInitRequestBody> for AuthPasskeyInitRequestBody {
        fn from(value: &AuthPasskeyInitRequestBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AuthPasskeyInitRequestBody {
        fn default() -> Self {
            Self {
                relying_party: Default::default(),
            }
        }
    }

    ///The request body for initiating a passkey registration ceremony linked
    /// to a user account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyLinkInitRequestBody",
    ///  "description": "The request body for initiating a passkey registration
    /// ceremony linked to a user account.",
    ///  "type": "object",
    ///  "required": [
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "relying_party": {
    ///      "$ref": "#/components/schemas/PasskeyRelyingPartyUrl"
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyLinkInitRequestBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub relying_party: ::std::option::Option<PasskeyRelyingPartyUrl>,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&AuthPasskeyLinkInitRequestBody> for AuthPasskeyLinkInitRequestBody {
        fn from(value: &AuthPasskeyLinkInitRequestBody) -> Self {
            value.clone()
        }
    }

    ///The authenticator response for the registration ceremony linked to a
    /// user account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyLinkedRegistrationRequestBody",
    ///  "description": "The authenticator response for the registration
    /// ceremony linked to a user account.",
    ///  "type": "object",
    ///  "required": [
    ///    "authenticator_response",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "authenticator_response": {
    ///      "$ref":
    /// "#/components/schemas/PasskeyAuthenticatorRegistrationCredential"
    ///    },
    ///    "relying_party": {
    ///      "type": "string",
    ///      "format": "uri"
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyLinkedRegistrationRequestBody {
        pub authenticator_response: PasskeyAuthenticatorRegistrationCredential,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub relying_party: ::std::option::Option<::std::string::String>,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&AuthPasskeyLinkedRegistrationRequestBody>
        for AuthPasskeyLinkedRegistrationRequestBody
    {
        fn from(value: &AuthPasskeyLinkedRegistrationRequestBody) -> Self {
            value.clone()
        }
    }

    ///The response body for initiating a passkey registration ceremony.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyRegistrationInitResponseBody",
    ///  "description": "The response body for initiating a passkey registration
    /// ceremony.",
    ///  "type": "object",
    ///  "required": [
    ///    "options"
    ///  ],
    ///  "properties": {
    ///    "options": {
    ///      "$ref":
    /// "#/components/schemas/PasskeyAuthenticatorRegistrationOptions"
    ///    },
    ///    "relying_party": {
    ///      "$ref": "#/components/schemas/PasskeyRelyingPartyUrl"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyRegistrationInitResponseBody {
        pub options: PasskeyAuthenticatorRegistrationOptions,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub relying_party: ::std::option::Option<PasskeyRelyingPartyUrl>,
    }

    impl ::std::convert::From<&AuthPasskeyRegistrationInitResponseBody>
        for AuthPasskeyRegistrationInitResponseBody
    {
        fn from(value: &AuthPasskeyRegistrationInitResponseBody) -> Self {
            value.clone()
        }
    }

    ///The authenticator response for the registration ceremony.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyRegistrationRequestBody",
    ///  "description": "The authenticator response for the registration
    /// ceremony.",
    ///  "type": "object",
    ///  "required": [
    ///    "authenticator_response"
    ///  ],
    ///  "properties": {
    ///    "authenticator_response": {
    ///      "$ref":
    /// "#/components/schemas/PasskeyAuthenticatorRegistrationCredential"
    ///    },
    ///    "relying_party": {
    ///      "type": "string",
    ///      "format": "uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyRegistrationRequestBody {
        pub authenticator_response: PasskeyAuthenticatorRegistrationCredential,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub relying_party: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AuthPasskeyRegistrationRequestBody>
        for AuthPasskeyRegistrationRequestBody
    {
        fn from(value: &AuthPasskeyRegistrationRequestBody) -> Self {
            value.clone()
        }
    }

    ///The request body for unlinking a passkey from a user account.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthPasskeyUnlinkRequestBody",
    ///  "description": "The request body for unlinking a passkey from a user
    /// account.",
    ///  "type": "object",
    ///  "required": [
    ///    "credential_id",
    ///    "remove_as_mfa",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "credential_id": {
    ///      "type": "string"
    ///    },
    ///    "remove_as_mfa": {
    ///      "default": true,
    ///      "type": "boolean"
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthPasskeyUnlinkRequestBody {
        pub credential_id: ::std::string::String,
        pub remove_as_mfa: bool,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&AuthPasskeyUnlinkRequestBody> for AuthPasskeyUnlinkRequestBody {
        fn from(value: &AuthPasskeyUnlinkRequestBody) -> Self {
            value.clone()
        }
    }

    ///`AuthenticateBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "encryption_type": "HPKE",
    ///      "recipient_public_key":
    /// "DAQcDQgAEx4aoeD72yykviK+fckqE2CItVIGn1rCnvCXZ1HgpOcMEMialRmTrqIK4oZlYd1"
    /// ,
    ///      "user_jwt":
    /// "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
    /// eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.
    /// KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "user_jwt"
    ///  ],
    ///  "properties": {
    ///    "encryption_type": {
    ///      "description": "The encryption type for the authentication
    /// response. Currently only supports HPKE.",
    ///      "type": "string",
    ///      "enum": [
    ///        "HPKE"
    ///      ]
    ///    },
    ///    "recipient_public_key": {
    ///      "description": "The public key of your ECDH keypair, in
    /// base64-encoded, SPKI-format, whose private key will be able to decrypt
    /// the session key.",
    ///      "type": "string"
    ///    },
    ///    "user_jwt": {
    ///      "description": "The user's JWT, to be used to authenticate the
    /// user.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthenticateBody {
        ///The encryption type for the authentication response. Currently only
        /// supports HPKE.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub encryption_type: ::std::option::Option<AuthenticateBodyEncryptionType>,
        ///The public key of your ECDH keypair, in base64-encoded, SPKI-format,
        /// whose private key will be able to decrypt the session key.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub recipient_public_key: ::std::option::Option<::std::string::String>,
        ///The user's JWT, to be used to authenticate the user.
        pub user_jwt: ::std::string::String,
    }

    impl ::std::convert::From<&AuthenticateBody> for AuthenticateBody {
        fn from(value: &AuthenticateBody) -> Self {
            value.clone()
        }
    }

    ///The encryption type for the authentication response. Currently only
    /// supports HPKE.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The encryption type for the authentication response.
    /// Currently only supports HPKE.",
    ///  "type": "string",
    ///  "enum": [
    ///    "HPKE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AuthenticateBodyEncryptionType {
        #[serde(rename = "HPKE")]
        Hpke,
    }

    impl ::std::convert::From<&Self> for AuthenticateBodyEncryptionType {
        fn from(value: &AuthenticateBodyEncryptionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AuthenticateBodyEncryptionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hpke => f.write_str("HPKE"),
            }
        }
    }

    impl ::std::str::FromStr for AuthenticateBodyEncryptionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "HPKE" => Ok(Self::Hpke),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticateBodyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticateBodyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticateBodyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`AuthenticateResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "title": "With encryption",
    ///      "examples": [
    ///        {
    ///          "encrypted_authorization_key": {
    ///            "ciphertext":
    /// "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgsqM8IKMlpFxVypBUa/
    /// Q2QvB1AmS/g5WHPp3SKq9A75uhRANCAATeX6BDghwclKAH8+/
    /// 7IjvS1tCpvIfZ570IR44acX93pUGz5iEvpkg+HGaalHAXubuoUMq9CUWRm4wo+3090Nus",
    ///            "encapsulated_key":
    /// "BECqbgIAcs3TpP5GadS6F8mXkSktR2DR8WNtd3e0Qcy7PpoRHEygpzjFWttntS+SEM3VSr4Thewh18ZP9chseLE="
    /// ,
    ///            "encryption_type": "HPKE"
    ///          },
    ///          "expires_at": 1697059200000,
    ///          "wallets": [
    ///            {
    ///              "additional_signers": [
    ///                {
    ///                  "override_policy_ids": [],
    ///                  "signer_id": "p3cyj3n8mt9f9u2htfize511"
    ///                }
    ///              ],
    ///              "address": "0x3DE69Fd93873d40459f27Ce5B74B42536f8d6149",
    ///              "chain_type": "ethereum",
    ///              "created_at": 1744300912643,
    ///              "exported_at": null,
    ///              "id": "ubul5xhljqorce73sf82u0p3",
    ///              "imported_at": null,
    ///              "owner_id": "lzjb3xnjk2ntod3w1hgwa358",
    ///              "policy_ids": []
    ///            },
    ///            {
    ///              "additional_signers": [
    ///                {
    ///                  "override_policy_ids": [],
    ///                  "signer_id": "p3cyj3n8mt9f9u2htfize511"
    ///                }
    ///              ],
    ///              "address": "9wtGmqMamnKfz49XBwnJASbjcVnnKnT78qKopCL54TAk",
    ///              "chain_type": "solana",
    ///              "created_at": 1744300912644,
    ///              "exported_at": null,
    ///              "id": "sb4y18l68xze8gfszafmyv3q",
    ///              "imported_at": null,
    ///              "owner_id": "lzjb3xnjk2ntod3w1hgwa358",
    ///              "policy_ids": []
    ///            }
    ///          ]
    ///        }
    ///      ],
    ///      "type": "object",
    ///      "required": [
    ///        "encrypted_authorization_key",
    ///        "expires_at",
    ///        "wallets"
    ///      ],
    ///      "properties": {
    ///        "encrypted_authorization_key": {
    ///          "description": "The encrypted authorization key data.",
    ///          "type": "object",
    ///          "required": [
    ///            "ciphertext",
    ///            "encapsulated_key",
    ///            "encryption_type"
    ///          ],
    ///          "properties": {
    ///            "ciphertext": {
    ///              "description": "The encrypted authorization key
    /// corresponding to the user's current authentication session.",
    ///              "type": "string"
    ///            },
    ///            "encapsulated_key": {
    ///              "description": "Base64-encoded ephemeral public key used in
    /// the HPKE encryption process. Required for decryption.",
    ///              "type": "string"
    ///            },
    ///            "encryption_type": {
    ///              "description": "The encryption type used. Currently only
    /// supports HPKE.",
    ///              "type": "string",
    ///              "enum": [
    ///                "HPKE"
    ///              ]
    ///            }
    ///          }
    ///        },
    ///        "expires_at": {
    ///          "description": "The expiration time of the authorization key in
    /// seconds since the epoch.",
    ///          "type": "number"
    ///        },
    ///        "wallets": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Wallet"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "title": "Without encryption",
    ///      "type": "object",
    ///      "required": [
    ///        "authorization_key",
    ///        "expires_at",
    ///        "wallets"
    ///      ],
    ///      "properties": {
    ///        "authorization_key": {
    ///          "description": "The raw authorization key data.",
    ///          "type": "string"
    ///        },
    ///        "expires_at": {
    ///          "description": "The expiration time of the authorization key in
    /// seconds since the epoch.",
    ///          "type": "number"
    ///        },
    ///        "wallets": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Wallet"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum AuthenticateResponse {
        WithEncryption {
            encrypted_authorization_key: WithEncryptionEncryptedAuthorizationKey,
            expires_at: f64,
            wallets: ::std::vec::Vec<Wallet>,
        },
        WithoutEncryption {
            ///The raw authorization key data.
            authorization_key: ::std::string::String,
            expires_at: f64,
            wallets: ::std::vec::Vec<Wallet>,
        },
    }

    impl ::std::convert::From<&Self> for AuthenticateResponse {
        fn from(value: &AuthenticateResponse) -> Self {
            value.clone()
        }
    }

    ///`AuthenticateWithEmailRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthenticateWithEmailRequestBody",
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "email"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "type": "string",
    ///      "maxLength": 6,
    ///      "minLength": 6
    ///    },
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "mode": {
    ///      "type": "string",
    ///      "enum": [
    ///        "no-signup",
    ///        "login-or-sign-up"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthenticateWithEmailRequestBody {
        pub code: AuthenticateWithEmailRequestBodyCode,
        pub email: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub mode: ::std::option::Option<AuthenticateWithEmailRequestBodyMode>,
    }

    impl ::std::convert::From<&AuthenticateWithEmailRequestBody> for AuthenticateWithEmailRequestBody {
        fn from(value: &AuthenticateWithEmailRequestBody) -> Self {
            value.clone()
        }
    }

    ///`AuthenticateWithEmailRequestBodyCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 6,
    ///  "minLength": 6
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AuthenticateWithEmailRequestBodyCode(::std::string::String);
    impl ::std::ops::Deref for AuthenticateWithEmailRequestBodyCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AuthenticateWithEmailRequestBodyCode> for ::std::string::String {
        fn from(value: AuthenticateWithEmailRequestBodyCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AuthenticateWithEmailRequestBodyCode>
        for AuthenticateWithEmailRequestBodyCode
    {
        fn from(value: &AuthenticateWithEmailRequestBodyCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AuthenticateWithEmailRequestBodyCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 6usize {
                return Err("longer than 6 characters".into());
            }
            if value.chars().count() < 6usize {
                return Err("shorter than 6 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticateWithEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticateWithEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticateWithEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AuthenticateWithEmailRequestBodyCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`AuthenticateWithEmailRequestBodyMode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "no-signup",
    ///    "login-or-sign-up"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AuthenticateWithEmailRequestBodyMode {
        #[serde(rename = "no-signup")]
        NoSignup,
        #[serde(rename = "login-or-sign-up")]
        LoginOrSignUp,
    }

    impl ::std::convert::From<&Self> for AuthenticateWithEmailRequestBodyMode {
        fn from(value: &AuthenticateWithEmailRequestBodyMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AuthenticateWithEmailRequestBodyMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NoSignup => f.write_str("no-signup"),
                Self::LoginOrSignUp => f.write_str("login-or-sign-up"),
            }
        }
    }

    impl ::std::str::FromStr for AuthenticateWithEmailRequestBodyMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "no-signup" => Ok(Self::NoSignup),
                "login-or-sign-up" => Ok(Self::LoginOrSignUp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticateWithEmailRequestBodyMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticateWithEmailRequestBodyMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticateWithEmailRequestBodyMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The authenticated user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "AuthenticatedUser",
    ///  "description": "The authenticated user.",
    ///  "type": "object",
    ///  "required": [
    ///    "privy_access_token",
    ///    "refresh_token",
    ///    "session_update_action",
    ///    "token",
    ///    "user"
    ///  ],
    ///  "properties": {
    ///    "identity_token": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "is_new_user": {
    ///      "type": "boolean"
    ///    },
    ///    "oauth_tokens": {
    ///      "$ref": "#/components/schemas/OAuthTokens"
    ///    },
    ///    "privy_access_token": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "minLength": 1
    ///    },
    ///    "refresh_token": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "minLength": 1
    ///    },
    ///    "session_update_action": {
    ///      "description": "Instructs the client on how to handle tokens
    /// received",
    ///      "examples": [
    ///        "set"
    ///      ],
    ///      "type": "string",
    ///      "enum": [
    ///        "set",
    ///        "ignore",
    ///        "clear"
    ///      ]
    ///    },
    ///    "token": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "minLength": 1
    ///    },
    ///    "user": {
    ///      "$ref": "#/components/schemas/User"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AuthenticatedUser {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub identity_token: ::std::option::Option<AuthenticatedUserIdentityToken>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub is_new_user: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub oauth_tokens: ::std::option::Option<OAuthTokens>,
        pub privy_access_token: ::std::option::Option<AuthenticatedUserPrivyAccessToken>,
        pub refresh_token: ::std::option::Option<AuthenticatedUserRefreshToken>,
        ///Instructs the client on how to handle tokens received
        pub session_update_action: AuthenticatedUserSessionUpdateAction,
        pub token: ::std::option::Option<AuthenticatedUserToken>,
        pub user: User,
    }

    impl ::std::convert::From<&AuthenticatedUser> for AuthenticatedUser {
        fn from(value: &AuthenticatedUser) -> Self {
            value.clone()
        }
    }

    ///`AuthenticatedUserIdentityToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AuthenticatedUserIdentityToken(::std::string::String);
    impl ::std::ops::Deref for AuthenticatedUserIdentityToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AuthenticatedUserIdentityToken> for ::std::string::String {
        fn from(value: AuthenticatedUserIdentityToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AuthenticatedUserIdentityToken> for AuthenticatedUserIdentityToken {
        fn from(value: &AuthenticatedUserIdentityToken) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AuthenticatedUserIdentityToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticatedUserIdentityToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticatedUserIdentityToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticatedUserIdentityToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AuthenticatedUserIdentityToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`AuthenticatedUserPrivyAccessToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AuthenticatedUserPrivyAccessToken(::std::string::String);
    impl ::std::ops::Deref for AuthenticatedUserPrivyAccessToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AuthenticatedUserPrivyAccessToken> for ::std::string::String {
        fn from(value: AuthenticatedUserPrivyAccessToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AuthenticatedUserPrivyAccessToken>
        for AuthenticatedUserPrivyAccessToken
    {
        fn from(value: &AuthenticatedUserPrivyAccessToken) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AuthenticatedUserPrivyAccessToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticatedUserPrivyAccessToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticatedUserPrivyAccessToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticatedUserPrivyAccessToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AuthenticatedUserPrivyAccessToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`AuthenticatedUserRefreshToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AuthenticatedUserRefreshToken(::std::string::String);
    impl ::std::ops::Deref for AuthenticatedUserRefreshToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AuthenticatedUserRefreshToken> for ::std::string::String {
        fn from(value: AuthenticatedUserRefreshToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AuthenticatedUserRefreshToken> for AuthenticatedUserRefreshToken {
        fn from(value: &AuthenticatedUserRefreshToken) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AuthenticatedUserRefreshToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticatedUserRefreshToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticatedUserRefreshToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticatedUserRefreshToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AuthenticatedUserRefreshToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Instructs the client on how to handle tokens received
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Instructs the client on how to handle tokens received",
    ///  "examples": [
    ///    "set"
    ///  ],
    ///  "type": "string",
    ///  "enum": [
    ///    "set",
    ///    "ignore",
    ///    "clear"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AuthenticatedUserSessionUpdateAction {
        #[serde(rename = "set")]
        Set,
        #[serde(rename = "ignore")]
        Ignore,
        #[serde(rename = "clear")]
        Clear,
    }

    impl ::std::convert::From<&Self> for AuthenticatedUserSessionUpdateAction {
        fn from(value: &AuthenticatedUserSessionUpdateAction) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AuthenticatedUserSessionUpdateAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Set => f.write_str("set"),
                Self::Ignore => f.write_str("ignore"),
                Self::Clear => f.write_str("clear"),
            }
        }
    }

    impl ::std::str::FromStr for AuthenticatedUserSessionUpdateAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "set" => Ok(Self::Set),
                "ignore" => Ok(Self::Ignore),
                "clear" => Ok(Self::Clear),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticatedUserSessionUpdateAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticatedUserSessionUpdateAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticatedUserSessionUpdateAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`AuthenticatedUserToken`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct AuthenticatedUserToken(::std::string::String);
    impl ::std::ops::Deref for AuthenticatedUserToken {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<AuthenticatedUserToken> for ::std::string::String {
        fn from(value: AuthenticatedUserToken) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&AuthenticatedUserToken> for AuthenticatedUserToken {
        fn from(value: &AuthenticatedUserToken) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AuthenticatedUserToken {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthenticatedUserToken {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthenticatedUserToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthenticatedUserToken {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AuthenticatedUserToken {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`ConditionOperator`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eq",
    ///    "gt",
    ///    "gte",
    ///    "lt",
    ///    "lte",
    ///    "in"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ConditionOperator {
        #[serde(rename = "eq")]
        Eq,
        #[serde(rename = "gt")]
        Gt,
        #[serde(rename = "gte")]
        Gte,
        #[serde(rename = "lt")]
        Lt,
        #[serde(rename = "lte")]
        Lte,
        #[serde(rename = "in")]
        In,
    }

    impl ::std::convert::From<&Self> for ConditionOperator {
        fn from(value: &ConditionOperator) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ConditionOperator {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Eq => f.write_str("eq"),
                Self::Gt => f.write_str("gt"),
                Self::Gte => f.write_str("gte"),
                Self::Lt => f.write_str("lt"),
                Self::Lte => f.write_str("lte"),
                Self::In => f.write_str("in"),
            }
        }
    }

    impl ::std::str::FromStr for ConditionOperator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eq" => Ok(Self::Eq),
                "gt" => Ok(Self::Gt),
                "gte" => Ok(Self::Gte),
                "lt" => Ok(Self::Lt),
                "lte" => Ok(Self::Lte),
                "in" => Ok(Self::In),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ConditionOperator {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ConditionValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ConditionValue {
        String(::std::string::String),
        Array(::std::vec::Vec<::std::string::String>),
    }

    impl ::std::convert::From<&Self> for ConditionValue {
        fn from(value: &ConditionValue) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for ConditionValue {
        fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
            Self::Array(value)
        }
    }

    ///`ConfigureAppForFiatOnOffRampingBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "api_key": "insert-api-key",
    ///      "provider": "bridge-sandbox"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "api_key",
    ///    "provider"
    ///  ],
    ///  "properties": {
    ///    "api_key": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "provider": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bridge",
    ///        "bridge-sandbox"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConfigureAppForFiatOnOffRampingBody {
        pub api_key: ConfigureAppForFiatOnOffRampingBodyApiKey,
        pub provider: ConfigureAppForFiatOnOffRampingBodyProvider,
    }

    impl ::std::convert::From<&ConfigureAppForFiatOnOffRampingBody>
        for ConfigureAppForFiatOnOffRampingBody
    {
        fn from(value: &ConfigureAppForFiatOnOffRampingBody) -> Self {
            value.clone()
        }
    }

    ///`ConfigureAppForFiatOnOffRampingBodyApiKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct ConfigureAppForFiatOnOffRampingBodyApiKey(::std::string::String);
    impl ::std::ops::Deref for ConfigureAppForFiatOnOffRampingBodyApiKey {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<ConfigureAppForFiatOnOffRampingBodyApiKey> for ::std::string::String {
        fn from(value: ConfigureAppForFiatOnOffRampingBodyApiKey) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ConfigureAppForFiatOnOffRampingBodyApiKey>
        for ConfigureAppForFiatOnOffRampingBodyApiKey
    {
        fn from(value: &ConfigureAppForFiatOnOffRampingBodyApiKey) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ConfigureAppForFiatOnOffRampingBodyApiKey {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ConfigureAppForFiatOnOffRampingBodyApiKey {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ConfigureAppForFiatOnOffRampingBodyApiKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ConfigureAppForFiatOnOffRampingBodyApiKey {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ConfigureAppForFiatOnOffRampingBodyApiKey {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`ConfigureAppForFiatOnOffRampingBodyProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ConfigureAppForFiatOnOffRampingBodyProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for ConfigureAppForFiatOnOffRampingBodyProvider {
        fn from(value: &ConfigureAppForFiatOnOffRampingBodyProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ConfigureAppForFiatOnOffRampingBodyProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for ConfigureAppForFiatOnOffRampingBodyProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ConfigureAppForFiatOnOffRampingBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for ConfigureAppForFiatOnOffRampingBodyProvider
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for ConfigureAppForFiatOnOffRampingBodyProvider
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`ConfigureAppForFiatOnOffRampingResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConfigureAppForFiatOnOffRampingResponse {
        pub success: bool,
    }

    impl ::std::convert::From<&ConfigureAppForFiatOnOffRampingResponse>
        for ConfigureAppForFiatOnOffRampingResponse
    {
        fn from(value: &ConfigureAppForFiatOnOffRampingResponse) -> Self {
            value.clone()
        }
    }

    ///`CreateKeyQuorumBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "authorization_threshold": 1,
    ///      "display_name": "Prod key quorum",
    ///      "public_keys": [
    ///        "-----BEGIN PUBLIC
    /// KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/
    /// ckqE2CItVIG\n1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/
    /// C9yjhboIuoPD3g==\n-----END PUBLIC KEY-----",
    ///        "-----BEGIN PUBLIC
    /// KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAErzZtQr/bMIh3Y8f9ZqseB9i/
    /// AfjQ\nhu+agbNqXcJy/TfoNqvc/Y3Mh7gIZ8ZLXQEykycx4mYSpqrxp1lBKqsZDQ==\
    /// n-----END PUBLIC KEY-----\","
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "authorization_threshold": {
    ///      "type": "number",
    ///      "minimum": 1.0
    ///    },
    ///    "display_name": {
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "public_keys": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "user_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateKeyQuorumBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authorization_threshold: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<CreateKeyQuorumBodyDisplayName>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub public_keys: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub user_ids: ::std::vec::Vec<::std::string::String>,
    }

    impl ::std::convert::From<&CreateKeyQuorumBody> for CreateKeyQuorumBody {
        fn from(value: &CreateKeyQuorumBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for CreateKeyQuorumBody {
        fn default() -> Self {
            Self {
                authorization_threshold: Default::default(),
                display_name: Default::default(),
                public_keys: Default::default(),
                user_ids: Default::default(),
            }
        }
    }

    ///`CreateKeyQuorumBodyDisplayName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateKeyQuorumBodyDisplayName(::std::string::String);
    impl ::std::ops::Deref for CreateKeyQuorumBodyDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateKeyQuorumBodyDisplayName> for ::std::string::String {
        fn from(value: CreateKeyQuorumBodyDisplayName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateKeyQuorumBodyDisplayName> for CreateKeyQuorumBodyDisplayName {
        fn from(value: &CreateKeyQuorumBodyDisplayName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateKeyQuorumBodyDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateKeyQuorumBodyDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateKeyQuorumBodyDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateKeyQuorumBodyDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateKeyQuorumBodyDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreatePolicyBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "chain_type",
    ///    "name",
    ///    "rules",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/PolicyChainType"
    ///    },
    ///    "name": {
    ///      "description": "Name to assign to policy.",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/OwnerInput"
    ///    },
    ///    "owner_id": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/OwnerIdInput"
    ///        },
    ///        {}
    ///      ]
    ///    },
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PolicyRuleRequestBody"
    ///      }
    ///    },
    ///    "version": {
    ///      "description": "Version of the policy. Currently, 1.0 is the only
    /// version.",
    ///      "type": "string",
    ///      "enum": [
    ///        "1.0"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreatePolicyBody {
        pub chain_type: PolicyChainType,
        ///Name to assign to policy.
        pub name: CreatePolicyBodyName,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<OwnerInput>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<OwnerIdInput>,
        pub rules: ::std::vec::Vec<PolicyRuleRequestBody>,
        ///Version of the policy. Currently, 1.0 is the only version.
        pub version: CreatePolicyBodyVersion,
    }

    impl ::std::convert::From<&CreatePolicyBody> for CreatePolicyBody {
        fn from(value: &CreatePolicyBody) -> Self {
            value.clone()
        }
    }

    ///Name to assign to policy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Name to assign to policy.",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreatePolicyBodyName(::std::string::String);
    impl ::std::ops::Deref for CreatePolicyBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreatePolicyBodyName> for ::std::string::String {
        fn from(value: CreatePolicyBodyName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreatePolicyBodyName> for CreatePolicyBodyName {
        fn from(value: &CreatePolicyBodyName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreatePolicyBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreatePolicyBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreatePolicyBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreatePolicyBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreatePolicyBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Version of the policy. Currently, 1.0 is the only version.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Version of the policy. Currently, 1.0 is the only
    /// version.",
    ///  "type": "string",
    ///  "enum": [
    ///    "1.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreatePolicyBodyVersion {
        #[serde(rename = "1.0")]
        X10,
    }

    impl ::std::convert::From<&Self> for CreatePolicyBodyVersion {
        fn from(value: &CreatePolicyBodyVersion) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreatePolicyBodyVersion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X10 => f.write_str("1.0"),
            }
        }
    }

    impl ::std::str::FromStr for CreatePolicyBodyVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "1.0" => Ok(Self::X10),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreatePolicyBodyVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreatePolicyBodyVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreatePolicyBodyVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreatePolicyRulePolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreatePolicyRulePolicyId(::std::string::String);
    impl ::std::ops::Deref for CreatePolicyRulePolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreatePolicyRulePolicyId> for ::std::string::String {
        fn from(value: CreatePolicyRulePolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreatePolicyRulePolicyId> for CreatePolicyRulePolicyId {
        fn from(value: &CreatePolicyRulePolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreatePolicyRulePolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreatePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreatePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreatePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreatePolicyRulePolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "linked_accounts": [
    ///        {
    ///          "address": "tom.bombadill@privy.io",
    ///          "type": "email"
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "linked_accounts"
    ///  ],
    ///  "properties": {
    ///    "custom_metadata": {
    ///      "$ref": "#/components/schemas/CustomMetadata"
    ///    },
    ///    "linked_accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LinkedAccountInput"
    ///      }
    ///    },
    ///    "wallets": {
    ///      "description": "Wallets to create for the user.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "chain_type"
    ///        ],
    ///        "properties": {
    ///          "additional_signers": {
    ///            "description": "Additional signers for the wallet.",
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "signer_id"
    ///              ],
    ///              "properties": {
    ///                "override_policy_ids": {
    ///                  "description": "The array of policy IDs that will be
    /// applied to wallet requests. If specified, this will override the base
    /// policy IDs set on the wallet. Currently, only one policy is supported
    /// per signer.",
    ///                  "type": "array",
    ///                  "items": {
    ///                    "type": "string",
    ///                    "maxLength": 24,
    ///                    "minLength": 24
    ///                  }
    ///                },
    ///                "signer_id": {
    ///                  "description": "The key quorum ID for the signer.",
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "chain_type": {
    ///            "$ref": "#/components/schemas/WalletChainType"
    ///          },
    ///          "create_smart_wallet": {
    ///            "description": "Create a smart wallet with this wallet as the signer. Only supported for wallets with `chain_type: \"ethereum\"`.",
    ///            "type": "boolean"
    ///          },
    ///          "policy_ids": {
    ///            "description": "Policy IDs to enforce on the wallet.
    /// Currently, only one policy is supported per wallet.",
    ///            "type": "array",
    ///            "items": {
    ///              "type": "string",
    ///              "maxLength": 24,
    ///              "minLength": 24
    ///            },
    ///            "maxItems": 1
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub custom_metadata: ::std::option::Option<CustomMetadata>,
        pub linked_accounts: ::std::vec::Vec<LinkedAccountInput>,
        ///Wallets to create for the user.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub wallets: ::std::vec::Vec<CreateUserBodyWalletsItem>,
    }

    impl ::std::convert::From<&CreateUserBody> for CreateUserBody {
        fn from(value: &CreateUserBody) -> Self {
            value.clone()
        }
    }

    ///`CreateUserBodyWalletsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "chain_type"
    ///  ],
    ///  "properties": {
    ///    "additional_signers": {
    ///      "description": "Additional signers for the wallet.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "signer_id"
    ///        ],
    ///        "properties": {
    ///          "override_policy_ids": {
    ///            "description": "The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet. Currently, only one policy is supported per signer.",
    ///            "type": "array",
    ///            "items": {
    ///              "type": "string",
    ///              "maxLength": 24,
    ///              "minLength": 24
    ///            }
    ///          },
    ///          "signer_id": {
    ///            "description": "The key quorum ID for the signer.",
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/WalletChainType"
    ///    },
    ///    "create_smart_wallet": {
    ///      "description": "Create a smart wallet with this wallet as the signer. Only supported for wallets with `chain_type: \"ethereum\"`.",
    ///      "type": "boolean"
    ///    },
    ///    "policy_ids": {
    ///      "description": "Policy IDs to enforce on the wallet. Currently,
    /// only one policy is supported per wallet.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "maxLength": 24,
    ///        "minLength": 24
    ///      },
    ///      "maxItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserBodyWalletsItem {
        ///Additional signers for the wallet.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub additional_signers: ::std::vec::Vec<CreateUserBodyWalletsItemAdditionalSignersItem>,
        pub chain_type: WalletChainType,
        ///Create a smart wallet with this wallet as the signer. Only supported
        /// for wallets with `chain_type: "ethereum"`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub create_smart_wallet: ::std::option::Option<bool>,
        ///Policy IDs to enforce on the wallet. Currently, only one policy is
        /// supported per wallet.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<CreateUserBodyWalletsItemPolicyIdsItem>,
    }

    impl ::std::convert::From<&CreateUserBodyWalletsItem> for CreateUserBodyWalletsItem {
        fn from(value: &CreateUserBodyWalletsItem) -> Self {
            value.clone()
        }
    }

    ///`CreateUserBodyWalletsItemAdditionalSignersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signer_id"
    ///  ],
    ///  "properties": {
    ///    "override_policy_ids": {
    ///      "description": "The array of policy IDs that will be applied to wallet requests. If specified, this will override the base policy IDs set on the wallet. Currently, only one policy is supported per signer.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "maxLength": 24,
    ///        "minLength": 24
    ///      }
    ///    },
    ///    "signer_id": {
    ///      "description": "The key quorum ID for the signer.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserBodyWalletsItemAdditionalSignersItem {
        ///The array of policy IDs that will be applied to wallet requests. If
        /// specified, this will override the base policy IDs set on the wallet.
        /// Currently, only one policy is supported per signer.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub override_policy_ids:
            ::std::vec::Vec<CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem>,
        ///The key quorum ID for the signer.
        pub signer_id: ::std::string::String,
    }

    impl ::std::convert::From<&CreateUserBodyWalletsItemAdditionalSignersItem>
        for CreateUserBodyWalletsItemAdditionalSignersItem
    {
        fn from(value: &CreateUserBodyWalletsItemAdditionalSignersItem) -> Self {
            value.clone()
        }
    }

    ///`CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem(
        ::std::string::String,
    );
    impl ::std::ops::Deref for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem>
        for ::std::string::String
    {
        fn from(
            value: CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem,
        ) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        fn from(
            value: &CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for CreateUserBodyWalletsItemAdditionalSignersItemOverridePolicyIdsItem
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserBodyWalletsItemPolicyIdsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserBodyWalletsItemPolicyIdsItem(::std::string::String);
    impl ::std::ops::Deref for CreateUserBodyWalletsItemPolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserBodyWalletsItemPolicyIdsItem> for ::std::string::String {
        fn from(value: CreateUserBodyWalletsItemPolicyIdsItem) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserBodyWalletsItemPolicyIdsItem>
        for CreateUserBodyWalletsItemPolicyIdsItem
    {
        fn from(value: &CreateUserBodyWalletsItemPolicyIdsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserBodyWalletsItemPolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserBodyWalletsItemPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserBodyWalletsItemPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserBodyWalletsItemPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserBodyWalletsItemPolicyIdsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "account": {
    ///        "account_number": "1234567899",
    ///        "checking_or_savings": "checking",
    ///        "routing_number": "121212121"
    ///      },
    ///      "account_owner_name": "John Doe",
    ///      "address": {
    ///        "city": "New York",
    ///        "country": "USA",
    ///        "postal_code": "10001",
    ///        "state": "NY",
    ///        "street_line_1": "123 Washington St",
    ///        "street_line_2": "Apt 2F"
    ///      },
    ///      "bank_name": "Chase",
    ///      "currency": "usd",
    ///      "first_name": "John",
    ///      "last_name": "Doe",
    ///      "provider": "bridge-sandbox"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "account_owner_name",
    ///    "currency",
    ///    "provider"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "type": "object",
    ///      "required": [
    ///        "account_number",
    ///        "routing_number"
    ///      ],
    ///      "properties": {
    ///        "account_number": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "checking_or_savings": {
    ///          "type": "string",
    ///          "enum": [
    ///            "checking",
    ///            "savings"
    ///          ]
    ///        },
    ///        "routing_number": {
    ///          "type": "string",
    ///          "maxLength": 9,
    ///          "minLength": 9
    ///        }
    ///      }
    ///    },
    ///    "account_owner_name": {
    ///      "type": "string",
    ///      "maxLength": 256,
    ///      "minLength": 3
    ///    },
    ///    "address": {
    ///      "type": "object",
    ///      "required": [
    ///        "city",
    ///        "country",
    ///        "street_line_1"
    ///      ],
    ///      "properties": {
    ///        "city": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "country": {
    ///          "type": "string",
    ///          "maxLength": 3,
    ///          "minLength": 3
    ///        },
    ///        "postal_code": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "maxLength": 3,
    ///          "minLength": 1
    ///        },
    ///        "street_line_1": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "street_line_2": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        }
    ///      }
    ///    },
    ///    "bank_name": {
    ///      "type": "string",
    ///      "maxLength": 256,
    ///      "minLength": 3
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usd",
    ///        "eur"
    ///      ]
    ///    },
    ///    "first_name": {
    ///      "type": "string",
    ///      "maxLength": 1024,
    ///      "minLength": 1
    ///    },
    ///    "iban": {
    ///      "type": "object",
    ///      "required": [
    ///        "account_number",
    ///        "bic",
    ///        "country"
    ///      ],
    ///      "properties": {
    ///        "account_number": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "bic": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "country": {
    ///          "type": "string",
    ///          "maxLength": 3,
    ///          "minLength": 3
    ///        }
    ///      }
    ///    },
    ///    "last_name": {
    ///      "type": "string",
    ///      "maxLength": 1024,
    ///      "minLength": 1
    ///    },
    ///    "provider": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bridge",
    ///        "bridge-sandbox"
    ///      ]
    ///    },
    ///    "swift": {
    ///      "type": "object",
    ///      "required": [
    ///        "account",
    ///        "address",
    ///        "category",
    ///        "purpose_of_funds",
    ///        "short_business_description"
    ///      ],
    ///      "properties": {
    ///        "account": {
    ///          "type": "object",
    ///          "required": [
    ///            "account_number",
    ///            "bic",
    ///            "country"
    ///          ],
    ///          "properties": {
    ///            "account_number": {
    ///              "type": "string",
    ///              "minLength": 1
    ///            },
    ///            "bic": {
    ///              "type": "string",
    ///              "minLength": 1
    ///            },
    ///            "country": {
    ///              "type": "string",
    ///              "maxLength": 3,
    ///              "minLength": 3
    ///            }
    ///          }
    ///        },
    ///        "address": {
    ///          "type": "object",
    ///          "required": [
    ///            "city",
    ///            "country",
    ///            "street_line_1"
    ///          ],
    ///          "properties": {
    ///            "city": {
    ///              "type": "string",
    ///              "minLength": 1
    ///            },
    ///            "country": {
    ///              "type": "string",
    ///              "maxLength": 3,
    ///              "minLength": 3
    ///            },
    ///            "postal_code": {
    ///              "type": "string",
    ///              "minLength": 1
    ///            },
    ///            "state": {
    ///              "type": "string",
    ///              "maxLength": 3,
    ///              "minLength": 1
    ///            },
    ///            "street_line_1": {
    ///              "type": "string",
    ///              "minLength": 1
    ///            },
    ///            "street_line_2": {
    ///              "type": "string",
    ///              "minLength": 1
    ///            }
    ///          }
    ///        },
    ///        "category": {
    ///          "type": "string",
    ///          "enum": [
    ///            "client",
    ///            "parent_company",
    ///            "subsidiary",
    ///            "supplier"
    ///          ]
    ///        },
    ///        "purpose_of_funds": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string",
    ///            "enum": [
    ///              "intra_group_transfer",
    ///              "invoice_for_goods_and_services"
    ///            ]
    ///          },
    ///          "minItems": 1
    ///        },
    ///        "short_business_description": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account: ::std::option::Option<CreateUserFiatAccountBodyAccount>,
        pub account_owner_name: CreateUserFiatAccountBodyAccountOwnerName,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<CreateUserFiatAccountBodyAddress>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_name: ::std::option::Option<CreateUserFiatAccountBodyBankName>,
        pub currency: CreateUserFiatAccountBodyCurrency,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_name: ::std::option::Option<CreateUserFiatAccountBodyFirstName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub iban: ::std::option::Option<CreateUserFiatAccountBodyIban>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_name: ::std::option::Option<CreateUserFiatAccountBodyLastName>,
        pub provider: CreateUserFiatAccountBodyProvider,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub swift: ::std::option::Option<CreateUserFiatAccountBodySwift>,
    }

    impl ::std::convert::From<&CreateUserFiatAccountBody> for CreateUserFiatAccountBody {
        fn from(value: &CreateUserFiatAccountBody) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatAccountBodyAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_number",
    ///    "routing_number"
    ///  ],
    ///  "properties": {
    ///    "account_number": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "checking_or_savings": {
    ///      "type": "string",
    ///      "enum": [
    ///        "checking",
    ///        "savings"
    ///      ]
    ///    },
    ///    "routing_number": {
    ///      "type": "string",
    ///      "maxLength": 9,
    ///      "minLength": 9
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountBodyAccount {
        pub account_number: CreateUserFiatAccountBodyAccountAccountNumber,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub checking_or_savings:
            ::std::option::Option<CreateUserFiatAccountBodyAccountCheckingOrSavings>,
        pub routing_number: CreateUserFiatAccountBodyAccountRoutingNumber,
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAccount> for CreateUserFiatAccountBodyAccount {
        fn from(value: &CreateUserFiatAccountBodyAccount) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatAccountBodyAccountAccountNumber`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAccountAccountNumber(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAccountAccountNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAccountAccountNumber> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAccountAccountNumber) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAccountAccountNumber>
        for CreateUserFiatAccountBodyAccountAccountNumber
    {
        fn from(value: &CreateUserFiatAccountBodyAccountAccountNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAccountAccountNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAccountAccountNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodyAccountAccountNumber
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodyAccountAccountNumber
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAccountAccountNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAccountCheckingOrSavings`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "checking",
    ///    "savings"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserFiatAccountBodyAccountCheckingOrSavings {
        #[serde(rename = "checking")]
        Checking,
        #[serde(rename = "savings")]
        Savings,
    }

    impl ::std::convert::From<&Self> for CreateUserFiatAccountBodyAccountCheckingOrSavings {
        fn from(value: &CreateUserFiatAccountBodyAccountCheckingOrSavings) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreateUserFiatAccountBodyAccountCheckingOrSavings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Checking => f.write_str("checking"),
                Self::Savings => f.write_str("savings"),
            }
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAccountCheckingOrSavings {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "checking" => Ok(Self::Checking),
                "savings" => Ok(Self::Savings),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAccountCheckingOrSavings {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodyAccountCheckingOrSavings
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodyAccountCheckingOrSavings
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreateUserFiatAccountBodyAccountOwnerName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAccountOwnerName(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAccountOwnerName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAccountOwnerName> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAccountOwnerName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAccountOwnerName>
        for CreateUserFiatAccountBodyAccountOwnerName
    {
        fn from(value: &CreateUserFiatAccountBodyAccountOwnerName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAccountOwnerName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAccountOwnerName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyAccountOwnerName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyAccountOwnerName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAccountOwnerName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAccountRoutingNumber`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 9,
    ///  "minLength": 9
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAccountRoutingNumber(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAccountRoutingNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAccountRoutingNumber> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAccountRoutingNumber) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAccountRoutingNumber>
        for CreateUserFiatAccountBodyAccountRoutingNumber
    {
        fn from(value: &CreateUserFiatAccountBodyAccountRoutingNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAccountRoutingNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 9usize {
                return Err("longer than 9 characters".into());
            }
            if value.chars().count() < 9usize {
                return Err("shorter than 9 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAccountRoutingNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodyAccountRoutingNumber
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodyAccountRoutingNumber
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAccountRoutingNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "state": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountBodyAddress {
        pub city: CreateUserFiatAccountBodyAddressCity,
        pub country: CreateUserFiatAccountBodyAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<CreateUserFiatAccountBodyAddressPostalCode>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<CreateUserFiatAccountBodyAddressState>,
        pub street_line_1: CreateUserFiatAccountBodyAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<CreateUserFiatAccountBodyAddressStreetLine2>,
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAddress> for CreateUserFiatAccountBodyAddress {
        fn from(value: &CreateUserFiatAccountBodyAddress) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatAccountBodyAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAddressCity(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAddressCity> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAddressCity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAddressCity>
        for CreateUserFiatAccountBodyAddressCity
    {
        fn from(value: &CreateUserFiatAccountBodyAddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAddressCity {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAddressCountry(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAddressCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAddressCountry> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAddressCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAddressCountry>
        for CreateUserFiatAccountBodyAddressCountry
    {
        fn from(value: &CreateUserFiatAccountBodyAddressCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyAddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyAddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAddressCountry {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAddressPostalCode(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAddressPostalCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAddressPostalCode> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAddressPostalCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAddressPostalCode>
        for CreateUserFiatAccountBodyAddressPostalCode
    {
        fn from(value: &CreateUserFiatAccountBodyAddressPostalCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAddressPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAddressPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodyAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyAddressPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAddressPostalCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAddressState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAddressState(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAddressState {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAddressState> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAddressState) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAddressState>
        for CreateUserFiatAccountBodyAddressState
    {
        fn from(value: &CreateUserFiatAccountBodyAddressState) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAddressState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAddressState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyAddressState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyAddressState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAddressState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAddressStreetLine1(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAddressStreetLine1 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAddressStreetLine1> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAddressStreetLine1) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAddressStreetLine1>
        for CreateUserFiatAccountBodyAddressStreetLine1
    {
        fn from(value: &CreateUserFiatAccountBodyAddressStreetLine1) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAddressStreetLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAddressStreetLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodyAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodyAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAddressStreetLine1 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyAddressStreetLine2(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyAddressStreetLine2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyAddressStreetLine2> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyAddressStreetLine2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyAddressStreetLine2>
        for CreateUserFiatAccountBodyAddressStreetLine2
    {
        fn from(value: &CreateUserFiatAccountBodyAddressStreetLine2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyAddressStreetLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyAddressStreetLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodyAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodyAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyAddressStreetLine2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyBankName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyBankName(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyBankName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyBankName> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyBankName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyBankName>
        for CreateUserFiatAccountBodyBankName
    {
        fn from(value: &CreateUserFiatAccountBodyBankName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyBankName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyBankName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyBankName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyBankName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyBankName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usd",
    ///    "eur"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserFiatAccountBodyCurrency {
        #[serde(rename = "usd")]
        Usd,
        #[serde(rename = "eur")]
        Eur,
    }

    impl ::std::convert::From<&Self> for CreateUserFiatAccountBodyCurrency {
        fn from(value: &CreateUserFiatAccountBodyCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreateUserFiatAccountBodyCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
                Self::Eur => f.write_str("eur"),
            }
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                "eur" => Ok(Self::Eur),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreateUserFiatAccountBodyFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyFirstName(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyFirstName> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyFirstName>
        for CreateUserFiatAccountBodyFirstName
    {
        fn from(value: &CreateUserFiatAccountBodyFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyIban`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_number",
    ///    "bic",
    ///    "country"
    ///  ],
    ///  "properties": {
    ///    "account_number": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "bic": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountBodyIban {
        pub account_number: CreateUserFiatAccountBodyIbanAccountNumber,
        pub bic: CreateUserFiatAccountBodyIbanBic,
        pub country: CreateUserFiatAccountBodyIbanCountry,
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyIban> for CreateUserFiatAccountBodyIban {
        fn from(value: &CreateUserFiatAccountBodyIban) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatAccountBodyIbanAccountNumber`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyIbanAccountNumber(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyIbanAccountNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyIbanAccountNumber> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyIbanAccountNumber) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyIbanAccountNumber>
        for CreateUserFiatAccountBodyIbanAccountNumber
    {
        fn from(value: &CreateUserFiatAccountBodyIbanAccountNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyIbanAccountNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyIbanAccountNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodyIbanAccountNumber
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyIbanAccountNumber {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyIbanAccountNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyIbanBic`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyIbanBic(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyIbanBic {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyIbanBic> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyIbanBic) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyIbanBic> for CreateUserFiatAccountBodyIbanBic {
        fn from(value: &CreateUserFiatAccountBodyIbanBic) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyIbanBic {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyIbanBic {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyIbanBic {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyIbanBic {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyIbanBic {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyIbanCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyIbanCountry(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyIbanCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyIbanCountry> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyIbanCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyIbanCountry>
        for CreateUserFiatAccountBodyIbanCountry
    {
        fn from(value: &CreateUserFiatAccountBodyIbanCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyIbanCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyIbanCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyIbanCountry {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyIbanCountry {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyIbanCountry {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodyLastName(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodyLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodyLastName> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodyLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodyLastName>
        for CreateUserFiatAccountBodyLastName
    {
        fn from(value: &CreateUserFiatAccountBodyLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodyLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodyProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserFiatAccountBodyProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for CreateUserFiatAccountBodyProvider {
        fn from(value: &CreateUserFiatAccountBodyProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreateUserFiatAccountBodyProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodyProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreateUserFiatAccountBodySwift`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account",
    ///    "address",
    ///    "category",
    ///    "purpose_of_funds",
    ///    "short_business_description"
    ///  ],
    ///  "properties": {
    ///    "account": {
    ///      "type": "object",
    ///      "required": [
    ///        "account_number",
    ///        "bic",
    ///        "country"
    ///      ],
    ///      "properties": {
    ///        "account_number": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "bic": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "country": {
    ///          "type": "string",
    ///          "maxLength": 3,
    ///          "minLength": 3
    ///        }
    ///      }
    ///    },
    ///    "address": {
    ///      "type": "object",
    ///      "required": [
    ///        "city",
    ///        "country",
    ///        "street_line_1"
    ///      ],
    ///      "properties": {
    ///        "city": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "country": {
    ///          "type": "string",
    ///          "maxLength": 3,
    ///          "minLength": 3
    ///        },
    ///        "postal_code": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "maxLength": 3,
    ///          "minLength": 1
    ///        },
    ///        "street_line_1": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        },
    ///        "street_line_2": {
    ///          "type": "string",
    ///          "minLength": 1
    ///        }
    ///      }
    ///    },
    ///    "category": {
    ///      "type": "string",
    ///      "enum": [
    ///        "client",
    ///        "parent_company",
    ///        "subsidiary",
    ///        "supplier"
    ///      ]
    ///    },
    ///    "purpose_of_funds": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "intra_group_transfer",
    ///          "invoice_for_goods_and_services"
    ///        ]
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "short_business_description": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountBodySwift {
        pub account: CreateUserFiatAccountBodySwiftAccount,
        pub address: CreateUserFiatAccountBodySwiftAddress,
        pub category: CreateUserFiatAccountBodySwiftCategory,
        pub purpose_of_funds: ::std::vec::Vec<CreateUserFiatAccountBodySwiftPurposeOfFundsItem>,
        pub short_business_description: CreateUserFiatAccountBodySwiftShortBusinessDescription,
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwift> for CreateUserFiatAccountBodySwift {
        fn from(value: &CreateUserFiatAccountBodySwift) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatAccountBodySwiftAccount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_number",
    ///    "bic",
    ///    "country"
    ///  ],
    ///  "properties": {
    ///    "account_number": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "bic": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountBodySwiftAccount {
        pub account_number: CreateUserFiatAccountBodySwiftAccountAccountNumber,
        pub bic: CreateUserFiatAccountBodySwiftAccountBic,
        pub country: CreateUserFiatAccountBodySwiftAccountCountry,
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAccount>
        for CreateUserFiatAccountBodySwiftAccount
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAccount) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatAccountBodySwiftAccountAccountNumber`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAccountAccountNumber(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAccountAccountNumber {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAccountAccountNumber>
        for ::std::string::String
    {
        fn from(value: CreateUserFiatAccountBodySwiftAccountAccountNumber) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAccountAccountNumber>
        for CreateUserFiatAccountBodySwiftAccountAccountNumber
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAccountAccountNumber) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAccountAccountNumber {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAccountAccountNumber {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftAccountAccountNumber
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftAccountAccountNumber
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAccountAccountNumber {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAccountBic`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAccountBic(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAccountBic {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAccountBic> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodySwiftAccountBic) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAccountBic>
        for CreateUserFiatAccountBodySwiftAccountBic
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAccountBic) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAccountBic {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAccountBic {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodySwiftAccountBic {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodySwiftAccountBic {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAccountBic {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAccountCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAccountCountry(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAccountCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAccountCountry> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodySwiftAccountCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAccountCountry>
        for CreateUserFiatAccountBodySwiftAccountCountry
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAccountCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAccountCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAccountCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftAccountCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftAccountCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAccountCountry {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "state": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountBodySwiftAddress {
        pub city: CreateUserFiatAccountBodySwiftAddressCity,
        pub country: CreateUserFiatAccountBodySwiftAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<CreateUserFiatAccountBodySwiftAddressPostalCode>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub state: ::std::option::Option<CreateUserFiatAccountBodySwiftAddressState>,
        pub street_line_1: CreateUserFiatAccountBodySwiftAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<CreateUserFiatAccountBodySwiftAddressStreetLine2>,
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAddress>
        for CreateUserFiatAccountBodySwiftAddress
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAddress) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatAccountBodySwiftAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAddressCity(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAddressCity> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodySwiftAddressCity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAddressCity>
        for CreateUserFiatAccountBodySwiftAddressCity
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodySwiftAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodySwiftAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAddressCity {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAddressCountry(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAddressCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAddressCountry> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodySwiftAddressCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAddressCountry>
        for CreateUserFiatAccountBodySwiftAddressCountry
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAddressCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAddressCountry {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAddressPostalCode(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAddressPostalCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAddressPostalCode>
        for ::std::string::String
    {
        fn from(value: CreateUserFiatAccountBodySwiftAddressPostalCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAddressPostalCode>
        for CreateUserFiatAccountBodySwiftAddressPostalCode
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAddressPostalCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAddressPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAddressPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAddressPostalCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAddressState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAddressState(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAddressState {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAddressState> for ::std::string::String {
        fn from(value: CreateUserFiatAccountBodySwiftAddressState) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAddressState>
        for CreateUserFiatAccountBodySwiftAddressState
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAddressState) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAddressState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAddressState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressState
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodySwiftAddressState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAddressState {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAddressStreetLine1(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAddressStreetLine1 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAddressStreetLine1>
        for ::std::string::String
    {
        fn from(value: CreateUserFiatAccountBodySwiftAddressStreetLine1) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAddressStreetLine1>
        for CreateUserFiatAccountBodySwiftAddressStreetLine1
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAddressStreetLine1) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAddressStreetLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAddressStreetLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAddressStreetLine1 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftAddressStreetLine2(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftAddressStreetLine2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftAddressStreetLine2>
        for ::std::string::String
    {
        fn from(value: CreateUserFiatAccountBodySwiftAddressStreetLine2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftAddressStreetLine2>
        for CreateUserFiatAccountBodySwiftAddressStreetLine2
    {
        fn from(value: &CreateUserFiatAccountBodySwiftAddressStreetLine2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftAddressStreetLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftAddressStreetLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftAddressStreetLine2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountBodySwiftCategory`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "client",
    ///    "parent_company",
    ///    "subsidiary",
    ///    "supplier"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserFiatAccountBodySwiftCategory {
        #[serde(rename = "client")]
        Client,
        #[serde(rename = "parent_company")]
        ParentCompany,
        #[serde(rename = "subsidiary")]
        Subsidiary,
        #[serde(rename = "supplier")]
        Supplier,
    }

    impl ::std::convert::From<&Self> for CreateUserFiatAccountBodySwiftCategory {
        fn from(value: &CreateUserFiatAccountBodySwiftCategory) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreateUserFiatAccountBodySwiftCategory {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Client => f.write_str("client"),
                Self::ParentCompany => f.write_str("parent_company"),
                Self::Subsidiary => f.write_str("subsidiary"),
                Self::Supplier => f.write_str("supplier"),
            }
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftCategory {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "client" => Ok(Self::Client),
                "parent_company" => Ok(Self::ParentCompany),
                "subsidiary" => Ok(Self::Subsidiary),
                "supplier" => Ok(Self::Supplier),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftCategory {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatAccountBodySwiftCategory {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatAccountBodySwiftCategory {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreateUserFiatAccountBodySwiftPurposeOfFundsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "intra_group_transfer",
    ///    "invoice_for_goods_and_services"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserFiatAccountBodySwiftPurposeOfFundsItem {
        #[serde(rename = "intra_group_transfer")]
        IntraGroupTransfer,
        #[serde(rename = "invoice_for_goods_and_services")]
        InvoiceForGoodsAndServices,
    }

    impl ::std::convert::From<&Self> for CreateUserFiatAccountBodySwiftPurposeOfFundsItem {
        fn from(value: &CreateUserFiatAccountBodySwiftPurposeOfFundsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreateUserFiatAccountBodySwiftPurposeOfFundsItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IntraGroupTransfer => f.write_str("intra_group_transfer"),
                Self::InvoiceForGoodsAndServices => f.write_str("invoice_for_goods_and_services"),
            }
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftPurposeOfFundsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "intra_group_transfer" => Ok(Self::IntraGroupTransfer),
                "invoice_for_goods_and_services" => Ok(Self::InvoiceForGoodsAndServices),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftPurposeOfFundsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftPurposeOfFundsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftPurposeOfFundsItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreateUserFiatAccountBodySwiftShortBusinessDescription`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateUserFiatAccountBodySwiftShortBusinessDescription(::std::string::String);
    impl ::std::ops::Deref for CreateUserFiatAccountBodySwiftShortBusinessDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateUserFiatAccountBodySwiftShortBusinessDescription>
        for ::std::string::String
    {
        fn from(value: CreateUserFiatAccountBodySwiftShortBusinessDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateUserFiatAccountBodySwiftShortBusinessDescription>
        for CreateUserFiatAccountBodySwiftShortBusinessDescription
    {
        fn from(value: &CreateUserFiatAccountBodySwiftShortBusinessDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateUserFiatAccountBodySwiftShortBusinessDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatAccountBodySwiftShortBusinessDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for CreateUserFiatAccountBodySwiftShortBusinessDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for CreateUserFiatAccountBodySwiftShortBusinessDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateUserFiatAccountBodySwiftShortBusinessDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`CreateUserFiatAccountResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "account_type": "us",
    ///      "bank_name": "Chase",
    ///      "currency": "usd",
    ///      "id": "a068d2dd-743a-4011-9b62-8ad33cc7a7be",
    ///      "last_4": "7899"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "account_type",
    ///    "currency",
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "account_type": {
    ///      "type": "string"
    ///    },
    ///    "bank_name": {
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "last_4": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatAccountResponse {
        pub account_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_name: ::std::option::Option<::std::string::String>,
        pub currency: ::std::string::String,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_4: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CreateUserFiatAccountResponse> for CreateUserFiatAccountResponse {
        fn from(value: &CreateUserFiatAccountResponse) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatTosBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "provider": "bridge-sandbox"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "provider"
    ///  ],
    ///  "properties": {
    ///    "provider": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bridge",
    ///        "bridge-sandbox"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserFiatTosBody {
        pub provider: CreateUserFiatTosBodyProvider,
    }

    impl ::std::convert::From<&CreateUserFiatTosBody> for CreateUserFiatTosBody {
        fn from(value: &CreateUserFiatTosBody) -> Self {
            value.clone()
        }
    }

    ///`CreateUserFiatTosBodyProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserFiatTosBodyProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for CreateUserFiatTosBodyProvider {
        fn from(value: &CreateUserFiatTosBodyProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreateUserFiatTosBodyProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for CreateUserFiatTosBodyProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserFiatTosBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserFiatTosBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserFiatTosBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreateUserFiatTosResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "status": "incomplete",
    ///      "url": "https://dashboard.bridge.xyz/accept-terms-of-service?session_token=a53cd290-0ef6-4ab6-99d2-cd82192e7914"
    ///    }
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "status"
    ///      ],
    ///      "properties": {
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "completed"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "status",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "incomplete"
    ///          ]
    ///        },
    ///        "url": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "status", content = "url")]
    pub enum CreateUserFiatTosResponse {
        #[serde(rename = "completed")]
        Completed,
        #[serde(rename = "incomplete")]
        Incomplete(::std::string::String),
    }

    impl ::std::convert::From<&Self> for CreateUserFiatTosResponse {
        fn from(value: &CreateUserFiatTosResponse) -> Self {
            value.clone()
        }
    }

    ///`CreateUserWalletBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "wallets"
    ///  ],
    ///  "properties": {
    ///    "wallets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "chain_type"
    ///        ],
    ///        "properties": {
    ///          "additional_signers": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "signer_id"
    ///              ],
    ///              "properties": {
    ///                "override_policy_ids": {
    ///                  "type": "array",
    ///                  "items": {
    ///                    "type": "string"
    ///                  },
    ///                  "maxItems": 1
    ///                },
    ///                "signer_id": {
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          },
    ///          "chain_type": {
    ///            "type": "string",
    ///            "enum": [
    ///              "cosmos",
    ///              "stellar",
    ///              "sui",
    ///              "tron",
    ///              "bitcoin-segwit",
    ///              "near",
    ///              "ton",
    ///              "starknet",
    ///              "spark",
    ///              "solana",
    ///              "ethereum"
    ///            ]
    ///          },
    ///          "create_smart_wallet": {
    ///            "type": "boolean"
    ///          },
    ///          "policy_ids": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "string"
    ///            },
    ///            "maxItems": 1
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserWalletBody {
        pub wallets: ::std::vec::Vec<CreateUserWalletBodyWalletsItem>,
    }

    impl ::std::convert::From<&CreateUserWalletBody> for CreateUserWalletBody {
        fn from(value: &CreateUserWalletBody) -> Self {
            value.clone()
        }
    }

    ///`CreateUserWalletBodyWalletsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "chain_type"
    ///  ],
    ///  "properties": {
    ///    "additional_signers": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "signer_id"
    ///        ],
    ///        "properties": {
    ///          "override_policy_ids": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "string"
    ///            },
    ///            "maxItems": 1
    ///          },
    ///          "signer_id": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "cosmos",
    ///        "stellar",
    ///        "sui",
    ///        "tron",
    ///        "bitcoin-segwit",
    ///        "near",
    ///        "ton",
    ///        "starknet",
    ///        "spark",
    ///        "solana",
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "create_smart_wallet": {
    ///      "type": "boolean"
    ///    },
    ///    "policy_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserWalletBodyWalletsItem {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub additional_signers:
            ::std::vec::Vec<CreateUserWalletBodyWalletsItemAdditionalSignersItem>,
        pub chain_type: CreateUserWalletBodyWalletsItemChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub create_smart_wallet: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<::std::string::String>,
    }

    impl ::std::convert::From<&CreateUserWalletBodyWalletsItem> for CreateUserWalletBodyWalletsItem {
        fn from(value: &CreateUserWalletBodyWalletsItem) -> Self {
            value.clone()
        }
    }

    ///`CreateUserWalletBodyWalletsItemAdditionalSignersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signer_id"
    ///  ],
    ///  "properties": {
    ///    "override_policy_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 1
    ///    },
    ///    "signer_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateUserWalletBodyWalletsItemAdditionalSignersItem {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub override_policy_ids: ::std::vec::Vec<::std::string::String>,
        pub signer_id: ::std::string::String,
    }

    impl ::std::convert::From<&CreateUserWalletBodyWalletsItemAdditionalSignersItem>
        for CreateUserWalletBodyWalletsItemAdditionalSignersItem
    {
        fn from(value: &CreateUserWalletBodyWalletsItemAdditionalSignersItem) -> Self {
            value.clone()
        }
    }

    ///`CreateUserWalletBodyWalletsItemChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "cosmos",
    ///    "stellar",
    ///    "sui",
    ///    "tron",
    ///    "bitcoin-segwit",
    ///    "near",
    ///    "ton",
    ///    "starknet",
    ///    "spark",
    ///    "solana",
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CreateUserWalletBodyWalletsItemChainType {
        #[serde(rename = "cosmos")]
        Cosmos,
        #[serde(rename = "stellar")]
        Stellar,
        #[serde(rename = "sui")]
        Sui,
        #[serde(rename = "tron")]
        Tron,
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
        #[serde(rename = "near")]
        Near,
        #[serde(rename = "ton")]
        Ton,
        #[serde(rename = "starknet")]
        Starknet,
        #[serde(rename = "spark")]
        Spark,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for CreateUserWalletBodyWalletsItemChainType {
        fn from(value: &CreateUserWalletBodyWalletsItemChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CreateUserWalletBodyWalletsItemChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Cosmos => f.write_str("cosmos"),
                Self::Stellar => f.write_str("stellar"),
                Self::Sui => f.write_str("sui"),
                Self::Tron => f.write_str("tron"),
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
                Self::Near => f.write_str("near"),
                Self::Ton => f.write_str("ton"),
                Self::Starknet => f.write_str("starknet"),
                Self::Spark => f.write_str("spark"),
                Self::Solana => f.write_str("solana"),
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for CreateUserWalletBodyWalletsItemChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "cosmos" => Ok(Self::Cosmos),
                "stellar" => Ok(Self::Stellar),
                "sui" => Ok(Self::Sui),
                "tron" => Ok(Self::Tron),
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                "near" => Ok(Self::Near),
                "ton" => Ok(Self::Ton),
                "starknet" => Ok(Self::Starknet),
                "spark" => Ok(Self::Spark),
                "solana" => Ok(Self::Solana),
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateUserWalletBodyWalletsItemChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateUserWalletBodyWalletsItemChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateUserWalletBodyWalletsItemChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`CreateWalletBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "chain_type": "ethereum"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "chain_type"
    ///  ],
    ///  "properties": {
    ///    "additional_signers": {
    ///      "$ref": "#/components/schemas/WalletAdditionalSigner"
    ///    },
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/WalletChainType"
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/OwnerInput"
    ///    },
    ///    "owner_id": {
    ///      "$ref": "#/components/schemas/OwnerIdInput"
    ///    },
    ///    "policy_ids": {
    ///      "description": "List of policy IDs for policies that should be
    /// enforced on the wallet. Currently, only one policy is supported per
    /// wallet.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "maxLength": 24,
    ///        "minLength": 24
    ///      },
    ///      "maxItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CreateWalletBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub additional_signers: ::std::option::Option<WalletAdditionalSigner>,
        pub chain_type: WalletChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<OwnerInput>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<OwnerIdInput>,
        ///List of policy IDs for policies that should be enforced on the
        /// wallet. Currently, only one policy is supported per wallet.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<CreateWalletBodyPolicyIdsItem>,
    }

    impl ::std::convert::From<&CreateWalletBody> for CreateWalletBody {
        fn from(value: &CreateWalletBody) -> Self {
            value.clone()
        }
    }

    ///`CreateWalletBodyPolicyIdsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct CreateWalletBodyPolicyIdsItem(::std::string::String);
    impl ::std::ops::Deref for CreateWalletBodyPolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<CreateWalletBodyPolicyIdsItem> for ::std::string::String {
        fn from(value: CreateWalletBodyPolicyIdsItem) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CreateWalletBodyPolicyIdsItem> for CreateWalletBodyPolicyIdsItem {
        fn from(value: &CreateWalletBodyPolicyIdsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CreateWalletBodyPolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CreateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for CreateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for CreateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CreateWalletBodyPolicyIdsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Custom metadata associated with the user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Custom metadata associated with the user.",
    ///  "type": "object",
    ///  "additionalProperties": {
    ///    "oneOf": [
    ///      {
    ///        "type": "string"
    ///      },
    ///      {
    ///        "type": "number"
    ///      },
    ///      {
    ///        "type": "boolean"
    ///      }
    ///    ]
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct CustomMetadata(
        pub ::std::collections::HashMap<::std::string::String, CustomMetadataValue>,
    );
    impl ::std::ops::Deref for CustomMetadata {
        type Target = ::std::collections::HashMap<::std::string::String, CustomMetadataValue>;
        fn deref(
            &self,
        ) -> &::std::collections::HashMap<::std::string::String, CustomMetadataValue> {
            &self.0
        }
    }

    impl ::std::convert::From<CustomMetadata>
        for ::std::collections::HashMap<::std::string::String, CustomMetadataValue>
    {
        fn from(value: CustomMetadata) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&CustomMetadata> for CustomMetadata {
        fn from(value: &CustomMetadata) -> Self {
            value.clone()
        }
    }

    impl
        ::std::convert::From<
            ::std::collections::HashMap<::std::string::String, CustomMetadataValue>,
        > for CustomMetadata
    {
        fn from(
            value: ::std::collections::HashMap<::std::string::String, CustomMetadataValue>,
        ) -> Self {
            Self(value)
        }
    }

    ///`CustomMetadataValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "number"
    ///    },
    ///    {
    ///      "type": "boolean"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum CustomMetadataValue {
        String(::std::string::String),
        Number(f64),
        Boolean(bool),
    }

    impl ::std::convert::From<&Self> for CustomMetadataValue {
        fn from(value: &CustomMetadataValue) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for CustomMetadataValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Number(x) => x.fmt(f),
                Self::Boolean(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<f64> for CustomMetadataValue {
        fn from(value: f64) -> Self {
            Self::Number(value)
        }
    }

    impl ::std::convert::From<bool> for CustomMetadataValue {
        fn from(value: bool) -> Self {
            Self::Boolean(value)
        }
    }

    ///`DeleteKeyQuorumResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "description": "Whether the key quorum was deleted successfully.",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeleteKeyQuorumResponse {
        ///Whether the key quorum was deleted successfully.
        pub success: bool,
    }

    impl ::std::convert::From<&DeleteKeyQuorumResponse> for DeleteKeyQuorumResponse {
        fn from(value: &DeleteKeyQuorumResponse) -> Self {
            value.clone()
        }
    }

    ///`DeletePolicyPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct DeletePolicyPolicyId(::std::string::String);
    impl ::std::ops::Deref for DeletePolicyPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<DeletePolicyPolicyId> for ::std::string::String {
        fn from(value: DeletePolicyPolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&DeletePolicyPolicyId> for DeletePolicyPolicyId {
        fn from(value: &DeletePolicyPolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for DeletePolicyPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for DeletePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DeletePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DeletePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for DeletePolicyPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`DeletePolicyResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "description": "Whether the policy was deleted successfully.",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeletePolicyResponse {
        ///Whether the policy was deleted successfully.
        pub success: bool,
    }

    impl ::std::convert::From<&DeletePolicyResponse> for DeletePolicyResponse {
        fn from(value: &DeletePolicyResponse) -> Self {
            value.clone()
        }
    }

    ///`DeletePolicyRulePolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct DeletePolicyRulePolicyId(::std::string::String);
    impl ::std::ops::Deref for DeletePolicyRulePolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<DeletePolicyRulePolicyId> for ::std::string::String {
        fn from(value: DeletePolicyRulePolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&DeletePolicyRulePolicyId> for DeletePolicyRulePolicyId {
        fn from(value: &DeletePolicyRulePolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for DeletePolicyRulePolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for DeletePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DeletePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DeletePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for DeletePolicyRulePolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`DeletePolicyRuleResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "success": true
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "description": "Whether the rule was deleted successfully.",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DeletePolicyRuleResponse {
        ///Whether the rule was deleted successfully.
        pub success: bool,
    }

    impl ::std::convert::From<&DeletePolicyRuleResponse> for DeletePolicyRuleResponse {
        fn from(value: &DeletePolicyRuleResponse) -> Self {
            value.clone()
        }
    }

    ///`DeletePolicyRuleRuleId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct DeletePolicyRuleRuleId(::std::string::String);
    impl ::std::ops::Deref for DeletePolicyRuleRuleId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<DeletePolicyRuleRuleId> for ::std::string::String {
        fn from(value: DeletePolicyRuleRuleId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&DeletePolicyRuleRuleId> for DeletePolicyRuleRuleId {
        fn from(value: &DeletePolicyRuleRuleId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for DeletePolicyRuleRuleId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for DeletePolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DeletePolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DeletePolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for DeletePolicyRuleRuleId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Allowed contract addresses for eth_signAuthorization requests.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "ethereum_7702_authorization",
    ///  "description": "Allowed contract addresses for eth_signAuthorization
    /// requests.",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "title": "Ethereum7702AuthorizationConditionField",
    ///      "type": "string",
    ///      "enum": [
    ///        "contract"
    ///      ]
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum_7702_authorization"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ethereum7702AuthorizationCondition {
        pub field: Ethereum7702AuthorizationConditionField,
        pub field_source: Ethereum7702AuthorizationConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&Ethereum7702AuthorizationCondition>
        for Ethereum7702AuthorizationCondition
    {
        fn from(value: &Ethereum7702AuthorizationCondition) -> Self {
            value.clone()
        }
    }

    ///`Ethereum7702AuthorizationConditionField`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Ethereum7702AuthorizationConditionField",
    ///  "type": "string",
    ///  "enum": [
    ///    "contract"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Ethereum7702AuthorizationConditionField {
        #[serde(rename = "contract")]
        Contract,
    }

    impl ::std::convert::From<&Self> for Ethereum7702AuthorizationConditionField {
        fn from(value: &Ethereum7702AuthorizationConditionField) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for Ethereum7702AuthorizationConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Contract => f.write_str("contract"),
            }
        }
    }

    impl ::std::str::FromStr for Ethereum7702AuthorizationConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "contract" => Ok(Self::Contract),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for Ethereum7702AuthorizationConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Ethereum7702AuthorizationConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Ethereum7702AuthorizationConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`Ethereum7702AuthorizationConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum_7702_authorization"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Ethereum7702AuthorizationConditionFieldSource {
        #[serde(rename = "ethereum_7702_authorization")]
        Ethereum7702Authorization,
    }

    impl ::std::convert::From<&Self> for Ethereum7702AuthorizationConditionFieldSource {
        fn from(value: &Ethereum7702AuthorizationConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for Ethereum7702AuthorizationConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum7702Authorization => f.write_str("ethereum_7702_authorization"),
            }
        }
    }

    impl ::std::str::FromStr for Ethereum7702AuthorizationConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_7702_authorization" => Ok(Self::Ethereum7702Authorization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for Ethereum7702AuthorizationConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for Ethereum7702AuthorizationConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for Ethereum7702AuthorizationConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The decoded calldata in a smart contract interaction as the smart
    /// contract method's parameters. Note that that 'ethereum_calldata'
    /// conditions must contain an abi parameter with the JSON ABI of the smart
    /// contract.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "ethereum_calldata",
    ///  "description": "The decoded calldata in a smart contract interaction as
    /// the smart contract method's parameters. Note that that
    /// 'ethereum_calldata' conditions must contain an abi parameter with the
    /// JSON ABI of the smart contract.",
    ///  "type": "object",
    ///  "required": [
    ///    "abi",
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "abi": {
    ///      "type": "object"
    ///    },
    ///    "field": {
    ///      "title": "EthereumCalldataConditionField",
    ///      "type": "string"
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum_calldata"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumCalldataCondition {
        pub abi: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub field: ::std::string::String,
        pub field_source: EthereumCalldataConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&EthereumCalldataCondition> for EthereumCalldataCondition {
        fn from(value: &EthereumCalldataCondition) -> Self {
            value.clone()
        }
    }

    ///`EthereumCalldataConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum_calldata"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumCalldataConditionFieldSource {
        #[serde(rename = "ethereum_calldata")]
        EthereumCalldata,
    }

    impl ::std::convert::From<&Self> for EthereumCalldataConditionFieldSource {
        fn from(value: &EthereumCalldataConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumCalldataConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumCalldata => f.write_str("ethereum_calldata"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumCalldataConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_calldata" => Ok(Self::EthereumCalldata),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumCalldataConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumCalldataConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumCalldataConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumPersonalSignRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "personal_sign"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string",
    ///              "enum": [
    ///                "utf-8"
    ///              ]
    ///            },
    ///            {
    ///              "type": "string",
    ///              "enum": [
    ///                "hex"
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumPersonalSignRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumPersonalSignRpcInputChainType>,
        pub method: EthereumPersonalSignRpcInputMethod,
        pub params: EthereumPersonalSignRpcInputParams,
    }

    impl ::std::convert::From<&EthereumPersonalSignRpcInput> for EthereumPersonalSignRpcInput {
        fn from(value: &EthereumPersonalSignRpcInput) -> Self {
            value.clone()
        }
    }

    ///`EthereumPersonalSignRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcInputChainType {
        fn from(value: &EthereumPersonalSignRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumPersonalSignRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumPersonalSignRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumPersonalSignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumPersonalSignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumPersonalSignRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "personal_sign"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcInputMethod {
        #[serde(rename = "personal_sign")]
        PersonalSign,
    }

    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcInputMethod {
        fn from(value: &EthereumPersonalSignRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumPersonalSignRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PersonalSign => f.write_str("personal_sign"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumPersonalSignRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "personal_sign" => Ok(Self::PersonalSign),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumPersonalSignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumPersonalSignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumPersonalSignRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string",
    ///          "enum": [
    ///            "utf-8"
    ///          ]
    ///        },
    ///        {
    ///          "type": "string",
    ///          "enum": [
    ///            "hex"
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumPersonalSignRpcInputParams {
        pub encoding: EthereumPersonalSignRpcInputParamsEncoding,
        pub message: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumPersonalSignRpcInputParams>
        for EthereumPersonalSignRpcInputParams
    {
        fn from(value: &EthereumPersonalSignRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`EthereumPersonalSignRpcInputParamsEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "utf-8"
    ///      ]
    ///    },
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "hex"
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcInputParamsEncoding {
        #[serde(rename = "utf-8")]
        Utf8,
        #[serde(rename = "hex")]
        Hex,
    }

    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcInputParamsEncoding {
        fn from(value: &EthereumPersonalSignRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumPersonalSignRpcInputParamsEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Utf8 => f.write_str("utf-8"),
                Self::Hex => f.write_str("hex"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumPersonalSignRpcInputParamsEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "utf-8" => Ok(Self::Utf8),
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumPersonalSignRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumPersonalSignRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumPersonalSignRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "hex"
    ///          ]
    ///        },
    ///        "signature": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "personal_sign"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumPersonalSignRpcResponse {
        pub data: EthereumPersonalSignRpcResponseData,
        pub method: EthereumPersonalSignRpcResponseMethod,
    }

    impl ::std::convert::From<&EthereumPersonalSignRpcResponse> for EthereumPersonalSignRpcResponse {
        fn from(value: &EthereumPersonalSignRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`EthereumPersonalSignRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "hex"
    ///      ]
    ///    },
    ///    "signature": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumPersonalSignRpcResponseData {
        pub encoding: EthereumPersonalSignRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumPersonalSignRpcResponseData>
        for EthereumPersonalSignRpcResponseData
    {
        fn from(value: &EthereumPersonalSignRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`EthereumPersonalSignRpcResponseDataEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "hex"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }

    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcResponseDataEncoding {
        fn from(value: &EthereumPersonalSignRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumPersonalSignRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumPersonalSignRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumPersonalSignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumPersonalSignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumPersonalSignRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "personal_sign"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumPersonalSignRpcResponseMethod {
        #[serde(rename = "personal_sign")]
        PersonalSign,
    }

    impl ::std::convert::From<&Self> for EthereumPersonalSignRpcResponseMethod {
        fn from(value: &EthereumPersonalSignRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumPersonalSignRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PersonalSign => f.write_str("personal_sign"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumPersonalSignRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "personal_sign" => Ok(Self::PersonalSign),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumPersonalSignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumPersonalSignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumPersonalSignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSecp256k1SignRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "secp256k1_sign"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "hash"
    ///      ],
    ///      "properties": {
    ///        "hash": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSecp256k1SignRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSecp256k1SignRpcInputChainType>,
        pub method: EthereumSecp256k1SignRpcInputMethod,
        pub params: EthereumSecp256k1SignRpcInputParams,
    }

    impl ::std::convert::From<&EthereumSecp256k1SignRpcInput> for EthereumSecp256k1SignRpcInput {
        fn from(value: &EthereumSecp256k1SignRpcInput) -> Self {
            value.clone()
        }
    }

    ///`EthereumSecp256k1SignRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcInputChainType {
        fn from(value: &EthereumSecp256k1SignRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSecp256k1SignRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSecp256k1SignRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSecp256k1SignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSecp256k1SignRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSecp256k1SignRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "secp256k1_sign"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcInputMethod {
        #[serde(rename = "secp256k1_sign")]
        Secp256k1Sign,
    }

    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcInputMethod {
        fn from(value: &EthereumSecp256k1SignRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSecp256k1SignRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Secp256k1Sign => f.write_str("secp256k1_sign"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSecp256k1SignRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "secp256k1_sign" => Ok(Self::Secp256k1Sign),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSecp256k1SignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSecp256k1SignRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSecp256k1SignRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "hash": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSecp256k1SignRpcInputParams {
        pub hash: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumSecp256k1SignRpcInputParams>
        for EthereumSecp256k1SignRpcInputParams
    {
        fn from(value: &EthereumSecp256k1SignRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`EthereumSecp256k1SignRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "hex"
    ///          ]
    ///        },
    ///        "signature": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "secp256k1_sign"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSecp256k1SignRpcResponse {
        pub data: EthereumSecp256k1SignRpcResponseData,
        pub method: EthereumSecp256k1SignRpcResponseMethod,
    }

    impl ::std::convert::From<&EthereumSecp256k1SignRpcResponse> for EthereumSecp256k1SignRpcResponse {
        fn from(value: &EthereumSecp256k1SignRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`EthereumSecp256k1SignRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "hex"
    ///      ]
    ///    },
    ///    "signature": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSecp256k1SignRpcResponseData {
        pub encoding: EthereumSecp256k1SignRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumSecp256k1SignRpcResponseData>
        for EthereumSecp256k1SignRpcResponseData
    {
        fn from(value: &EthereumSecp256k1SignRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`EthereumSecp256k1SignRpcResponseDataEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "hex"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }

    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcResponseDataEncoding {
        fn from(value: &EthereumSecp256k1SignRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSecp256k1SignRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSecp256k1SignRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSecp256k1SignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSecp256k1SignRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSecp256k1SignRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "secp256k1_sign"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSecp256k1SignRpcResponseMethod {
        #[serde(rename = "secp256k1_sign")]
        Secp256k1Sign,
    }

    impl ::std::convert::From<&Self> for EthereumSecp256k1SignRpcResponseMethod {
        fn from(value: &EthereumSecp256k1SignRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSecp256k1SignRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Secp256k1Sign => f.write_str("secp256k1_sign"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSecp256k1SignRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "secp256k1_sign" => Ok(Self::Secp256k1Sign),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSecp256k1SignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSecp256k1SignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSecp256k1SignRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSendTransactionRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "caip2",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "caip2": {
    ///      "type": "string",
    ///      "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_sendTransaction"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "transaction"
    ///      ],
    ///      "properties": {
    ///        "transaction": {
    ///          "type": "object",
    ///          "properties": {
    ///            "chain_id": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "data": {
    ///              "type": "string"
    ///            },
    ///            "from": {
    ///              "type": "string"
    ///            },
    ///            "gas_limit": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "gas_price": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "max_fee_per_gas": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "max_priority_fee_per_gas": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "nonce": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "to": {
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    0.0
    ///                  ]
    ///                },
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    1.0
    ///                  ]
    ///                },
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    2.0
    ///                  ]
    ///                }
    ///              ]
    ///            },
    ///            "value": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "sponsor": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        pub caip2: EthereumSendTransactionRpcInputCaip2,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSendTransactionRpcInputChainType>,
        pub method: EthereumSendTransactionRpcInputMethod,
        pub params: EthereumSendTransactionRpcInputParams,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsor: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcInput> for EthereumSendTransactionRpcInput {
        fn from(value: &EthereumSendTransactionRpcInput) -> Self {
            value.clone()
        }
    }

    ///`EthereumSendTransactionRpcInputCaip2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputCaip2(::std::string::String);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInputCaip2> for ::std::string::String {
        fn from(value: EthereumSendTransactionRpcInputCaip2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcInputCaip2>
        for EthereumSendTransactionRpcInputCaip2
    {
        fn from(value: &EthereumSendTransactionRpcInputCaip2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EthereumSendTransactionRpcInputCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EthereumSendTransactionRpcInputCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`EthereumSendTransactionRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSendTransactionRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputChainType {
        fn from(value: &EthereumSendTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSendTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSendTransactionRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_sendTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSendTransactionRpcInputMethod {
        #[serde(rename = "eth_sendTransaction")]
        EthSendTransaction,
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputMethod {
        fn from(value: &EthereumSendTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSendTransaction => f.write_str("eth_sendTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSendTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sendTransaction" => Ok(Self::EthSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSendTransactionRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "transaction": {
    ///      "type": "object",
    ///      "properties": {
    ///        "chain_id": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "data": {
    ///          "type": "string"
    ///        },
    ///        "from": {
    ///          "type": "string"
    ///        },
    ///        "gas_limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "gas_price": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "max_fee_per_gas": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "max_priority_fee_per_gas": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "nonce": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "to": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "oneOf": [
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                0.0
    ///              ]
    ///            },
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                1.0
    ///              ]
    ///            },
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                2.0
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "value": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcInputParams {
        pub transaction: EthereumSendTransactionRpcInputParamsTransaction,
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcInputParams>
        for EthereumSendTransactionRpcInputParams
    {
        fn from(value: &EthereumSendTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransaction`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chain_id": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "data": {
    ///      "type": "string"
    ///    },
    ///    "from": {
    ///      "type": "string"
    ///    },
    ///    "gas_limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "gas_price": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "max_fee_per_gas": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "max_priority_fee_per_gas": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "nonce": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "to": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "oneOf": [
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            0.0
    ///          ]
    ///        },
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            1.0
    ///          ]
    ///        },
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            2.0
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "value": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcInputParamsTransaction {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionChainId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_limit:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionGasLimit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_price:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionGasPrice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_fee_per_gas:
            ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_priority_fee_per_gas: ::std::option::Option<
            EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce: ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionNonce>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub to: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<EthereumSendTransactionRpcInputParamsTransactionValue>,
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransaction>
        for EthereumSendTransactionRpcInputParamsTransaction
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransaction) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EthereumSendTransactionRpcInputParamsTransaction {
        fn default() -> Self {
            Self {
                chain_id: Default::default(),
                data: Default::default(),
                from: Default::default(),
                gas_limit: Default::default(),
                gas_price: Default::default(),
                max_fee_per_gas: Default::default(),
                max_priority_fee_per_gas: Default::default(),
                nonce: Default::default(),
                to: Default::default(),
                type_: Default::default(),
                value: Default::default(),
            }
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionChainId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionChainId {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionChainId {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionChainId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionChainId {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionGasLimit`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionGasLimit) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionGasPrice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionGasPrice) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(
            value: &EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionNonce`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionNonce {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionNonce {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionNonce) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionNonce {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        0.0
    ///      ]
    ///    },
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        1.0
    ///      ]
    ///    },
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        2.0
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionType {
        Variant0(EthereumSendTransactionRpcInputParamsTransactionTypeVariant0),
        Variant1(EthereumSendTransactionRpcInputParamsTransactionTypeVariant1),
        Variant2(EthereumSendTransactionRpcInputParamsTransactionTypeVariant2),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionType {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeVariant0>
        for EthereumSendTransactionRpcInputParamsTransactionType
    {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeVariant0) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeVariant1>
        for EthereumSendTransactionRpcInputParamsTransactionType
    {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeVariant2>
        for EthereumSendTransactionRpcInputParamsTransactionType
    {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeVariant2) -> Self {
            Self::Variant2(value)
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionTypeVariant0`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    0.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputParamsTransactionTypeVariant0(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputParamsTransactionTypeVariant0 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeVariant0> for f64 {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeVariant0) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransactionTypeVariant0>
        for EthereumSendTransactionRpcInputParamsTransactionTypeVariant0
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionTypeVariant0) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64> for EthereumSendTransactionRpcInputParamsTransactionTypeVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![0.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcInputParamsTransactionTypeVariant0
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionTypeVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    1.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputParamsTransactionTypeVariant1(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputParamsTransactionTypeVariant1 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeVariant1> for f64 {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeVariant1) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransactionTypeVariant1>
        for EthereumSendTransactionRpcInputParamsTransactionTypeVariant1
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionTypeVariant1) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64> for EthereumSendTransactionRpcInputParamsTransactionTypeVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![1.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcInputParamsTransactionTypeVariant1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionTypeVariant2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    2.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcInputParamsTransactionTypeVariant2(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcInputParamsTransactionTypeVariant2 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInputParamsTransactionTypeVariant2> for f64 {
        fn from(value: EthereumSendTransactionRpcInputParamsTransactionTypeVariant2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcInputParamsTransactionTypeVariant2>
        for EthereumSendTransactionRpcInputParamsTransactionTypeVariant2
    {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionTypeVariant2) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64> for EthereumSendTransactionRpcInputParamsTransactionTypeVariant2 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![2.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcInputParamsTransactionTypeVariant2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSendTransactionRpcInputParamsTransactionValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcInputParamsTransactionValue {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcInputParamsTransactionValue {
        fn from(value: &EthereumSendTransactionRpcInputParamsTransactionValue) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcInputParamsTransactionValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcInputParamsTransactionValue {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "caip2",
    ///        "hash"
    ///      ],
    ///      "properties": {
    ///        "caip2": {
    ///          "type": "string",
    ///          "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///        },
    ///        "hash": {
    ///          "type": "string"
    ///        },
    ///        "transaction_id": {
    ///          "type": "string"
    ///        },
    ///        "transaction_request": {
    ///          "type": "object",
    ///          "properties": {
    ///            "chain_id": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "data": {
    ///              "type": "string"
    ///            },
    ///            "from": {
    ///              "type": "string"
    ///            },
    ///            "gas_limit": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "gas_price": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "max_fee_per_gas": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "max_priority_fee_per_gas": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "nonce": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "to": {
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    0.0
    ///                  ]
    ///                },
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    1.0
    ///                  ]
    ///                },
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    2.0
    ///                  ]
    ///                }
    ///              ]
    ///            },
    ///            "value": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_sendTransaction"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcResponse {
        pub data: EthereumSendTransactionRpcResponseData,
        pub method: EthereumSendTransactionRpcResponseMethod,
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcResponse>
        for EthereumSendTransactionRpcResponse
    {
        fn from(value: &EthereumSendTransactionRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`EthereumSendTransactionRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "caip2",
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "caip2": {
    ///      "type": "string",
    ///      "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///    },
    ///    "hash": {
    ///      "type": "string"
    ///    },
    ///    "transaction_id": {
    ///      "type": "string"
    ///    },
    ///    "transaction_request": {
    ///      "type": "object",
    ///      "properties": {
    ///        "chain_id": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "data": {
    ///          "type": "string"
    ///        },
    ///        "from": {
    ///          "type": "string"
    ///        },
    ///        "gas_limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "gas_price": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "max_fee_per_gas": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "max_priority_fee_per_gas": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "nonce": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "to": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "oneOf": [
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                0.0
    ///              ]
    ///            },
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                1.0
    ///              ]
    ///            },
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                2.0
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "value": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcResponseData {
        pub caip2: EthereumSendTransactionRpcResponseDataCaip2,
        pub hash: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_request:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequest>,
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcResponseData>
        for EthereumSendTransactionRpcResponseData
    {
        fn from(value: &EthereumSendTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`EthereumSendTransactionRpcResponseDataCaip2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataCaip2(::std::string::String);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataCaip2> for ::std::string::String {
        fn from(value: EthereumSendTransactionRpcResponseDataCaip2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataCaip2>
        for EthereumSendTransactionRpcResponseDataCaip2
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataCaip2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EthereumSendTransactionRpcResponseDataCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcResponseDataCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EthereumSendTransactionRpcResponseDataCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chain_id": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "data": {
    ///      "type": "string"
    ///    },
    ///    "from": {
    ///      "type": "string"
    ///    },
    ///    "gas_limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "gas_price": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "max_fee_per_gas": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "max_priority_fee_per_gas": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "nonce": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "to": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "oneOf": [
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            0.0
    ///          ]
    ///        },
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            1.0
    ///          ]
    ///        },
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            2.0
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "value": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequest {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestChainId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_limit:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_price:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_fee_per_gas: ::std::option::Option<
            EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_priority_fee_per_gas: ::std::option::Option<
            EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestNonce>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub to: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value:
            ::std::option::Option<EthereumSendTransactionRpcResponseDataTransactionRequestValue>,
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequest>
        for EthereumSendTransactionRpcResponseDataTransactionRequest
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EthereumSendTransactionRpcResponseDataTransactionRequest {
        fn default() -> Self {
            Self {
                chain_id: Default::default(),
                data: Default::default(),
                from: Default::default(),
                gas_limit: Default::default(),
                gas_price: Default::default(),
                max_fee_per_gas: Default::default(),
                max_priority_fee_per_gas: Default::default(),
                nonce: Default::default(),
                to: Default::default(),
                type_: Default::default(),
                value: Default::default(),
            }
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestChainId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestChainId {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestChainId
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestChainId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcResponseDataTransactionRequestChainId {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasLimit
    {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice
    {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestGasPrice
    {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestMaxPriorityFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestNonce`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestNonce) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcResponseDataTransactionRequestNonce {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        0.0
    ///      ]
    ///    },
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        1.0
    ///      ]
    ///    },
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        2.0
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestType {
        Variant0(EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0),
        Variant1(EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1),
        Variant2(EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcResponseDataTransactionRequestType {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestType) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0>
        for EthereumSendTransactionRpcResponseDataTransactionRequestType
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0,
        ) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1>
        for EthereumSendTransactionRpcResponseDataTransactionRequestType
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1,
        ) -> Self {
            Self::Variant1(value)
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2>
        for EthereumSendTransactionRpcResponseDataTransactionRequestType
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2,
        ) -> Self {
            Self::Variant2(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    0.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0>
        for f64
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0,
        ) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0
    {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![0.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant0
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    1.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1>
        for f64
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1,
        ) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![1.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    2.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2(f64);
    impl ::std::ops::Deref for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2>
        for f64
    {
        fn from(
            value: EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2,
        ) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2
    {
        fn from(
            value: &EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![2.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSendTransactionRpcResponseDataTransactionRequestTypeVariant2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSendTransactionRpcResponseDataTransactionRequestValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        fn from(value: &EthereumSendTransactionRpcResponseDataTransactionRequestValue) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSendTransactionRpcResponseDataTransactionRequestValue {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSendTransactionRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_sendTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSendTransactionRpcResponseMethod {
        #[serde(rename = "eth_sendTransaction")]
        EthSendTransaction,
    }

    impl ::std::convert::From<&Self> for EthereumSendTransactionRpcResponseMethod {
        fn from(value: &EthereumSendTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSendTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSendTransaction => f.write_str("eth_sendTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSendTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sendTransaction" => Ok(Self::EthSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSign7702AuthorizationRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_sign7702Authorization"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "chain_id",
    ///        "contract"
    ///      ],
    ///      "properties": {
    ///        "chain_id": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "contract": {
    ///          "type": "string"
    ///        },
    ///        "nonce": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSign7702AuthorizationRpcInputChainType>,
        pub method: EthereumSign7702AuthorizationRpcInputMethod,
        pub params: EthereumSign7702AuthorizationRpcInputParams,
    }

    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcInput>
        for EthereumSign7702AuthorizationRpcInput
    {
        fn from(value: &EthereumSign7702AuthorizationRpcInput) -> Self {
            value.clone()
        }
    }

    ///`EthereumSign7702AuthorizationRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSign7702AuthorizationRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputChainType {
        fn from(value: &EthereumSign7702AuthorizationRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSign7702AuthorizationRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSign7702AuthorizationRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSign7702AuthorizationRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSign7702AuthorizationRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSign7702AuthorizationRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_sign7702Authorization"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSign7702AuthorizationRpcInputMethod {
        #[serde(rename = "eth_sign7702Authorization")]
        EthSign7702Authorization,
    }

    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputMethod {
        fn from(value: &EthereumSign7702AuthorizationRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSign7702Authorization => f.write_str("eth_sign7702Authorization"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSign7702AuthorizationRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sign7702Authorization" => Ok(Self::EthSign7702Authorization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSign7702AuthorizationRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSign7702AuthorizationRpcInputMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSign7702AuthorizationRpcInputMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSign7702AuthorizationRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "chain_id",
    ///    "contract"
    ///  ],
    ///  "properties": {
    ///    "chain_id": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "contract": {
    ///      "type": "string"
    ///    },
    ///    "nonce": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcInputParams {
        pub chain_id: EthereumSign7702AuthorizationRpcInputParamsChainId,
        pub contract: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce: ::std::option::Option<EthereumSign7702AuthorizationRpcInputParamsNonce>,
    }

    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcInputParams>
        for EthereumSign7702AuthorizationRpcInputParams
    {
        fn from(value: &EthereumSign7702AuthorizationRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`EthereumSign7702AuthorizationRpcInputParamsChainId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcInputParamsChainId {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputParamsChainId {
        fn from(value: &EthereumSign7702AuthorizationRpcInputParamsChainId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputParamsChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSign7702AuthorizationRpcInputParamsChainId {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSign7702AuthorizationRpcInputParamsNonce`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcInputParamsNonce {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcInputParamsNonce {
        fn from(value: &EthereumSign7702AuthorizationRpcInputParamsNonce) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcInputParamsNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSign7702AuthorizationRpcInputParamsNonce {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSign7702AuthorizationRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "authorization"
    ///      ],
    ///      "properties": {
    ///        "authorization": {
    ///          "type": "object",
    ///          "required": [
    ///            "chain_id",
    ///            "contract",
    ///            "nonce",
    ///            "r",
    ///            "s",
    ///            "y_parity"
    ///          ],
    ///          "properties": {
    ///            "chain_id": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "contract": {
    ///              "type": "string"
    ///            },
    ///            "nonce": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "r": {
    ///              "type": "string"
    ///            },
    ///            "s": {
    ///              "type": "string"
    ///            },
    ///            "y_parity": {
    ///              "type": "number"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_sign7702Authorization"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcResponse {
        pub data: EthereumSign7702AuthorizationRpcResponseData,
        pub method: EthereumSign7702AuthorizationRpcResponseMethod,
    }

    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcResponse>
        for EthereumSign7702AuthorizationRpcResponse
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`EthereumSign7702AuthorizationRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "authorization"
    ///  ],
    ///  "properties": {
    ///    "authorization": {
    ///      "type": "object",
    ///      "required": [
    ///        "chain_id",
    ///        "contract",
    ///        "nonce",
    ///        "r",
    ///        "s",
    ///        "y_parity"
    ///      ],
    ///      "properties": {
    ///        "chain_id": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "contract": {
    ///          "type": "string"
    ///        },
    ///        "nonce": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "r": {
    ///          "type": "string"
    ///        },
    ///        "s": {
    ///          "type": "string"
    ///        },
    ///        "y_parity": {
    ///          "type": "number"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcResponseData {
        pub authorization: EthereumSign7702AuthorizationRpcResponseDataAuthorization,
    }

    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcResponseData>
        for EthereumSign7702AuthorizationRpcResponseData
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`EthereumSign7702AuthorizationRpcResponseDataAuthorization`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "chain_id",
    ///    "contract",
    ///    "nonce",
    ///    "r",
    ///    "s",
    ///    "y_parity"
    ///  ],
    ///  "properties": {
    ///    "chain_id": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "contract": {
    ///      "type": "string"
    ///    },
    ///    "nonce": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "r": {
    ///      "type": "string"
    ///    },
    ///    "s": {
    ///      "type": "string"
    ///    },
    ///    "y_parity": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSign7702AuthorizationRpcResponseDataAuthorization {
        pub chain_id: EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId,
        pub contract: ::std::string::String,
        pub nonce: EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce,
        pub r: ::std::string::String,
        pub s: ::std::string::String,
        pub y_parity: f64,
    }

    impl ::std::convert::From<&EthereumSign7702AuthorizationRpcResponseDataAuthorization>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorization
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseDataAuthorization) -> Self {
            value.clone()
        }
    }

    ///`EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorizationChainId
    {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce
    {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSign7702AuthorizationRpcResponseDataAuthorizationNonce {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSign7702AuthorizationRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_sign7702Authorization"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSign7702AuthorizationRpcResponseMethod {
        #[serde(rename = "eth_sign7702Authorization")]
        EthSign7702Authorization,
    }

    impl ::std::convert::From<&Self> for EthereumSign7702AuthorizationRpcResponseMethod {
        fn from(value: &EthereumSign7702AuthorizationRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSign7702AuthorizationRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSign7702Authorization => f.write_str("eth_sign7702Authorization"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSign7702AuthorizationRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sign7702Authorization" => Ok(Self::EthSign7702Authorization),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSign7702AuthorizationRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSign7702AuthorizationRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSign7702AuthorizationRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTransactionRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_signTransaction"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "transaction"
    ///      ],
    ///      "properties": {
    ///        "transaction": {
    ///          "type": "object",
    ///          "properties": {
    ///            "chain_id": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "data": {
    ///              "type": "string"
    ///            },
    ///            "from": {
    ///              "type": "string"
    ///            },
    ///            "gas_limit": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "gas_price": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "max_fee_per_gas": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "max_priority_fee_per_gas": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "nonce": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            },
    ///            "to": {
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    0.0
    ///                  ]
    ///                },
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    1.0
    ///                  ]
    ///                },
    ///                {
    ///                  "type": "number",
    ///                  "enum": [
    ///                    2.0
    ///                  ]
    ///                }
    ///              ]
    ///            },
    ///            "value": {
    ///              "oneOf": [
    ///                {
    ///                  "type": "string"
    ///                },
    ///                {
    ///                  "type": "integer",
    ///                  "maximum": 9007199254740991.0,
    ///                  "minimum": -9007199254740991.0
    ///                }
    ///              ]
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSignTransactionRpcInputChainType>,
        pub method: EthereumSignTransactionRpcInputMethod,
        pub params: EthereumSignTransactionRpcInputParams,
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcInput> for EthereumSignTransactionRpcInput {
        fn from(value: &EthereumSignTransactionRpcInput) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTransactionRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputChainType {
        fn from(value: &EthereumSignTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTransactionRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_signTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcInputMethod {
        #[serde(rename = "eth_signTransaction")]
        EthSignTransaction,
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputMethod {
        fn from(value: &EthereumSignTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTransaction => f.write_str("eth_signTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTransaction" => Ok(Self::EthSignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTransactionRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "transaction": {
    ///      "type": "object",
    ///      "properties": {
    ///        "chain_id": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "data": {
    ///          "type": "string"
    ///        },
    ///        "from": {
    ///          "type": "string"
    ///        },
    ///        "gas_limit": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "gas_price": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "max_fee_per_gas": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "max_priority_fee_per_gas": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "nonce": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        },
    ///        "to": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "oneOf": [
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                0.0
    ///              ]
    ///            },
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                1.0
    ///              ]
    ///            },
    ///            {
    ///              "type": "number",
    ///              "enum": [
    ///                2.0
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "value": {
    ///          "oneOf": [
    ///            {
    ///              "type": "string"
    ///            },
    ///            {
    ///              "type": "integer",
    ///              "maximum": 9007199254740991.0,
    ///              "minimum": -9007199254740991.0
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcInputParams {
        pub transaction: EthereumSignTransactionRpcInputParamsTransaction,
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcInputParams>
        for EthereumSignTransactionRpcInputParams
    {
        fn from(value: &EthereumSignTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransaction`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "chain_id": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "data": {
    ///      "type": "string"
    ///    },
    ///    "from": {
    ///      "type": "string"
    ///    },
    ///    "gas_limit": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "gas_price": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "max_fee_per_gas": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "max_priority_fee_per_gas": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "nonce": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    },
    ///    "to": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "oneOf": [
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            0.0
    ///          ]
    ///        },
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            1.0
    ///          ]
    ///        },
    ///        {
    ///          "type": "number",
    ///          "enum": [
    ///            2.0
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "value": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "integer",
    ///          "maximum": 9007199254740991.0,
    ///          "minimum": -9007199254740991.0
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcInputParamsTransaction {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionChainId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub data: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub from: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_limit:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionGasLimit>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub gas_price:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionGasPrice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_fee_per_gas:
            ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max_priority_fee_per_gas: ::std::option::Option<
            EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub nonce: ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionNonce>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub to: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionType>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub value: ::std::option::Option<EthereumSignTransactionRpcInputParamsTransactionValue>,
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransaction>
        for EthereumSignTransactionRpcInputParamsTransaction
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransaction) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EthereumSignTransactionRpcInputParamsTransaction {
        fn default() -> Self {
            Self {
                chain_id: Default::default(),
                data: Default::default(),
                from: Default::default(),
                gas_limit: Default::default(),
                gas_price: Default::default(),
                max_fee_per_gas: Default::default(),
                max_priority_fee_per_gas: Default::default(),
                nonce: Default::default(),
                to: Default::default(),
                type_: Default::default(),
                value: Default::default(),
            }
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionChainId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionChainId {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionChainId {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionChainId) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionChainId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionChainId {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionGasLimit`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionGasLimit) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionGasLimit {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionGasPrice`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionGasPrice) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionGasPrice {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionMaxFeePerGas {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self>
        for EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(
            value: &EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64>
        for EthereumSignTransactionRpcInputParamsTransactionMaxPriorityFeePerGas
    {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionNonce`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionNonce {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionNonce {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionNonce) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionNonce {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionNonce {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        0.0
    ///      ]
    ///    },
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        1.0
    ///      ]
    ///    },
    ///    {
    ///      "type": "number",
    ///      "enum": [
    ///        2.0
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionType {
        Variant0(EthereumSignTransactionRpcInputParamsTransactionTypeVariant0),
        Variant1(EthereumSignTransactionRpcInputParamsTransactionTypeVariant1),
        Variant2(EthereumSignTransactionRpcInputParamsTransactionTypeVariant2),
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionType {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionType) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeVariant0>
        for EthereumSignTransactionRpcInputParamsTransactionType
    {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeVariant0) -> Self {
            Self::Variant0(value)
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeVariant1>
        for EthereumSignTransactionRpcInputParamsTransactionType
    {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeVariant2>
        for EthereumSignTransactionRpcInputParamsTransactionType
    {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeVariant2) -> Self {
            Self::Variant2(value)
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionTypeVariant0`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    0.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSignTransactionRpcInputParamsTransactionTypeVariant0(f64);
    impl ::std::ops::Deref for EthereumSignTransactionRpcInputParamsTransactionTypeVariant0 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeVariant0> for f64 {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeVariant0) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransactionTypeVariant0>
        for EthereumSignTransactionRpcInputParamsTransactionTypeVariant0
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionTypeVariant0) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64> for EthereumSignTransactionRpcInputParamsTransactionTypeVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![0.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSignTransactionRpcInputParamsTransactionTypeVariant0
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionTypeVariant1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    1.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSignTransactionRpcInputParamsTransactionTypeVariant1(f64);
    impl ::std::ops::Deref for EthereumSignTransactionRpcInputParamsTransactionTypeVariant1 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeVariant1> for f64 {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeVariant1) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransactionTypeVariant1>
        for EthereumSignTransactionRpcInputParamsTransactionTypeVariant1
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionTypeVariant1) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64> for EthereumSignTransactionRpcInputParamsTransactionTypeVariant1 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![1.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSignTransactionRpcInputParamsTransactionTypeVariant1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionTypeVariant2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "number",
    ///  "enum": [
    ///    2.0
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct EthereumSignTransactionRpcInputParamsTransactionTypeVariant2(f64);
    impl ::std::ops::Deref for EthereumSignTransactionRpcInputParamsTransactionTypeVariant2 {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcInputParamsTransactionTypeVariant2> for f64 {
        fn from(value: EthereumSignTransactionRpcInputParamsTransactionTypeVariant2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcInputParamsTransactionTypeVariant2>
        for EthereumSignTransactionRpcInputParamsTransactionTypeVariant2
    {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionTypeVariant2) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<f64> for EthereumSignTransactionRpcInputParamsTransactionTypeVariant2 {
        type Error = self::error::ConversionError;
        fn try_from(value: f64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![2.0_f64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for EthereumSignTransactionRpcInputParamsTransactionTypeVariant2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<f64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    ///`EthereumSignTransactionRpcInputParamsTransactionValue`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "integer",
    ///      "maximum": 9007199254740991.0,
    ///      "minimum": -9007199254740991.0
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum EthereumSignTransactionRpcInputParamsTransactionValue {
        String(::std::string::String),
        Integer(i64),
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcInputParamsTransactionValue {
        fn from(value: &EthereumSignTransactionRpcInputParamsTransactionValue) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcInputParamsTransactionValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::String(x) => x.fmt(f),
                Self::Integer(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<i64> for EthereumSignTransactionRpcInputParamsTransactionValue {
        fn from(value: i64) -> Self {
            Self::Integer(value)
        }
    }

    ///`EthereumSignTransactionRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "signed_transaction"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "rlp"
    ///          ]
    ///        },
    ///        "signed_transaction": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_signTransaction"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcResponse {
        pub data: EthereumSignTransactionRpcResponseData,
        pub method: EthereumSignTransactionRpcResponseMethod,
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcResponse>
        for EthereumSignTransactionRpcResponse
    {
        fn from(value: &EthereumSignTransactionRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTransactionRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "signed_transaction"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "rlp"
    ///      ]
    ///    },
    ///    "signed_transaction": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTransactionRpcResponseData {
        pub encoding: EthereumSignTransactionRpcResponseDataEncoding,
        pub signed_transaction: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumSignTransactionRpcResponseData>
        for EthereumSignTransactionRpcResponseData
    {
        fn from(value: &EthereumSignTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTransactionRpcResponseDataEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "rlp"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcResponseDataEncoding {
        #[serde(rename = "rlp")]
        Rlp,
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcResponseDataEncoding {
        fn from(value: &EthereumSignTransactionRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Rlp => f.write_str("rlp"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTransactionRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "rlp" => Ok(Self::Rlp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTransactionRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_signTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTransactionRpcResponseMethod {
        #[serde(rename = "eth_signTransaction")]
        EthSignTransaction,
    }

    impl ::std::convert::From<&Self> for EthereumSignTransactionRpcResponseMethod {
        fn from(value: &EthereumSignTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTransaction => f.write_str("eth_signTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTransaction" => Ok(Self::EthSignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTypedDataRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_signTypedData_v4"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "typed_data"
    ///      ],
    ///      "properties": {
    ///        "typed_data": {
    ///          "type": "object",
    ///          "required": [
    ///            "domain",
    ///            "message",
    ///            "primary_type",
    ///            "types"
    ///          ],
    ///          "properties": {
    ///            "domain": {
    ///              "type": "object",
    ///              "additionalProperties": {}
    ///            },
    ///            "message": {
    ///              "type": "object",
    ///              "additionalProperties": {}
    ///            },
    ///            "primary_type": {
    ///              "type": "string"
    ///            },
    ///            "types": {
    ///              "type": "object",
    ///              "additionalProperties": {
    ///                "type": "array",
    ///                "items": {
    ///                  "type": "object",
    ///                  "required": [
    ///                    "name",
    ///                    "type"
    ///                  ],
    ///                  "properties": {
    ///                    "name": {
    ///                      "type": "string"
    ///                    },
    ///                    "type": {
    ///                      "type": "string"
    ///                    }
    ///                  }
    ///                }
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<EthereumSignTypedDataRpcInputChainType>,
        pub method: EthereumSignTypedDataRpcInputMethod,
        pub params: EthereumSignTypedDataRpcInputParams,
    }

    impl ::std::convert::From<&EthereumSignTypedDataRpcInput> for EthereumSignTypedDataRpcInput {
        fn from(value: &EthereumSignTypedDataRpcInput) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTypedDataRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcInputChainType {
        fn from(value: &EthereumSignTypedDataRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTypedDataRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTypedDataRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTypedDataRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTypedDataRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTypedDataRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_signTypedData_v4"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcInputMethod {
        #[serde(rename = "eth_signTypedData_v4")]
        EthSignTypedDataV4,
    }

    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcInputMethod {
        fn from(value: &EthereumSignTypedDataRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTypedDataRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTypedDataV4 => f.write_str("eth_signTypedData_v4"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTypedDataRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTypedData_v4" => Ok(Self::EthSignTypedDataV4),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTypedDataRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTypedDataRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTypedDataRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "typed_data"
    ///  ],
    ///  "properties": {
    ///    "typed_data": {
    ///      "type": "object",
    ///      "required": [
    ///        "domain",
    ///        "message",
    ///        "primary_type",
    ///        "types"
    ///      ],
    ///      "properties": {
    ///        "domain": {
    ///          "type": "object",
    ///          "additionalProperties": {}
    ///        },
    ///        "message": {
    ///          "type": "object",
    ///          "additionalProperties": {}
    ///        },
    ///        "primary_type": {
    ///          "type": "string"
    ///        },
    ///        "types": {
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "name",
    ///                "type"
    ///              ],
    ///              "properties": {
    ///                "name": {
    ///                  "type": "string"
    ///                },
    ///                "type": {
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcInputParams {
        pub typed_data: EthereumSignTypedDataRpcInputParamsTypedData,
    }

    impl ::std::convert::From<&EthereumSignTypedDataRpcInputParams>
        for EthereumSignTypedDataRpcInputParams
    {
        fn from(value: &EthereumSignTypedDataRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTypedDataRpcInputParamsTypedData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "domain",
    ///    "message",
    ///    "primary_type",
    ///    "types"
    ///  ],
    ///  "properties": {
    ///    "domain": {
    ///      "type": "object",
    ///      "additionalProperties": {}
    ///    },
    ///    "message": {
    ///      "type": "object",
    ///      "additionalProperties": {}
    ///    },
    ///    "primary_type": {
    ///      "type": "string"
    ///    },
    ///    "types": {
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "array",
    ///        "items": {
    ///          "type": "object",
    ///          "required": [
    ///            "name",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "name": {
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcInputParamsTypedData {
        pub domain: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub message: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        pub primary_type: ::std::string::String,
        pub types: ::std::collections::HashMap<
            ::std::string::String,
            ::std::vec::Vec<EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem>,
        >,
    }

    impl ::std::convert::From<&EthereumSignTypedDataRpcInputParamsTypedData>
        for EthereumSignTypedDataRpcInputParamsTypedData
    {
        fn from(value: &EthereumSignTypedDataRpcInputParamsTypedData) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem {
        pub name: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem>
        for EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem
    {
        fn from(value: &EthereumSignTypedDataRpcInputParamsTypedDataTypesValueItem) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTypedDataRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "hex"
    ///          ]
    ///        },
    ///        "signature": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "eth_signTypedData_v4"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcResponse {
        pub data: EthereumSignTypedDataRpcResponseData,
        pub method: EthereumSignTypedDataRpcResponseMethod,
    }

    impl ::std::convert::From<&EthereumSignTypedDataRpcResponse> for EthereumSignTypedDataRpcResponse {
        fn from(value: &EthereumSignTypedDataRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTypedDataRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "hex"
    ///      ]
    ///    },
    ///    "signature": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumSignTypedDataRpcResponseData {
        pub encoding: EthereumSignTypedDataRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumSignTypedDataRpcResponseData>
        for EthereumSignTypedDataRpcResponseData
    {
        fn from(value: &EthereumSignTypedDataRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`EthereumSignTypedDataRpcResponseDataEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "hex"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }

    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcResponseDataEncoding {
        fn from(value: &EthereumSignTypedDataRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTypedDataRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTypedDataRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumSignTypedDataRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumSignTypedDataRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumSignTypedDataRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_signTypedData_v4"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumSignTypedDataRpcResponseMethod {
        #[serde(rename = "eth_signTypedData_v4")]
        EthSignTypedDataV4,
    }

    impl ::std::convert::From<&Self> for EthereumSignTypedDataRpcResponseMethod {
        fn from(value: &EthereumSignTypedDataRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumSignTypedDataRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSignTypedDataV4 => f.write_str("eth_signTypedData_v4"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumSignTypedDataRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_signTypedData_v4" => Ok(Self::EthSignTypedDataV4),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumSignTypedDataRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumSignTypedDataRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumSignTypedDataRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The verbatim Ethereum transaction object in an eth_signTransaction or
    /// eth_sendTransaction request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "ethereum_transaction",
    ///  "description": "The verbatim Ethereum transaction object in an
    /// eth_signTransaction or eth_sendTransaction request.",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "title": "EthereumTransactionConditionField",
    ///      "type": "string",
    ///      "enum": [
    ///        "to",
    ///        "value"
    ///      ]
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum_transaction"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTransactionCondition {
        pub field: EthereumTransactionConditionField,
        pub field_source: EthereumTransactionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&EthereumTransactionCondition> for EthereumTransactionCondition {
        fn from(value: &EthereumTransactionCondition) -> Self {
            value.clone()
        }
    }

    ///`EthereumTransactionConditionField`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EthereumTransactionConditionField",
    ///  "type": "string",
    ///  "enum": [
    ///    "to",
    ///    "value"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTransactionConditionField {
        #[serde(rename = "to")]
        To,
        #[serde(rename = "value")]
        Value,
    }

    impl ::std::convert::From<&Self> for EthereumTransactionConditionField {
        fn from(value: &EthereumTransactionConditionField) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumTransactionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::To => f.write_str("to"),
                Self::Value => f.write_str("value"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumTransactionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "to" => Ok(Self::To),
                "value" => Ok(Self::Value),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumTransactionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumTransactionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumTransactionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumTransactionConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum_transaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTransactionConditionFieldSource {
        #[serde(rename = "ethereum_transaction")]
        EthereumTransaction,
    }

    impl ::std::convert::From<&Self> for EthereumTransactionConditionFieldSource {
        fn from(value: &EthereumTransactionConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumTransactionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumTransaction => f.write_str("ethereum_transaction"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumTransactionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_transaction" => Ok(Self::EthereumTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumTransactionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumTransactionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumTransactionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Attributes from the signing domain that will verify the signature.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "ethereum_typed_data_domain",
    ///  "description": "Attributes from the signing domain that will verify the
    /// signature.",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "title": "EthereumTypedDataDomainConditionField",
    ///      "type": "string",
    ///      "enum": [
    ///        "chainId",
    ///        "verifyingContract"
    ///      ]
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum_typed_data_domain"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataDomainCondition {
        pub field: EthereumTypedDataDomainConditionField,
        pub field_source: EthereumTypedDataDomainConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&EthereumTypedDataDomainCondition> for EthereumTypedDataDomainCondition {
        fn from(value: &EthereumTypedDataDomainCondition) -> Self {
            value.clone()
        }
    }

    ///`EthereumTypedDataDomainConditionField`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "EthereumTypedDataDomainConditionField",
    ///  "type": "string",
    ///  "enum": [
    ///    "chainId",
    ///    "verifyingContract"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTypedDataDomainConditionField {
        #[serde(rename = "chainId")]
        ChainId,
        #[serde(rename = "verifyingContract")]
        VerifyingContract,
    }

    impl ::std::convert::From<&Self> for EthereumTypedDataDomainConditionField {
        fn from(value: &EthereumTypedDataDomainConditionField) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumTypedDataDomainConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ChainId => f.write_str("chainId"),
                Self::VerifyingContract => f.write_str("verifyingContract"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumTypedDataDomainConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "chainId" => Ok(Self::ChainId),
                "verifyingContract" => Ok(Self::VerifyingContract),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumTypedDataDomainConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for EthereumTypedDataDomainConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for EthereumTypedDataDomainConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumTypedDataDomainConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum_typed_data_domain"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTypedDataDomainConditionFieldSource {
        #[serde(rename = "ethereum_typed_data_domain")]
        EthereumTypedDataDomain,
    }

    impl ::std::convert::From<&Self> for EthereumTypedDataDomainConditionFieldSource {
        fn from(value: &EthereumTypedDataDomainConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumTypedDataDomainConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumTypedDataDomain => f.write_str("ethereum_typed_data_domain"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumTypedDataDomainConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_typed_data_domain" => Ok(Self::EthereumTypedDataDomain),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumTypedDataDomainConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumTypedDataDomainConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumTypedDataDomainConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///'types' and 'primary_type' attributes of the TypedData JSON object
    /// defined in EIP-712.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "ethereum_typed_data_message",
    ///  "description": "'types' and 'primary_type' attributes of the TypedData
    /// JSON object defined in EIP-712.",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "typed_data",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "title": "EthereumTypedDataMessageConditionField",
    ///      "type": "string"
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum_typed_data_message"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "typed_data": {
    ///      "type": "object",
    ///      "required": [
    ///        "primary_type",
    ///        "types"
    ///      ],
    ///      "properties": {
    ///        "primary_type": {
    ///          "type": "string"
    ///        },
    ///        "types": {
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "object",
    ///              "required": [
    ///                "name",
    ///                "type"
    ///              ],
    ///              "properties": {
    ///                "name": {
    ///                  "type": "string"
    ///                },
    ///                "type": {
    ///                  "type": "string"
    ///                }
    ///              }
    ///            }
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataMessageCondition {
        pub field: ::std::string::String,
        pub field_source: EthereumTypedDataMessageConditionFieldSource,
        pub operator: ConditionOperator,
        pub typed_data: EthereumTypedDataMessageConditionTypedData,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&EthereumTypedDataMessageCondition>
        for EthereumTypedDataMessageCondition
    {
        fn from(value: &EthereumTypedDataMessageCondition) -> Self {
            value.clone()
        }
    }

    ///`EthereumTypedDataMessageConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum_typed_data_message"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EthereumTypedDataMessageConditionFieldSource {
        #[serde(rename = "ethereum_typed_data_message")]
        EthereumTypedDataMessage,
    }

    impl ::std::convert::From<&Self> for EthereumTypedDataMessageConditionFieldSource {
        fn from(value: &EthereumTypedDataMessageConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for EthereumTypedDataMessageConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthereumTypedDataMessage => f.write_str("ethereum_typed_data_message"),
            }
        }
    }

    impl ::std::str::FromStr for EthereumTypedDataMessageConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum_typed_data_message" => Ok(Self::EthereumTypedDataMessage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for EthereumTypedDataMessageConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for EthereumTypedDataMessageConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for EthereumTypedDataMessageConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`EthereumTypedDataMessageConditionTypedData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "primary_type",
    ///    "types"
    ///  ],
    ///  "properties": {
    ///    "primary_type": {
    ///      "type": "string"
    ///    },
    ///    "types": {
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "array",
    ///        "items": {
    ///          "type": "object",
    ///          "required": [
    ///            "name",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "name": {
    ///              "type": "string"
    ///            },
    ///            "type": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataMessageConditionTypedData {
        pub primary_type: ::std::string::String,
        pub types: ::std::collections::HashMap<
            ::std::string::String,
            ::std::vec::Vec<EthereumTypedDataMessageConditionTypedDataTypesValueItem>,
        >,
    }

    impl ::std::convert::From<&EthereumTypedDataMessageConditionTypedData>
        for EthereumTypedDataMessageConditionTypedData
    {
        fn from(value: &EthereumTypedDataMessageConditionTypedData) -> Self {
            value.clone()
        }
    }

    ///`EthereumTypedDataMessageConditionTypedDataTypesValueItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthereumTypedDataMessageConditionTypedDataTypesValueItem {
        pub name: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&EthereumTypedDataMessageConditionTypedDataTypesValueItem>
        for EthereumTypedDataMessageConditionTypedDataTypesValueItem
    {
        fn from(value: &EthereumTypedDataMessageConditionTypedDataTypesValueItem) -> Self {
            value.clone()
        }
    }

    ///`GetPolicyPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetPolicyPolicyId(::std::string::String);
    impl ::std::ops::Deref for GetPolicyPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<GetPolicyPolicyId> for ::std::string::String {
        fn from(value: GetPolicyPolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&GetPolicyPolicyId> for GetPolicyPolicyId {
        fn from(value: &GetPolicyPolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GetPolicyPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GetPolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetPolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetPolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GetPolicyPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`GetPolicyRulePolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetPolicyRulePolicyId(::std::string::String);
    impl ::std::ops::Deref for GetPolicyRulePolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<GetPolicyRulePolicyId> for ::std::string::String {
        fn from(value: GetPolicyRulePolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&GetPolicyRulePolicyId> for GetPolicyRulePolicyId {
        fn from(value: &GetPolicyRulePolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GetPolicyRulePolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GetPolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetPolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetPolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GetPolicyRulePolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`GetPolicyRuleRuleId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetPolicyRuleRuleId(::std::string::String);
    impl ::std::ops::Deref for GetPolicyRuleRuleId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<GetPolicyRuleRuleId> for ::std::string::String {
        fn from(value: GetPolicyRuleRuleId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&GetPolicyRuleRuleId> for GetPolicyRuleRuleId {
        fn from(value: &GetPolicyRuleRuleId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GetPolicyRuleRuleId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GetPolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetPolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetPolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GetPolicyRuleRuleId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`GetUserFiatAccountsProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatAccountsProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for GetUserFiatAccountsProvider {
        fn from(value: &GetUserFiatAccountsProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatAccountsProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatAccountsProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatAccountsProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatAccountsProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatAccountsProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUserFiatAccountsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "accounts": [
    ///        {
    ///          "account_type": "us",
    ///          "bank_name": "Chase",
    ///          "currency": "usd",
    ///          "id": "a068d2dd-743a-4011-9b62-8ad33cc7a7be",
    ///          "last_4": "7899"
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "accounts"
    ///  ],
    ///  "properties": {
    ///    "accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "account_type",
    ///          "currency",
    ///          "id"
    ///        ],
    ///        "properties": {
    ///          "account_type": {
    ///            "type": "string"
    ///          },
    ///          "bank_name": {
    ///            "type": "string"
    ///          },
    ///          "currency": {
    ///            "type": "string"
    ///          },
    ///          "id": {
    ///            "type": "string"
    ///          },
    ///          "last_4": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUserFiatAccountsResponse {
        pub accounts: ::std::vec::Vec<GetUserFiatAccountsResponseAccountsItem>,
    }

    impl ::std::convert::From<&GetUserFiatAccountsResponse> for GetUserFiatAccountsResponse {
        fn from(value: &GetUserFiatAccountsResponse) -> Self {
            value.clone()
        }
    }

    ///`GetUserFiatAccountsResponseAccountsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "account_type",
    ///    "currency",
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "account_type": {
    ///      "type": "string"
    ///    },
    ///    "bank_name": {
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "last_4": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUserFiatAccountsResponseAccountsItem {
        pub account_type: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_name: ::std::option::Option<::std::string::String>,
        pub currency: ::std::string::String,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_4: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GetUserFiatAccountsResponseAccountsItem>
        for GetUserFiatAccountsResponseAccountsItem
    {
        fn from(value: &GetUserFiatAccountsResponseAccountsItem) -> Self {
            value.clone()
        }
    }

    ///`GetUserFiatKycLinkBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "provider"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "endorsements": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "sepa"
    ///        ]
    ///      }
    ///    },
    ///    "full_name": {
    ///      "type": "string"
    ///    },
    ///    "provider": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bridge",
    ///        "bridge-sandbox"
    ///      ]
    ///    },
    ///    "redirect_uri": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "individual",
    ///        "business"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUserFiatKycLinkBody {
        pub email: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub endorsements: ::std::vec::Vec<GetUserFiatKycLinkBodyEndorsementsItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub full_name: ::std::option::Option<::std::string::String>,
        pub provider: GetUserFiatKycLinkBodyProvider,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub redirect_uri: ::std::option::Option<::std::string::String>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub type_: ::std::option::Option<GetUserFiatKycLinkBodyType>,
    }

    impl ::std::convert::From<&GetUserFiatKycLinkBody> for GetUserFiatKycLinkBody {
        fn from(value: &GetUserFiatKycLinkBody) -> Self {
            value.clone()
        }
    }

    ///`GetUserFiatKycLinkBodyEndorsementsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "sepa"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatKycLinkBodyEndorsementsItem {
        #[serde(rename = "sepa")]
        Sepa,
    }

    impl ::std::convert::From<&Self> for GetUserFiatKycLinkBodyEndorsementsItem {
        fn from(value: &GetUserFiatKycLinkBodyEndorsementsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatKycLinkBodyEndorsementsItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sepa => f.write_str("sepa"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatKycLinkBodyEndorsementsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sepa" => Ok(Self::Sepa),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatKycLinkBodyEndorsementsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatKycLinkBodyEndorsementsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatKycLinkBodyEndorsementsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUserFiatKycLinkBodyProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatKycLinkBodyProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for GetUserFiatKycLinkBodyProvider {
        fn from(value: &GetUserFiatKycLinkBodyProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatKycLinkBodyProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatKycLinkBodyProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatKycLinkBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatKycLinkBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatKycLinkBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUserFiatKycLinkBodyType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "individual",
    ///    "business"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatKycLinkBodyType {
        #[serde(rename = "individual")]
        Individual,
        #[serde(rename = "business")]
        Business,
    }

    impl ::std::convert::From<&Self> for GetUserFiatKycLinkBodyType {
        fn from(value: &GetUserFiatKycLinkBodyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatKycLinkBodyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Individual => f.write_str("individual"),
                Self::Business => f.write_str("business"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatKycLinkBodyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "individual" => Ok(Self::Individual),
                "business" => Ok(Self::Business),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatKycLinkBodyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatKycLinkBodyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatKycLinkBodyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUserFiatKycLinkResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "created_at",
    ///    "customer_id",
    ///    "email",
    ///    "full_name",
    ///    "id",
    ///    "kyc_link",
    ///    "kyc_status",
    ///    "rejection_reasons",
    ///    "tos_link",
    ///    "tos_status"
    ///  ],
    ///  "properties": {
    ///    "created_at": {
    ///      "type": "string"
    ///    },
    ///    "customer_id": {
    ///      "type": "string"
    ///    },
    ///    "email": {
    ///      "type": "string"
    ///    },
    ///    "full_name": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "kyc_link": {
    ///      "type": "string"
    ///    },
    ///    "kyc_status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "not_started",
    ///        "pending",
    ///        "incomplete",
    ///        "awaiting_ubo",
    ///        "manual_review",
    ///        "under_review",
    ///        "approved",
    ///        "rejected"
    ///      ]
    ///    },
    ///    "persona_inquiry_type": {
    ///      "type": "string"
    ///    },
    ///    "rejection_reasons": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "created_at",
    ///          "developer_reason",
    ///          "reason"
    ///        ],
    ///        "properties": {
    ///          "created_at": {
    ///            "type": "string"
    ///          },
    ///          "developer_reason": {
    ///            "type": "string"
    ///          },
    ///          "reason": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "tos_link": {
    ///      "type": "string"
    ///    },
    ///    "tos_status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "pending",
    ///        "approved"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUserFiatKycLinkResponse {
        pub created_at: ::std::string::String,
        pub customer_id: ::std::string::String,
        pub email: ::std::string::String,
        pub full_name: ::std::string::String,
        pub id: ::std::string::String,
        pub kyc_link: ::std::string::String,
        pub kyc_status: GetUserFiatKycLinkResponseKycStatus,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub persona_inquiry_type: ::std::option::Option<::std::string::String>,
        pub rejection_reasons: ::std::vec::Vec<GetUserFiatKycLinkResponseRejectionReasonsItem>,
        pub tos_link: ::std::string::String,
        pub tos_status: GetUserFiatKycLinkResponseTosStatus,
    }

    impl ::std::convert::From<&GetUserFiatKycLinkResponse> for GetUserFiatKycLinkResponse {
        fn from(value: &GetUserFiatKycLinkResponse) -> Self {
            value.clone()
        }
    }

    ///`GetUserFiatKycLinkResponseKycStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "not_started",
    ///    "pending",
    ///    "incomplete",
    ///    "awaiting_ubo",
    ///    "manual_review",
    ///    "under_review",
    ///    "approved",
    ///    "rejected"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatKycLinkResponseKycStatus {
        #[serde(rename = "not_started")]
        NotStarted,
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "incomplete")]
        Incomplete,
        #[serde(rename = "awaiting_ubo")]
        AwaitingUbo,
        #[serde(rename = "manual_review")]
        ManualReview,
        #[serde(rename = "under_review")]
        UnderReview,
        #[serde(rename = "approved")]
        Approved,
        #[serde(rename = "rejected")]
        Rejected,
    }

    impl ::std::convert::From<&Self> for GetUserFiatKycLinkResponseKycStatus {
        fn from(value: &GetUserFiatKycLinkResponseKycStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatKycLinkResponseKycStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NotStarted => f.write_str("not_started"),
                Self::Pending => f.write_str("pending"),
                Self::Incomplete => f.write_str("incomplete"),
                Self::AwaitingUbo => f.write_str("awaiting_ubo"),
                Self::ManualReview => f.write_str("manual_review"),
                Self::UnderReview => f.write_str("under_review"),
                Self::Approved => f.write_str("approved"),
                Self::Rejected => f.write_str("rejected"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatKycLinkResponseKycStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "not_started" => Ok(Self::NotStarted),
                "pending" => Ok(Self::Pending),
                "incomplete" => Ok(Self::Incomplete),
                "awaiting_ubo" => Ok(Self::AwaitingUbo),
                "manual_review" => Ok(Self::ManualReview),
                "under_review" => Ok(Self::UnderReview),
                "approved" => Ok(Self::Approved),
                "rejected" => Ok(Self::Rejected),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatKycLinkResponseKycStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatKycLinkResponseKycStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatKycLinkResponseKycStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUserFiatKycLinkResponseRejectionReasonsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "created_at",
    ///    "developer_reason",
    ///    "reason"
    ///  ],
    ///  "properties": {
    ///    "created_at": {
    ///      "type": "string"
    ///    },
    ///    "developer_reason": {
    ///      "type": "string"
    ///    },
    ///    "reason": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUserFiatKycLinkResponseRejectionReasonsItem {
        pub created_at: ::std::string::String,
        pub developer_reason: ::std::string::String,
        pub reason: ::std::string::String,
    }

    impl ::std::convert::From<&GetUserFiatKycLinkResponseRejectionReasonsItem>
        for GetUserFiatKycLinkResponseRejectionReasonsItem
    {
        fn from(value: &GetUserFiatKycLinkResponseRejectionReasonsItem) -> Self {
            value.clone()
        }
    }

    ///`GetUserFiatKycLinkResponseTosStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "pending",
    ///    "approved"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatKycLinkResponseTosStatus {
        #[serde(rename = "pending")]
        Pending,
        #[serde(rename = "approved")]
        Approved,
    }

    impl ::std::convert::From<&Self> for GetUserFiatKycLinkResponseTosStatus {
        fn from(value: &GetUserFiatKycLinkResponseTosStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatKycLinkResponseTosStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => f.write_str("pending"),
                Self::Approved => f.write_str("approved"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatKycLinkResponseTosStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "approved" => Ok(Self::Approved),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatKycLinkResponseTosStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatKycLinkResponseTosStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatKycLinkResponseTosStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUserFiatKycStatusProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatKycStatusProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for GetUserFiatKycStatusProvider {
        fn from(value: &GetUserFiatKycStatusProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatKycStatusProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatKycStatusProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatKycStatusProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatKycStatusProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatKycStatusProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUserFiatKycStatusResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "provider_user_id": "303912cc-74fa-4f7a-9c51-2945b40ac09a",
    ///      "status": "under_review",
    ///      "user_id": "cmaftdj280001ww1ihwhy57s3"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "status",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "provider_user_id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "not_found",
    ///        "active",
    ///        "awaiting_questionnaire",
    ///        "awaiting_ubo",
    ///        "incomplete",
    ///        "not_started",
    ///        "offboarded",
    ///        "paused",
    ///        "rejected",
    ///        "under_review"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUserFiatKycStatusResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub provider_user_id: ::std::option::Option<::std::string::String>,
        pub status: GetUserFiatKycStatusResponseStatus,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&GetUserFiatKycStatusResponse> for GetUserFiatKycStatusResponse {
        fn from(value: &GetUserFiatKycStatusResponse) -> Self {
            value.clone()
        }
    }

    ///`GetUserFiatKycStatusResponseStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "not_found",
    ///    "active",
    ///    "awaiting_questionnaire",
    ///    "awaiting_ubo",
    ///    "incomplete",
    ///    "not_started",
    ///    "offboarded",
    ///    "paused",
    ///    "rejected",
    ///    "under_review"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetUserFiatKycStatusResponseStatus {
        #[serde(rename = "not_found")]
        NotFound,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "awaiting_questionnaire")]
        AwaitingQuestionnaire,
        #[serde(rename = "awaiting_ubo")]
        AwaitingUbo,
        #[serde(rename = "incomplete")]
        Incomplete,
        #[serde(rename = "not_started")]
        NotStarted,
        #[serde(rename = "offboarded")]
        Offboarded,
        #[serde(rename = "paused")]
        Paused,
        #[serde(rename = "rejected")]
        Rejected,
        #[serde(rename = "under_review")]
        UnderReview,
    }

    impl ::std::convert::From<&Self> for GetUserFiatKycStatusResponseStatus {
        fn from(value: &GetUserFiatKycStatusResponseStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetUserFiatKycStatusResponseStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NotFound => f.write_str("not_found"),
                Self::Active => f.write_str("active"),
                Self::AwaitingQuestionnaire => f.write_str("awaiting_questionnaire"),
                Self::AwaitingUbo => f.write_str("awaiting_ubo"),
                Self::Incomplete => f.write_str("incomplete"),
                Self::NotStarted => f.write_str("not_started"),
                Self::Offboarded => f.write_str("offboarded"),
                Self::Paused => f.write_str("paused"),
                Self::Rejected => f.write_str("rejected"),
                Self::UnderReview => f.write_str("under_review"),
            }
        }
    }

    impl ::std::str::FromStr for GetUserFiatKycStatusResponseStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "not_found" => Ok(Self::NotFound),
                "active" => Ok(Self::Active),
                "awaiting_questionnaire" => Ok(Self::AwaitingQuestionnaire),
                "awaiting_ubo" => Ok(Self::AwaitingUbo),
                "incomplete" => Ok(Self::Incomplete),
                "not_started" => Ok(Self::NotStarted),
                "offboarded" => Ok(Self::Offboarded),
                "paused" => Ok(Self::Paused),
                "rejected" => Ok(Self::Rejected),
                "under_review" => Ok(Self::UnderReview),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUserFiatKycStatusResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUserFiatKycStatusResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUserFiatKycStatusResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetUsersCursor`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetUsersCursor(::std::string::String);
    impl ::std::ops::Deref for GetUsersCursor {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<GetUsersCursor> for ::std::string::String {
        fn from(value: GetUsersCursor) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&GetUsersCursor> for GetUsersCursor {
        fn from(value: &GetUsersCursor) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GetUsersCursor {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GetUsersCursor {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetUsersCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetUsersCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GetUsersCursor {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`GetUsersResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/User"
    ///      }
    ///    },
    ///    "next_cursor": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetUsersResponse {
        pub data: ::std::vec::Vec<User>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_cursor: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GetUsersResponse> for GetUsersResponse {
        fn from(value: &GetUsersResponse) -> Self {
            value.clone()
        }
    }

    ///`GetWalletBalanceAsset`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "usdc",
    ///        "eth",
    ///        "pol",
    ///        "usdt",
    ///        "sol"
    ///      ]
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "usdc",
    ///          "eth",
    ///          "pol",
    ///          "usdt",
    ///          "sol"
    ///        ]
    ///      },
    ///      "maxItems": 10
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetWalletBalanceAsset {
        String(GetWalletBalanceAssetString),
        Array(::std::vec::Vec<GetWalletBalanceAssetArrayItem>),
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceAsset {
        fn from(value: &GetWalletBalanceAsset) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<GetWalletBalanceAssetString> for GetWalletBalanceAsset {
        fn from(value: GetWalletBalanceAssetString) -> Self {
            Self::String(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<GetWalletBalanceAssetArrayItem>>
        for GetWalletBalanceAsset
    {
        fn from(value: ::std::vec::Vec<GetWalletBalanceAssetArrayItem>) -> Self {
            Self::Array(value)
        }
    }

    ///`GetWalletBalanceAssetArrayItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc",
    ///    "eth",
    ///    "pol",
    ///    "usdt",
    ///    "sol"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceAssetArrayItem {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "usdt")]
        Usdt,
        #[serde(rename = "sol")]
        Sol,
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceAssetArrayItem {
        fn from(value: &GetWalletBalanceAssetArrayItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletBalanceAssetArrayItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Usdt => f.write_str("usdt"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletBalanceAssetArrayItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "usdt" => Ok(Self::Usdt),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletBalanceAssetArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceAssetArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceAssetArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletBalanceAssetString`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc",
    ///    "eth",
    ///    "pol",
    ///    "usdt",
    ///    "sol"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceAssetString {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "usdt")]
        Usdt,
        #[serde(rename = "sol")]
        Sol,
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceAssetString {
        fn from(value: &GetWalletBalanceAssetString) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletBalanceAssetString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Usdt => f.write_str("usdt"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletBalanceAssetString {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "usdt" => Ok(Self::Usdt),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletBalanceAssetString {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceAssetString {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceAssetString {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletBalanceChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum",
    ///        "arbitrum",
    ///        "base",
    ///        "linea",
    ///        "optimism",
    ///        "polygon",
    ///        "solana",
    ///        "zksync_era"
    ///      ]
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "ethereum",
    ///          "arbitrum",
    ///          "base",
    ///          "linea",
    ///          "optimism",
    ///          "polygon",
    ///          "solana",
    ///          "zksync_era"
    ///        ]
    ///      },
    ///      "maxItems": 10
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GetWalletBalanceChain {
        String(GetWalletBalanceChainString),
        Array(::std::vec::Vec<GetWalletBalanceChainArrayItem>),
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceChain {
        fn from(value: &GetWalletBalanceChain) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<GetWalletBalanceChainString> for GetWalletBalanceChain {
        fn from(value: GetWalletBalanceChainString) -> Self {
            Self::String(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<GetWalletBalanceChainArrayItem>>
        for GetWalletBalanceChain
    {
        fn from(value: ::std::vec::Vec<GetWalletBalanceChainArrayItem>) -> Self {
            Self::Array(value)
        }
    }

    ///`GetWalletBalanceChainArrayItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "arbitrum",
    ///    "base",
    ///    "linea",
    ///    "optimism",
    ///    "polygon",
    ///    "solana",
    ///    "zksync_era"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceChainArrayItem {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceChainArrayItem {
        fn from(value: &GetWalletBalanceChainArrayItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletBalanceChainArrayItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletBalanceChainArrayItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletBalanceChainArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceChainArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceChainArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletBalanceChainString`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "arbitrum",
    ///    "base",
    ///    "linea",
    ///    "optimism",
    ///    "polygon",
    ///    "solana",
    ///    "zksync_era"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceChainString {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceChainString {
        fn from(value: &GetWalletBalanceChainString) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletBalanceChainString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletBalanceChainString {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletBalanceChainString {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceChainString {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceChainString {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletBalanceIncludeCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usd"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceIncludeCurrency {
        #[serde(rename = "usd")]
        Usd,
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceIncludeCurrency {
        fn from(value: &GetWalletBalanceIncludeCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletBalanceIncludeCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletBalanceIncludeCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletBalanceIncludeCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceIncludeCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceIncludeCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletBalanceResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "balances": [
    ///        {
    ///          "asset": "eth",
    ///          "chain": "base",
    ///          "display_values": {
    ///            "eth": "0.001",
    ///            "usd": "2.56"
    ///          },
    ///          "raw_value": "1000000000000000000",
    ///          "raw_value_decimals": 18
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "balances"
    ///  ],
    ///  "properties": {
    ///    "balances": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "asset",
    ///          "chain",
    ///          "display_values",
    ///          "raw_value",
    ///          "raw_value_decimals"
    ///        ],
    ///        "properties": {
    ///          "asset": {
    ///            "type": "string",
    ///            "enum": [
    ///              "usdc",
    ///              "eth",
    ///              "pol",
    ///              "usdt",
    ///              "sol"
    ///            ]
    ///          },
    ///          "chain": {
    ///            "type": "string",
    ///            "enum": [
    ///              "ethereum",
    ///              "arbitrum",
    ///              "base",
    ///              "linea",
    ///              "optimism",
    ///              "polygon",
    ///              "solana",
    ///              "zksync_era"
    ///            ]
    ///          },
    ///          "display_values": {
    ///            "type": "object",
    ///            "additionalProperties": {
    ///              "type": "string"
    ///            }
    ///          },
    ///          "raw_value": {
    ///            "type": "string"
    ///          },
    ///          "raw_value_decimals": {
    ///            "type": "number"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWalletBalanceResponse {
        pub balances: ::std::vec::Vec<GetWalletBalanceResponseBalancesItem>,
    }

    impl ::std::convert::From<&GetWalletBalanceResponse> for GetWalletBalanceResponse {
        fn from(value: &GetWalletBalanceResponse) -> Self {
            value.clone()
        }
    }

    ///`GetWalletBalanceResponseBalancesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "asset",
    ///    "chain",
    ///    "display_values",
    ///    "raw_value",
    ///    "raw_value_decimals"
    ///  ],
    ///  "properties": {
    ///    "asset": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usdc",
    ///        "eth",
    ///        "pol",
    ///        "usdt",
    ///        "sol"
    ///      ]
    ///    },
    ///    "chain": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum",
    ///        "arbitrum",
    ///        "base",
    ///        "linea",
    ///        "optimism",
    ///        "polygon",
    ///        "solana",
    ///        "zksync_era"
    ///      ]
    ///    },
    ///    "display_values": {
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "raw_value": {
    ///      "type": "string"
    ///    },
    ///    "raw_value_decimals": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWalletBalanceResponseBalancesItem {
        pub asset: GetWalletBalanceResponseBalancesItemAsset,
        pub chain: GetWalletBalanceResponseBalancesItemChain,
        pub display_values:
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        pub raw_value: ::std::string::String,
        pub raw_value_decimals: f64,
    }

    impl ::std::convert::From<&GetWalletBalanceResponseBalancesItem>
        for GetWalletBalanceResponseBalancesItem
    {
        fn from(value: &GetWalletBalanceResponseBalancesItem) -> Self {
            value.clone()
        }
    }

    ///`GetWalletBalanceResponseBalancesItemAsset`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc",
    ///    "eth",
    ///    "pol",
    ///    "usdt",
    ///    "sol"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceResponseBalancesItemAsset {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "usdt")]
        Usdt,
        #[serde(rename = "sol")]
        Sol,
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceResponseBalancesItemAsset {
        fn from(value: &GetWalletBalanceResponseBalancesItemAsset) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletBalanceResponseBalancesItemAsset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Usdt => f.write_str("usdt"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletBalanceResponseBalancesItemAsset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "usdt" => Ok(Self::Usdt),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletBalanceResponseBalancesItemAsset {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceResponseBalancesItemAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceResponseBalancesItemAsset {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletBalanceResponseBalancesItemChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "arbitrum",
    ///    "base",
    ///    "linea",
    ///    "optimism",
    ///    "polygon",
    ///    "solana",
    ///    "zksync_era"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletBalanceResponseBalancesItemChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }

    impl ::std::convert::From<&Self> for GetWalletBalanceResponseBalancesItemChain {
        fn from(value: &GetWalletBalanceResponseBalancesItemChain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletBalanceResponseBalancesItemChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletBalanceResponseBalancesItemChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletBalanceResponseBalancesItemChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletBalanceResponseBalancesItemChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletBalanceResponseBalancesItemChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletsChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "cosmos",
    ///    "stellar",
    ///    "sui",
    ///    "tron",
    ///    "bitcoin-segwit",
    ///    "near",
    ///    "ton",
    ///    "starknet",
    ///    "spark",
    ///    "solana",
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GetWalletsChainType {
        #[serde(rename = "cosmos")]
        Cosmos,
        #[serde(rename = "stellar")]
        Stellar,
        #[serde(rename = "sui")]
        Sui,
        #[serde(rename = "tron")]
        Tron,
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
        #[serde(rename = "near")]
        Near,
        #[serde(rename = "ton")]
        Ton,
        #[serde(rename = "starknet")]
        Starknet,
        #[serde(rename = "spark")]
        Spark,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for GetWalletsChainType {
        fn from(value: &GetWalletsChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for GetWalletsChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Cosmos => f.write_str("cosmos"),
                Self::Stellar => f.write_str("stellar"),
                Self::Sui => f.write_str("sui"),
                Self::Tron => f.write_str("tron"),
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
                Self::Near => f.write_str("near"),
                Self::Ton => f.write_str("ton"),
                Self::Starknet => f.write_str("starknet"),
                Self::Spark => f.write_str("spark"),
                Self::Solana => f.write_str("solana"),
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for GetWalletsChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "cosmos" => Ok(Self::Cosmos),
                "stellar" => Ok(Self::Stellar),
                "sui" => Ok(Self::Sui),
                "tron" => Ok(Self::Tron),
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                "near" => Ok(Self::Near),
                "ton" => Ok(Self::Ton),
                "starknet" => Ok(Self::Starknet),
                "spark" => Ok(Self::Spark),
                "solana" => Ok(Self::Solana),
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletsChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`GetWalletsCursor`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct GetWalletsCursor(::std::string::String);
    impl ::std::ops::Deref for GetWalletsCursor {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<GetWalletsCursor> for ::std::string::String {
        fn from(value: GetWalletsCursor) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&GetWalletsCursor> for GetWalletsCursor {
        fn from(value: &GetWalletsCursor) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GetWalletsCursor {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GetWalletsCursor {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for GetWalletsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for GetWalletsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GetWalletsCursor {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`GetWalletsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Wallet"
    ///      }
    ///    },
    ///    "next_cursor": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GetWalletsResponse {
        pub data: ::std::vec::Vec<Wallet>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_cursor: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GetWalletsResponse> for GetWalletsResponse {
        fn from(value: &GetWalletsResponse) -> Self {
            value.clone()
        }
    }

    ///The input for HD wallets.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The input for HD wallets.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_type",
    ///    "encryption_type",
    ///    "entropy_type",
    ///    "index"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address of the wallet to import.",
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/WalletImportSupportedChains"
    ///    },
    ///    "encryption_type": {
    ///      "$ref": "#/components/schemas/HPKEEncryption"
    ///    },
    ///    "entropy_type": {
    ///      "description": "The entropy type of the wallet to import.",
    ///      "type": "string",
    ///      "enum": [
    ///        "hd"
    ///      ]
    ///    },
    ///    "index": {
    ///      "description": "The index of the wallet to import.",
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HdInitInput {
        ///The address of the wallet to import.
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        pub encryption_type: HpkeEncryption,
        ///The entropy type of the wallet to import.
        pub entropy_type: HdInitInputEntropyType,
        ///The index of the wallet to import.
        pub index: u64,
    }

    impl ::std::convert::From<&HdInitInput> for HdInitInput {
        fn from(value: &HdInitInput) -> Self {
            value.clone()
        }
    }

    ///The entropy type of the wallet to import.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The entropy type of the wallet to import.",
    ///  "type": "string",
    ///  "enum": [
    ///    "hd"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum HdInitInputEntropyType {
        #[serde(rename = "hd")]
        Hd,
    }

    impl ::std::convert::From<&Self> for HdInitInputEntropyType {
        fn from(value: &HdInitInputEntropyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for HdInitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hd => f.write_str("hd"),
            }
        }
    }

    impl ::std::str::FromStr for HdInitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hd" => Ok(Self::Hd),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for HdInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for HdInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for HdInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`HdSubmitInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_type",
    ///    "ciphertext",
    ///    "encapsulated_key",
    ///    "encryption_type",
    ///    "entropy_type",
    ///    "index"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address of the wallet to import.",
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/WalletImportSupportedChains"
    ///    },
    ///    "ciphertext": {
    ///      "description": "The encrypted entropy of the wallet to import.",
    ///      "type": "string"
    ///    },
    ///    "encapsulated_key": {
    ///      "description": "The base64-encoded encapsulated key that was generated during encryption, for use during decryption inside the TEE.",
    ///      "type": "string"
    ///    },
    ///    "encryption_type": {
    ///      "$ref": "#/components/schemas/HPKEEncryption"
    ///    },
    ///    "entropy_type": {
    ///      "description": "The entropy type of the wallet to import.",
    ///      "type": "string",
    ///      "enum": [
    ///        "hd"
    ///      ]
    ///    },
    ///    "index": {
    ///      "description": "The index of the wallet to import.",
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HdSubmitInput {
        ///The address of the wallet to import.
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        ///The encrypted entropy of the wallet to import.
        pub ciphertext: ::std::string::String,
        ///The base64-encoded encapsulated key that was generated during
        /// encryption, for use during decryption inside the TEE.
        pub encapsulated_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
        ///The entropy type of the wallet to import.
        pub entropy_type: HdSubmitInputEntropyType,
        ///The index of the wallet to import.
        pub index: u64,
    }

    impl ::std::convert::From<&HdSubmitInput> for HdSubmitInput {
        fn from(value: &HdSubmitInput) -> Self {
            value.clone()
        }
    }

    ///The entropy type of the wallet to import.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The entropy type of the wallet to import.",
    ///  "type": "string",
    ///  "enum": [
    ///    "hd"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum HdSubmitInputEntropyType {
        #[serde(rename = "hd")]
        Hd,
    }

    impl ::std::convert::From<&Self> for HdSubmitInputEntropyType {
        fn from(value: &HdSubmitInputEntropyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for HdSubmitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hd => f.write_str("hd"),
            }
        }
    }

    impl ::std::str::FromStr for HdSubmitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hd" => Ok(Self::Hd),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for HdSubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for HdSubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for HdSubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The encryption type of the wallet to import. Currently only supports
    /// `HPKE`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The encryption type of the wallet to import. Currently
    /// only supports `HPKE`.",
    ///  "type": "string",
    ///  "enum": [
    ///    "HPKE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum HpkeEncryption {
        #[serde(rename = "HPKE")]
        Hpke,
    }

    impl ::std::convert::From<&Self> for HpkeEncryption {
        fn from(value: &HpkeEncryption) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for HpkeEncryption {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hpke => f.write_str("HPKE"),
            }
        }
    }

    impl ::std::str::FromStr for HpkeEncryption {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "HPKE" => Ok(Self::Hpke),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for HpkeEncryption {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for HpkeEncryption {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for HpkeEncryption {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatKycBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "data": {
    ///        "birth_date": "1989-09-09",
    ///        "email": "john@doe.com",
    ///        "first_name": "John",
    ///        "identifying_information": [
    ///          {
    ///            "image_back": "data:image/jpeg;base64,/9j/4AAQSkZJRg...",
    ///            "image_front": "data:image/jpeg;base64,/9j/4AAQSkZJRg...",
    ///            "issuing_country": "USA",
    ///            "number": "111-11-1111",
    ///            "type": "ssn"
    ///          }
    ///        ],
    ///        "last_name": "Doe",
    ///        "phone": "+59898222122",
    ///        "residential_address": {
    ///          "city": "San Francisco",
    ///          "country": "USA",
    ///          "postal_code": "94109",
    ///          "street_line_1": "1234 Lombard Street",
    ///          "street_line_2": "Apt 2F",
    ///          "subdivision": "CA"
    ///        },
    ///        "signed_agreement_id": "123",
    ///        "type": "individual"
    ///      },
    ///      "provider": "bridge-sandbox"
    ///    }
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "provider"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "object",
    ///          "required": [
    ///            "birth_date",
    ///            "email",
    ///            "first_name",
    ///            "identifying_information",
    ///            "last_name",
    ///            "residential_address",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "account_purpose": {
    ///              "type": "string"
    ///            },
    ///            "account_purpose_other": {
    ///              "type": "string"
    ///            },
    ///            "acting_as_intermediary": {
    ///              "type": "string"
    ///            },
    ///            "birth_date": {
    ///              "type": "string",
    ///              "maxLength": 10,
    ///              "minLength": 10
    ///            },
    ///            "completed_customer_safety_check_at": {
    ///              "type": "string"
    ///            },
    ///            "documents": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "file",
    ///                  "purposes"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "file": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "purposes": {
    ///                    "type": "array",
    ///                    "items": {
    ///                      "type": "string",
    ///                      "minLength": 1
    ///                    },
    ///                    "minItems": 1
    ///                  }
    ///                }
    ///              }
    ///            },
    ///            "email": {
    ///              "type": "string",
    ///              "format": "email",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "employment_status": {
    ///              "type": "string"
    ///            },
    ///            "endorsements": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "string"
    ///              }
    ///            },
    ///            "expected_monthly_payments_usd": {
    ///              "type": "string"
    ///            },
    ///            "first_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "has_signed_terms_of_service": {
    ///              "type": "boolean"
    ///            },
    ///            "identifying_information": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "issuing_country",
    ///                  "type"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string"
    ///                  },
    ///                  "expiration": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_back": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_front": {
    ///                    "type": "string"
    ///                  },
    ///                  "issuing_country": {
    ///                    "type": "string",
    ///                    "maxLength": 3,
    ///                    "minLength": 3
    ///                  },
    ///                  "number": {
    ///                    "type": "string"
    ///                  },
    ///                  "type": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "minItems": 1
    ///            },
    ///            "kyc_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "last_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "middle_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "most_recent_occupation": {
    ///              "type": "string"
    ///            },
    ///            "nationality": {
    ///              "type": "string",
    ///              "maxLength": 3,
    ///              "minLength": 3
    ///            },
    ///            "ofac_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "phone": {
    ///              "type": "string",
    ///              "maxLength": 18,
    ///              "minLength": 2
    ///            },
    ///            "residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "signed_agreement_id": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "source_of_funds": {
    ///              "type": "string"
    ///            },
    ///            "transliterated_first_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_last_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_middle_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "individual"
    ///              ]
    ///            },
    ///            "verified_selfie_at": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "provider": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bridge"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "provider"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "object",
    ///          "required": [
    ///            "birth_date",
    ///            "email",
    ///            "first_name",
    ///            "identifying_information",
    ///            "last_name",
    ///            "residential_address",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "account_purpose": {
    ///              "type": "string"
    ///            },
    ///            "account_purpose_other": {
    ///              "type": "string"
    ///            },
    ///            "acting_as_intermediary": {
    ///              "type": "string"
    ///            },
    ///            "birth_date": {
    ///              "type": "string",
    ///              "maxLength": 10,
    ///              "minLength": 10
    ///            },
    ///            "completed_customer_safety_check_at": {
    ///              "type": "string"
    ///            },
    ///            "documents": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "file",
    ///                  "purposes"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "file": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "purposes": {
    ///                    "type": "array",
    ///                    "items": {
    ///                      "type": "string",
    ///                      "minLength": 1
    ///                    },
    ///                    "minItems": 1
    ///                  }
    ///                }
    ///              }
    ///            },
    ///            "email": {
    ///              "type": "string",
    ///              "format": "email",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "employment_status": {
    ///              "type": "string"
    ///            },
    ///            "endorsements": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "string"
    ///              }
    ///            },
    ///            "expected_monthly_payments_usd": {
    ///              "type": "string"
    ///            },
    ///            "first_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "has_signed_terms_of_service": {
    ///              "type": "boolean"
    ///            },
    ///            "identifying_information": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "issuing_country",
    ///                  "type"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string"
    ///                  },
    ///                  "expiration": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_back": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_front": {
    ///                    "type": "string"
    ///                  },
    ///                  "issuing_country": {
    ///                    "type": "string",
    ///                    "maxLength": 3,
    ///                    "minLength": 3
    ///                  },
    ///                  "number": {
    ///                    "type": "string"
    ///                  },
    ///                  "type": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "minItems": 1
    ///            },
    ///            "kyc_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "last_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "middle_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "most_recent_occupation": {
    ///              "type": "string"
    ///            },
    ///            "nationality": {
    ///              "type": "string",
    ///              "maxLength": 3,
    ///              "minLength": 3
    ///            },
    ///            "ofac_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "phone": {
    ///              "type": "string",
    ///              "maxLength": 18,
    ///              "minLength": 2
    ///            },
    ///            "residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "signed_agreement_id": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "source_of_funds": {
    ///              "type": "string"
    ///            },
    ///            "transliterated_first_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_last_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_middle_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "individual"
    ///              ]
    ///            },
    ///            "verified_selfie_at": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "provider": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bridge-sandbox"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "provider", content = "data")]
    pub enum InitiateUserFiatKycBody {
        #[serde(rename = "bridge")]
        Bridge {
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose_other: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            acting_as_intermediary: ::std::option::Option<::std::string::String>,
            birth_date: InitiateUserFiatKycBodyBridgeBirthDate,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            completed_customer_safety_check_at: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            documents: ::std::vec::Vec<InitiateUserFiatKycBodyBridgeDocumentsItem>,
            email: ::std::string::String,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            employment_status: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            endorsements: ::std::vec::Vec<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            expected_monthly_payments_usd: ::std::option::Option<::std::string::String>,
            first_name: InitiateUserFiatKycBodyBridgeFirstName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            has_signed_terms_of_service: ::std::option::Option<bool>,
            identifying_information:
                ::std::vec::Vec<InitiateUserFiatKycBodyBridgeIdentifyingInformationItem>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            kyc_screen: ::std::option::Option<InitiateUserFiatKycBodyBridgeKycScreen>,
            last_name: InitiateUserFiatKycBodyBridgeLastName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            middle_name: ::std::option::Option<InitiateUserFiatKycBodyBridgeMiddleName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            most_recent_occupation: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            nationality: ::std::option::Option<InitiateUserFiatKycBodyBridgeNationality>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            ofac_screen: ::std::option::Option<InitiateUserFiatKycBodyBridgeOfacScreen>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            phone: ::std::option::Option<InitiateUserFiatKycBodyBridgePhone>,
            residential_address: InitiateUserFiatKycBodyBridgeResidentialAddress,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            signed_agreement_id:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeSignedAgreementId>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            source_of_funds: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_first_name:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeTransliteratedFirstName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_last_name:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeTransliteratedLastName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_middle_name:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeTransliteratedMiddleName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_residential_address: ::std::option::Option<
                InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddress,
            >,
            #[serde(rename = "type")]
            type_: InitiateUserFiatKycBodyBridgeType,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            verified_selfie_at: ::std::option::Option<::std::string::String>,
        },
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox {
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose_other: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            acting_as_intermediary: ::std::option::Option<::std::string::String>,
            birth_date: InitiateUserFiatKycBodyBridgeSandboxBirthDate,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            completed_customer_safety_check_at: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            documents: ::std::vec::Vec<InitiateUserFiatKycBodyBridgeSandboxDocumentsItem>,
            email: ::std::string::String,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            employment_status: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            endorsements: ::std::vec::Vec<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            expected_monthly_payments_usd: ::std::option::Option<::std::string::String>,
            first_name: InitiateUserFiatKycBodyBridgeSandboxFirstName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            has_signed_terms_of_service: ::std::option::Option<bool>,
            identifying_information:
                ::std::vec::Vec<InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItem>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            kyc_screen: ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxKycScreen>,
            last_name: InitiateUserFiatKycBodyBridgeSandboxLastName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            middle_name: ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxMiddleName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            most_recent_occupation: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            nationality: ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxNationality>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            ofac_screen: ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxOfacScreen>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            phone: ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxPhone>,
            residential_address: InitiateUserFiatKycBodyBridgeSandboxResidentialAddress,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            signed_agreement_id:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            source_of_funds: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_first_name:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_last_name:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_middle_name:
                ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_residential_address: ::std::option::Option<
                InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddress,
            >,
            #[serde(rename = "type")]
            type_: InitiateUserFiatKycBodyBridgeSandboxType,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            verified_selfie_at: ::std::option::Option<::std::string::String>,
        },
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycBody {
        fn from(value: &InitiateUserFiatKycBody) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeBirthDate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 10,
    ///  "minLength": 10
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeBirthDate(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeBirthDate {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeBirthDate> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeBirthDate) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeBirthDate>
        for InitiateUserFiatKycBodyBridgeBirthDate
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeBirthDate) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeBirthDate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 10usize {
                return Err("longer than 10 characters".into());
            }
            if value.chars().count() < 10usize {
                return Err("shorter than 10 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeBirthDate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeBirthDate {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeBirthDate {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeBirthDate {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeDocumentsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "file",
    ///    "purposes"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "file": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "purposes": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "minLength": 1
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeDocumentsItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description:
            ::std::option::Option<InitiateUserFiatKycBodyBridgeDocumentsItemDescription>,
        pub file: InitiateUserFiatKycBodyBridgeDocumentsItemFile,
        pub purposes: ::std::vec::Vec<InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem>,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeDocumentsItem>
        for InitiateUserFiatKycBodyBridgeDocumentsItem
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeDocumentsItem) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeDocumentsItemDescription`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeDocumentsItemDescription(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeDocumentsItemDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeDocumentsItemDescription>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeDocumentsItemDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeDocumentsItemDescription>
        for InitiateUserFiatKycBodyBridgeDocumentsItemDescription
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeDocumentsItemDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeDocumentsItemDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeDocumentsItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeDocumentsItemDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeDocumentsItemFile`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeDocumentsItemFile(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeDocumentsItemFile {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeDocumentsItemFile>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeDocumentsItemFile) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeDocumentsItemFile>
        for InitiateUserFiatKycBodyBridgeDocumentsItemFile
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeDocumentsItemFile) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeDocumentsItemFile {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeDocumentsItemFile {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeDocumentsItemFile {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem>
        for InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeDocumentsItemPurposesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeFirstName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeFirstName> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeFirstName>
        for InitiateUserFiatKycBodyBridgeFirstName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeIdentifyingInformationItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "issuing_country",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "expiration": {
    ///      "type": "string"
    ///    },
    ///    "image_back": {
    ///      "type": "string"
    ///    },
    ///    "image_front": {
    ///      "type": "string"
    ///    },
    ///    "issuing_country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "number": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeIdentifyingInformationItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expiration: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_back: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_front: ::std::option::Option<::std::string::String>,
        pub issuing_country: InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub number: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeIdentifyingInformationItem>
        for InitiateUserFiatKycBodyBridgeIdentifyingInformationItem
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeIdentifyingInformationItem) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry>
        for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<&InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry>
        for InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeKycScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeKycScreen {
        pub result: InitiateUserFiatKycBodyBridgeKycScreenResult,
        pub screened_at: InitiateUserFiatKycBodyBridgeKycScreenScreenedAt,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeKycScreen>
        for InitiateUserFiatKycBodyBridgeKycScreen
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeKycScreen) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeKycScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatKycBodyBridgeKycScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycBodyBridgeKycScreenResult {
        fn from(value: &InitiateUserFiatKycBodyBridgeKycScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatKycBodyBridgeKycScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeKycScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeKycScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeKycScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeKycScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeKycScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeKycScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeKycScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeKycScreenScreenedAt>
        for InitiateUserFiatKycBodyBridgeKycScreenScreenedAt
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeKycScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeKycScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeKycScreenScreenedAt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeKycScreenScreenedAt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeLastName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeLastName> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeLastName>
        for InitiateUserFiatKycBodyBridgeLastName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeMiddleName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeMiddleName> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeMiddleName>
        for InitiateUserFiatKycBodyBridgeMiddleName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeMiddleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeNationality`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeNationality(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeNationality {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeNationality> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeNationality) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeNationality>
        for InitiateUserFiatKycBodyBridgeNationality
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeNationality) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeNationality {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeNationality {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeNationality {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeNationality {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeNationality {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeOfacScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeOfacScreen {
        pub result: InitiateUserFiatKycBodyBridgeOfacScreenResult,
        pub screened_at: InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeOfacScreen>
        for InitiateUserFiatKycBodyBridgeOfacScreen
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeOfacScreen) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeOfacScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatKycBodyBridgeOfacScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycBodyBridgeOfacScreenResult {
        fn from(value: &InitiateUserFiatKycBodyBridgeOfacScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatKycBodyBridgeOfacScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeOfacScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeOfacScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt>
        for InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeOfacScreenScreenedAt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgePhone`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 18,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgePhone(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgePhone {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgePhone> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgePhone) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgePhone>
        for InitiateUserFiatKycBodyBridgePhone
    {
        fn from(value: &InitiateUserFiatKycBodyBridgePhone) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgePhone {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 18usize {
                return Err("longer than 18 characters".into());
            }
            if value.chars().count() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgePhone {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgePhone {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgePhone {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgePhone {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeResidentialAddress {
        pub city: InitiateUserFiatKycBodyBridgeResidentialAddressCity,
        pub country: InitiateUserFiatKycBodyBridgeResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code:
            ::std::option::Option<InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode>,
        pub street_line_1: InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2:
            ::std::option::Option<InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2>,
        pub subdivision: InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeResidentialAddress>
        for InitiateUserFiatKycBodyBridgeResidentialAddress
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeResidentialAddress) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeResidentialAddressCity(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeResidentialAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeResidentialAddressCity>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeResidentialAddressCity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeResidentialAddressCity>
        for InitiateUserFiatKycBodyBridgeResidentialAddressCity
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeResidentialAddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeResidentialAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeResidentialAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeResidentialAddressCity {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeResidentialAddressCountry(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeResidentialAddressCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeResidentialAddressCountry>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeResidentialAddressCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeResidentialAddressCountry>
        for InitiateUserFiatKycBodyBridgeResidentialAddressCountry
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeResidentialAddressCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeResidentialAddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeResidentialAddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeResidentialAddressCountry {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode>
        for InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeResidentialAddressPostalCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1>
        for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine1 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2>
        for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeResidentialAddressStreetLine2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision>
        for InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeResidentialAddressSubdivision {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxBirthDate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 10,
    ///  "minLength": 10
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxBirthDate(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxBirthDate {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxBirthDate> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxBirthDate) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxBirthDate>
        for InitiateUserFiatKycBodyBridgeSandboxBirthDate
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxBirthDate) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxBirthDate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 10usize {
                return Err("longer than 10 characters".into());
            }
            if value.chars().count() < 10usize {
                return Err("shorter than 10 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxBirthDate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxBirthDate
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxBirthDate
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxBirthDate {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxDocumentsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "file",
    ///    "purposes"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "file": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "purposes": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "minLength": 1
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxDocumentsItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description:
            ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription>,
        pub file: InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile,
        pub purposes:
            ::std::vec::Vec<InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem>,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxDocumentsItem>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItem
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxDocumentsItem) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemDescription
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemFile {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxDocumentsItemPurposesItem
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxFirstName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxFirstName> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxFirstName>
        for InitiateUserFiatKycBodyBridgeSandboxFirstName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "issuing_country",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "expiration": {
    ///      "type": "string"
    ///    },
    ///    "image_back": {
    ///      "type": "string"
    ///    },
    ///    "image_front": {
    ///      "type": "string"
    ///    },
    ///    "issuing_country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "number": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expiration: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_back: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_front: ::std::option::Option<::std::string::String>,
        pub issuing_country:
            InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub number: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItem>
        for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItem
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItem) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        > for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxKycScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxKycScreen {
        pub result: InitiateUserFiatKycBodyBridgeSandboxKycScreenResult,
        pub screened_at: InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxKycScreen>
        for InitiateUserFiatKycBodyBridgeSandboxKycScreen
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxKycScreen) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxKycScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatKycBodyBridgeSandboxKycScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycBodyBridgeSandboxKycScreenResult {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxKycScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatKycBodyBridgeSandboxKycScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxKycScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxKycScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt>
        for InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxKycScreenScreenedAt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxLastName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxLastName> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxLastName>
        for InitiateUserFiatKycBodyBridgeSandboxLastName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxMiddleName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxMiddleName>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxMiddleName>
        for InitiateUserFiatKycBodyBridgeSandboxMiddleName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxMiddleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxNationality`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxNationality(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxNationality {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxNationality>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxNationality) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxNationality>
        for InitiateUserFiatKycBodyBridgeSandboxNationality
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxNationality) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxNationality {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxNationality {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxNationality
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxNationality
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxNationality {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxOfacScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxOfacScreen {
        pub result: InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult,
        pub screened_at: InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxOfacScreen>
        for InitiateUserFiatKycBodyBridgeSandboxOfacScreen
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxOfacScreen) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt>
        for InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxOfacScreenScreenedAt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxPhone`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 18,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxPhone(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxPhone {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxPhone> for ::std::string::String {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxPhone) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxPhone>
        for InitiateUserFiatKycBodyBridgeSandboxPhone
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxPhone) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxPhone {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 18usize {
                return Err("longer than 18 characters".into());
            }
            if value.chars().count() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxPhone {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeSandboxPhone {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeSandboxPhone {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxPhone {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxResidentialAddress {
        pub city: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity,
        pub country: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code:
            ::std::option::Option<InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode>,
        pub street_line_1: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<
            InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2,
        >,
        pub subdivision: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxResidentialAddress>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddress
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxResidentialAddress) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCity {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressPostalCode
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressStreetLine2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxResidentialAddressSubdivision
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId>
        for InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxSignedAgreementId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedFirstName
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSandboxTransliteratedLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedMiddleName
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddress {
        pub city: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity,
        pub country: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        >,
        pub street_line_1:
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        >,
        pub subdivision:
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddress>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddress
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddress,
        ) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity,
        > for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        > for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        > for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        > for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        > for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        > for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSandboxType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "individual"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatKycBodyBridgeSandboxType {
        #[serde(rename = "individual")]
        Individual,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycBodyBridgeSandboxType {
        fn from(value: &InitiateUserFiatKycBodyBridgeSandboxType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatKycBodyBridgeSandboxType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Individual => f.write_str("individual"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSandboxType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "individual" => Ok(Self::Individual),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSandboxType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeSandboxType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeSandboxType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeSignedAgreementId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeSignedAgreementId(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeSignedAgreementId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeSignedAgreementId>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeSignedAgreementId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeSignedAgreementId>
        for InitiateUserFiatKycBodyBridgeSignedAgreementId
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeSignedAgreementId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeSignedAgreementId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeSignedAgreementId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeSignedAgreementId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedFirstName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeTransliteratedFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeTransliteratedFirstName>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeTransliteratedFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeTransliteratedFirstName>
        for InitiateUserFiatKycBodyBridgeTransliteratedFirstName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeTransliteratedFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeTransliteratedFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeTransliteratedFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeTransliteratedFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedLastName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeTransliteratedLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeTransliteratedLastName>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeTransliteratedLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeTransliteratedLastName>
        for InitiateUserFiatKycBodyBridgeTransliteratedLastName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeTransliteratedLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeTransliteratedLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeTransliteratedLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeTransliteratedLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedMiddleName(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeTransliteratedMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeTransliteratedMiddleName>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeTransliteratedMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeTransliteratedMiddleName>
        for InitiateUserFiatKycBodyBridgeTransliteratedMiddleName
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeTransliteratedMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeTransliteratedMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeTransliteratedMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatKycBodyBridgeTransliteratedMiddleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddress {
        pub city: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity,
        pub country: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<
            InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode,
        >,
        pub street_line_1: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<
            InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2,
        >,
        pub subdivision: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision,
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddress>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddress
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddress) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity>
        for ::std::string::String
    {
        fn from(value: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity
    {
        fn from(value: &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCity
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry>
        for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode(
        ::std::string::String,
    );
    impl ::std::ops::Deref for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode,
        > for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1,
        > for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2,
        > for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision,
        > for ::std::string::String
    {
        fn from(
            value: InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision,
        > for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        fn from(
            value: &InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for InitiateUserFiatKycBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatKycBodyBridgeType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "individual"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatKycBodyBridgeType {
        #[serde(rename = "individual")]
        Individual,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycBodyBridgeType {
        fn from(value: &InitiateUserFiatKycBodyBridgeType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatKycBodyBridgeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Individual => f.write_str("individual"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycBodyBridgeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "individual" => Ok(Self::Individual),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycBodyBridgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycBodyBridgeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycBodyBridgeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatKycResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "provider_user_id": "303912cc-74fa-4f7a-9c51-2945b40ac09a",
    ///      "status": "under_review",
    ///      "user_id": "cmaftdj280001ww1ihwhy57s3"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "status",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "provider_user_id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "not_found",
    ///        "active",
    ///        "awaiting_questionnaire",
    ///        "awaiting_ubo",
    ///        "incomplete",
    ///        "not_started",
    ///        "offboarded",
    ///        "paused",
    ///        "rejected",
    ///        "under_review"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatKycResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub provider_user_id: ::std::option::Option<::std::string::String>,
        pub status: InitiateUserFiatKycResponseStatus,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&InitiateUserFiatKycResponse> for InitiateUserFiatKycResponse {
        fn from(value: &InitiateUserFiatKycResponse) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatKycResponseStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "not_found",
    ///    "active",
    ///    "awaiting_questionnaire",
    ///    "awaiting_ubo",
    ///    "incomplete",
    ///    "not_started",
    ///    "offboarded",
    ///    "paused",
    ///    "rejected",
    ///    "under_review"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatKycResponseStatus {
        #[serde(rename = "not_found")]
        NotFound,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "awaiting_questionnaire")]
        AwaitingQuestionnaire,
        #[serde(rename = "awaiting_ubo")]
        AwaitingUbo,
        #[serde(rename = "incomplete")]
        Incomplete,
        #[serde(rename = "not_started")]
        NotStarted,
        #[serde(rename = "offboarded")]
        Offboarded,
        #[serde(rename = "paused")]
        Paused,
        #[serde(rename = "rejected")]
        Rejected,
        #[serde(rename = "under_review")]
        UnderReview,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatKycResponseStatus {
        fn from(value: &InitiateUserFiatKycResponseStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatKycResponseStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NotFound => f.write_str("not_found"),
                Self::Active => f.write_str("active"),
                Self::AwaitingQuestionnaire => f.write_str("awaiting_questionnaire"),
                Self::AwaitingUbo => f.write_str("awaiting_ubo"),
                Self::Incomplete => f.write_str("incomplete"),
                Self::NotStarted => f.write_str("not_started"),
                Self::Offboarded => f.write_str("offboarded"),
                Self::Paused => f.write_str("paused"),
                Self::Rejected => f.write_str("rejected"),
                Self::UnderReview => f.write_str("under_review"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatKycResponseStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "not_found" => Ok(Self::NotFound),
                "active" => Ok(Self::Active),
                "awaiting_questionnaire" => Ok(Self::AwaitingQuestionnaire),
                "awaiting_ubo" => Ok(Self::AwaitingUbo),
                "incomplete" => Ok(Self::Incomplete),
                "not_started" => Ok(Self::NotStarted),
                "offboarded" => Ok(Self::Offboarded),
                "paused" => Ok(Self::Paused),
                "rejected" => Ok(Self::Rejected),
                "under_review" => Ok(Self::UnderReview),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatKycResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatKycResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatKycResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "amount": "100.00",
    ///      "destination": {
    ///        "currency": "usd",
    ///        "external_account_id": "a068d2dd-743a-4011-9b62-8ad33cc7a7be",
    ///        "payment_rail": "ach_push"
    ///      },
    ///      "provider": "bridge-sandbox",
    ///      "source": {
    ///        "chain": "base",
    ///        "currency": "usdc",
    ///        "from_address": "0xc24272abc794b973b896715db40a72714a030323"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "destination",
    ///    "provider",
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "destination": {
    ///      "type": "object",
    ///      "required": [
    ///        "currency",
    ///        "external_account_id",
    ///        "payment_rail"
    ///      ],
    ///      "properties": {
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usd",
    ///            "eur"
    ///          ]
    ///        },
    ///        "external_account_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "payment_rail": {
    ///          "type": "string",
    ///          "enum": [
    ///            "sepa",
    ///            "ach_push",
    ///            "wire"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "provider": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bridge",
    ///        "bridge-sandbox"
    ///      ]
    ///    },
    ///    "source": {
    ///      "type": "object",
    ///      "required": [
    ///        "chain",
    ///        "currency",
    ///        "from_address"
    ///      ],
    ///      "properties": {
    ///        "chain": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ethereum",
    ///            "base",
    ///            "arbitrum",
    ///            "polygon",
    ///            "optimism"
    ///          ]
    ///        },
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usdc"
    ///          ]
    ///        },
    ///        "from_address": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOfframpBody {
        pub amount: InitiateUserFiatOfframpBodyAmount,
        pub destination: InitiateUserFiatOfframpBodyDestination,
        pub provider: InitiateUserFiatOfframpBodyProvider,
        pub source: InitiateUserFiatOfframpBodySource,
    }

    impl ::std::convert::From<&InitiateUserFiatOfframpBody> for InitiateUserFiatOfframpBody {
        fn from(value: &InitiateUserFiatOfframpBody) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOfframpBodyAmount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatOfframpBodyAmount(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatOfframpBodyAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatOfframpBodyAmount> for ::std::string::String {
        fn from(value: InitiateUserFiatOfframpBodyAmount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatOfframpBodyAmount>
        for InitiateUserFiatOfframpBodyAmount
    {
        fn from(value: &InitiateUserFiatOfframpBodyAmount) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpBodyAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpBodyAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOfframpBodyAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOfframpBodyAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatOfframpBodyAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatOfframpBodyDestination`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "currency",
    ///    "external_account_id",
    ///    "payment_rail"
    ///  ],
    ///  "properties": {
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usd",
    ///        "eur"
    ///      ]
    ///    },
    ///    "external_account_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "payment_rail": {
    ///      "type": "string",
    ///      "enum": [
    ///        "sepa",
    ///        "ach_push",
    ///        "wire"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOfframpBodyDestination {
        pub currency: InitiateUserFiatOfframpBodyDestinationCurrency,
        pub external_account_id: ::uuid::Uuid,
        pub payment_rail: InitiateUserFiatOfframpBodyDestinationPaymentRail,
    }

    impl ::std::convert::From<&InitiateUserFiatOfframpBodyDestination>
        for InitiateUserFiatOfframpBodyDestination
    {
        fn from(value: &InitiateUserFiatOfframpBodyDestination) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOfframpBodyDestinationCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usd",
    ///    "eur"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpBodyDestinationCurrency {
        #[serde(rename = "usd")]
        Usd,
        #[serde(rename = "eur")]
        Eur,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpBodyDestinationCurrency {
        fn from(value: &InitiateUserFiatOfframpBodyDestinationCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpBodyDestinationCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
                Self::Eur => f.write_str("eur"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpBodyDestinationCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                "eur" => Ok(Self::Eur),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpBodyDestinationCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOfframpBodyDestinationCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOfframpBodyDestinationCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpBodyDestinationPaymentRail`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "sepa",
    ///    "ach_push",
    ///    "wire"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpBodyDestinationPaymentRail {
        #[serde(rename = "sepa")]
        Sepa,
        #[serde(rename = "ach_push")]
        AchPush,
        #[serde(rename = "wire")]
        Wire,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpBodyDestinationPaymentRail {
        fn from(value: &InitiateUserFiatOfframpBodyDestinationPaymentRail) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpBodyDestinationPaymentRail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sepa => f.write_str("sepa"),
                Self::AchPush => f.write_str("ach_push"),
                Self::Wire => f.write_str("wire"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpBodyDestinationPaymentRail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sepa" => Ok(Self::Sepa),
                "ach_push" => Ok(Self::AchPush),
                "wire" => Ok(Self::Wire),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpBodyDestinationPaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOfframpBodyDestinationPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOfframpBodyDestinationPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpBodyProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpBodyProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpBodyProvider {
        fn from(value: &InitiateUserFiatOfframpBodyProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpBodyProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpBodyProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOfframpBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOfframpBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpBodySource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "chain",
    ///    "currency",
    ///    "from_address"
    ///  ],
    ///  "properties": {
    ///    "chain": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum",
    ///        "base",
    ///        "arbitrum",
    ///        "polygon",
    ///        "optimism"
    ///      ]
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usdc"
    ///      ]
    ///    },
    ///    "from_address": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOfframpBodySource {
        pub chain: InitiateUserFiatOfframpBodySourceChain,
        pub currency: InitiateUserFiatOfframpBodySourceCurrency,
        pub from_address: ::std::string::String,
    }

    impl ::std::convert::From<&InitiateUserFiatOfframpBodySource>
        for InitiateUserFiatOfframpBodySource
    {
        fn from(value: &InitiateUserFiatOfframpBodySource) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOfframpBodySourceChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "base",
    ///    "arbitrum",
    ///    "polygon",
    ///    "optimism"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpBodySourceChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpBodySourceChain {
        fn from(value: &InitiateUserFiatOfframpBodySourceChain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpBodySourceChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Base => f.write_str("base"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpBodySourceChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "base" => Ok(Self::Base),
                "arbitrum" => Ok(Self::Arbitrum),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpBodySourceChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOfframpBodySourceChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOfframpBodySourceChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpBodySourceCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpBodySourceCurrency {
        #[serde(rename = "usdc")]
        Usdc,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpBodySourceCurrency {
        fn from(value: &InitiateUserFiatOfframpBodySourceCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpBodySourceCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpBodySourceCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpBodySourceCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOfframpBodySourceCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOfframpBodySourceCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "deposit_instructions": {
    ///        "amount": "100.0",
    ///        "chain": "base",
    ///        "currency": "usdc",
    ///        "from_address": "0xc24272abc794b973b896715db40a72714a030323",
    ///        "to_address": "0xdeadbeef2usdcbase"
    ///      },
    ///      "id": "d220bcf7-4ad5-4687-8a61-e51c5875225e",
    ///      "status": "awaiting_funds"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "deposit_instructions",
    ///    "id",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "deposit_instructions": {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "chain",
    ///        "currency",
    ///        "from_address",
    ///        "to_address"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "type": "string"
    ///        },
    ///        "chain": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ethereum",
    ///            "base",
    ///            "arbitrum",
    ///            "polygon",
    ///            "optimism"
    ///          ]
    ///        },
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usdc"
    ///          ]
    ///        },
    ///        "from_address": {
    ///          "type": "string"
    ///        },
    ///        "to_address": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awaiting_funds",
    ///        "in_review",
    ///        "funds_received",
    ///        "payment_submitted",
    ///        "payment_processed",
    ///        "canceled",
    ///        "error",
    ///        "undeliverable",
    ///        "returned",
    ///        "refunded"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOfframpResponse {
        pub deposit_instructions: InitiateUserFiatOfframpResponseDepositInstructions,
        pub id: ::std::string::String,
        pub status: InitiateUserFiatOfframpResponseStatus,
    }

    impl ::std::convert::From<&InitiateUserFiatOfframpResponse> for InitiateUserFiatOfframpResponse {
        fn from(value: &InitiateUserFiatOfframpResponse) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOfframpResponseDepositInstructions`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "chain",
    ///    "currency",
    ///    "from_address",
    ///    "to_address"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "type": "string"
    ///    },
    ///    "chain": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum",
    ///        "base",
    ///        "arbitrum",
    ///        "polygon",
    ///        "optimism"
    ///      ]
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usdc"
    ///      ]
    ///    },
    ///    "from_address": {
    ///      "type": "string"
    ///    },
    ///    "to_address": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOfframpResponseDepositInstructions {
        pub amount: ::std::string::String,
        pub chain: InitiateUserFiatOfframpResponseDepositInstructionsChain,
        pub currency: InitiateUserFiatOfframpResponseDepositInstructionsCurrency,
        pub from_address: ::std::string::String,
        pub to_address: ::std::string::String,
    }

    impl ::std::convert::From<&InitiateUserFiatOfframpResponseDepositInstructions>
        for InitiateUserFiatOfframpResponseDepositInstructions
    {
        fn from(value: &InitiateUserFiatOfframpResponseDepositInstructions) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOfframpResponseDepositInstructionsChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "base",
    ///    "arbitrum",
    ///    "polygon",
    ///    "optimism"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpResponseDepositInstructionsChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpResponseDepositInstructionsChain {
        fn from(value: &InitiateUserFiatOfframpResponseDepositInstructionsChain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpResponseDepositInstructionsChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Base => f.write_str("base"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpResponseDepositInstructionsChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "base" => Ok(Self::Base),
                "arbitrum" => Ok(Self::Arbitrum),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpResponseDepositInstructionsChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOfframpResponseDepositInstructionsChain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOfframpResponseDepositInstructionsChain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpResponseDepositInstructionsCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpResponseDepositInstructionsCurrency {
        #[serde(rename = "usdc")]
        Usdc,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpResponseDepositInstructionsCurrency {
        fn from(value: &InitiateUserFiatOfframpResponseDepositInstructionsCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpResponseDepositInstructionsCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpResponseDepositInstructionsCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpResponseDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOfframpResponseDepositInstructionsCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOfframpResponseDepositInstructionsCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOfframpResponseStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awaiting_funds",
    ///    "in_review",
    ///    "funds_received",
    ///    "payment_submitted",
    ///    "payment_processed",
    ///    "canceled",
    ///    "error",
    ///    "undeliverable",
    ///    "returned",
    ///    "refunded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOfframpResponseStatus {
        #[serde(rename = "awaiting_funds")]
        AwaitingFunds,
        #[serde(rename = "in_review")]
        InReview,
        #[serde(rename = "funds_received")]
        FundsReceived,
        #[serde(rename = "payment_submitted")]
        PaymentSubmitted,
        #[serde(rename = "payment_processed")]
        PaymentProcessed,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "undeliverable")]
        Undeliverable,
        #[serde(rename = "returned")]
        Returned,
        #[serde(rename = "refunded")]
        Refunded,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOfframpResponseStatus {
        fn from(value: &InitiateUserFiatOfframpResponseStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOfframpResponseStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwaitingFunds => f.write_str("awaiting_funds"),
                Self::InReview => f.write_str("in_review"),
                Self::FundsReceived => f.write_str("funds_received"),
                Self::PaymentSubmitted => f.write_str("payment_submitted"),
                Self::PaymentProcessed => f.write_str("payment_processed"),
                Self::Canceled => f.write_str("canceled"),
                Self::Error => f.write_str("error"),
                Self::Undeliverable => f.write_str("undeliverable"),
                Self::Returned => f.write_str("returned"),
                Self::Refunded => f.write_str("refunded"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOfframpResponseStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awaiting_funds" => Ok(Self::AwaitingFunds),
                "in_review" => Ok(Self::InReview),
                "funds_received" => Ok(Self::FundsReceived),
                "payment_submitted" => Ok(Self::PaymentSubmitted),
                "payment_processed" => Ok(Self::PaymentProcessed),
                "canceled" => Ok(Self::Canceled),
                "error" => Ok(Self::Error),
                "undeliverable" => Ok(Self::Undeliverable),
                "returned" => Ok(Self::Returned),
                "refunded" => Ok(Self::Refunded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOfframpResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOfframpResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOfframpResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "amount": "100.00",
    ///      "destination": {
    ///        "chain": "base",
    ///        "currency": "usdc",
    ///        "to_address": "0x38Bc05d7b69F63D05337829fA5Dc4896F179B5fA"
    ///      },
    ///      "provider": "bridge-sandbox",
    ///      "source": {
    ///        "currency": "usd",
    ///        "payment_rail": "ach_push"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "destination",
    ///    "provider",
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "destination": {
    ///      "type": "object",
    ///      "required": [
    ///        "chain",
    ///        "currency",
    ///        "to_address"
    ///      ],
    ///      "properties": {
    ///        "chain": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ethereum",
    ///            "base",
    ///            "arbitrum",
    ///            "polygon",
    ///            "optimism"
    ///          ]
    ///        },
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usdc"
    ///          ]
    ///        },
    ///        "to_address": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "provider": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bridge",
    ///        "bridge-sandbox"
    ///      ]
    ///    },
    ///    "source": {
    ///      "type": "object",
    ///      "required": [
    ///        "currency",
    ///        "payment_rail"
    ///      ],
    ///      "properties": {
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usd",
    ///            "eur"
    ///          ]
    ///        },
    ///        "payment_rail": {
    ///          "type": "string",
    ///          "enum": [
    ///            "sepa",
    ///            "ach_push",
    ///            "wire"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOnrampBody {
        pub amount: InitiateUserFiatOnrampBodyAmount,
        pub destination: InitiateUserFiatOnrampBodyDestination,
        pub provider: InitiateUserFiatOnrampBodyProvider,
        pub source: InitiateUserFiatOnrampBodySource,
    }

    impl ::std::convert::From<&InitiateUserFiatOnrampBody> for InitiateUserFiatOnrampBody {
        fn from(value: &InitiateUserFiatOnrampBody) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOnrampBodyAmount`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct InitiateUserFiatOnrampBodyAmount(::std::string::String);
    impl ::std::ops::Deref for InitiateUserFiatOnrampBodyAmount {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<InitiateUserFiatOnrampBodyAmount> for ::std::string::String {
        fn from(value: InitiateUserFiatOnrampBodyAmount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InitiateUserFiatOnrampBodyAmount> for InitiateUserFiatOnrampBodyAmount {
        fn from(value: &InitiateUserFiatOnrampBodyAmount) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampBodyAmount {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampBodyAmount {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOnrampBodyAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOnrampBodyAmount {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for InitiateUserFiatOnrampBodyAmount {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`InitiateUserFiatOnrampBodyDestination`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "chain",
    ///    "currency",
    ///    "to_address"
    ///  ],
    ///  "properties": {
    ///    "chain": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum",
    ///        "base",
    ///        "arbitrum",
    ///        "polygon",
    ///        "optimism"
    ///      ]
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usdc"
    ///      ]
    ///    },
    ///    "to_address": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOnrampBodyDestination {
        pub chain: InitiateUserFiatOnrampBodyDestinationChain,
        pub currency: InitiateUserFiatOnrampBodyDestinationCurrency,
        pub to_address: ::std::string::String,
    }

    impl ::std::convert::From<&InitiateUserFiatOnrampBodyDestination>
        for InitiateUserFiatOnrampBodyDestination
    {
        fn from(value: &InitiateUserFiatOnrampBodyDestination) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOnrampBodyDestinationChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "base",
    ///    "arbitrum",
    ///    "polygon",
    ///    "optimism"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampBodyDestinationChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampBodyDestinationChain {
        fn from(value: &InitiateUserFiatOnrampBodyDestinationChain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampBodyDestinationChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Base => f.write_str("base"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampBodyDestinationChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "base" => Ok(Self::Base),
                "arbitrum" => Ok(Self::Arbitrum),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampBodyDestinationChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOnrampBodyDestinationChain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOnrampBodyDestinationChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampBodyDestinationCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampBodyDestinationCurrency {
        #[serde(rename = "usdc")]
        Usdc,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampBodyDestinationCurrency {
        fn from(value: &InitiateUserFiatOnrampBodyDestinationCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampBodyDestinationCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampBodyDestinationCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampBodyDestinationCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOnrampBodyDestinationCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOnrampBodyDestinationCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampBodyProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampBodyProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampBodyProvider {
        fn from(value: &InitiateUserFiatOnrampBodyProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampBodyProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampBodyProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOnrampBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOnrampBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampBodySource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "currency",
    ///    "payment_rail"
    ///  ],
    ///  "properties": {
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usd",
    ///        "eur"
    ///      ]
    ///    },
    ///    "payment_rail": {
    ///      "type": "string",
    ///      "enum": [
    ///        "sepa",
    ///        "ach_push",
    ///        "wire"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOnrampBodySource {
        pub currency: InitiateUserFiatOnrampBodySourceCurrency,
        pub payment_rail: InitiateUserFiatOnrampBodySourcePaymentRail,
    }

    impl ::std::convert::From<&InitiateUserFiatOnrampBodySource> for InitiateUserFiatOnrampBodySource {
        fn from(value: &InitiateUserFiatOnrampBodySource) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOnrampBodySourceCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usd",
    ///    "eur"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampBodySourceCurrency {
        #[serde(rename = "usd")]
        Usd,
        #[serde(rename = "eur")]
        Eur,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampBodySourceCurrency {
        fn from(value: &InitiateUserFiatOnrampBodySourceCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampBodySourceCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
                Self::Eur => f.write_str("eur"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampBodySourceCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                "eur" => Ok(Self::Eur),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampBodySourceCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOnrampBodySourceCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOnrampBodySourceCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampBodySourcePaymentRail`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "sepa",
    ///    "ach_push",
    ///    "wire"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampBodySourcePaymentRail {
        #[serde(rename = "sepa")]
        Sepa,
        #[serde(rename = "ach_push")]
        AchPush,
        #[serde(rename = "wire")]
        Wire,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampBodySourcePaymentRail {
        fn from(value: &InitiateUserFiatOnrampBodySourcePaymentRail) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampBodySourcePaymentRail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sepa => f.write_str("sepa"),
                Self::AchPush => f.write_str("ach_push"),
                Self::Wire => f.write_str("wire"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampBodySourcePaymentRail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sepa" => Ok(Self::Sepa),
                "ach_push" => Ok(Self::AchPush),
                "wire" => Ok(Self::Wire),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampBodySourcePaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOnrampBodySourcePaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOnrampBodySourcePaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "deposit_instructions": {
    ///        "amount": "100.0",
    ///        "bank_account_number": "11223344556677",
    ///        "bank_address": "1800 North Pole St., Orlando, FL 32801",
    ///        "bank_beneficiary_address": "1234 Elm St, Springfield, IL 12345",
    ///        "bank_beneficiary_name": "Bridge Ventures Inc",
    ///        "bank_name": "Bank of Nowhere",
    ///        "bank_routing_number": "123456789",
    ///        "currency": "usd",
    ///        "deposit_message": "BRGFU2Z9TJPJXCS7ZZK2",
    ///        "payment_rail": "ach_push"
    ///      },
    ///      "id": "3a61a69a-1f20-4113-85f5-997078166729",
    ///      "status": "awaiting_funds"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "deposit_instructions",
    ///    "id",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "deposit_instructions": {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "currency",
    ///        "payment_rail"
    ///      ],
    ///      "properties": {
    ///        "account_holder_name": {
    ///          "type": "string"
    ///        },
    ///        "amount": {
    ///          "type": "string"
    ///        },
    ///        "bank_account_number": {
    ///          "type": "string"
    ///        },
    ///        "bank_address": {
    ///          "type": "string"
    ///        },
    ///        "bank_beneficiary_address": {
    ///          "type": "string"
    ///        },
    ///        "bank_beneficiary_name": {
    ///          "type": "string"
    ///        },
    ///        "bank_name": {
    ///          "type": "string"
    ///        },
    ///        "bank_routing_number": {
    ///          "type": "string"
    ///        },
    ///        "bic": {
    ///          "type": "string"
    ///        },
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usd",
    ///            "eur"
    ///          ]
    ///        },
    ///        "deposit_message": {
    ///          "type": "string"
    ///        },
    ///        "iban": {
    ///          "type": "string"
    ///        },
    ///        "payment_rail": {
    ///          "type": "string",
    ///          "enum": [
    ///            "sepa",
    ///            "ach_push",
    ///            "wire"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awaiting_funds",
    ///        "in_review",
    ///        "funds_received",
    ///        "payment_submitted",
    ///        "payment_processed",
    ///        "canceled",
    ///        "error",
    ///        "undeliverable",
    ///        "returned",
    ///        "refunded"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOnrampResponse {
        pub deposit_instructions: InitiateUserFiatOnrampResponseDepositInstructions,
        pub id: ::std::string::String,
        pub status: InitiateUserFiatOnrampResponseStatus,
    }

    impl ::std::convert::From<&InitiateUserFiatOnrampResponse> for InitiateUserFiatOnrampResponse {
        fn from(value: &InitiateUserFiatOnrampResponse) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOnrampResponseDepositInstructions`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "currency",
    ///    "payment_rail"
    ///  ],
    ///  "properties": {
    ///    "account_holder_name": {
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "type": "string"
    ///    },
    ///    "bank_account_number": {
    ///      "type": "string"
    ///    },
    ///    "bank_address": {
    ///      "type": "string"
    ///    },
    ///    "bank_beneficiary_address": {
    ///      "type": "string"
    ///    },
    ///    "bank_beneficiary_name": {
    ///      "type": "string"
    ///    },
    ///    "bank_name": {
    ///      "type": "string"
    ///    },
    ///    "bank_routing_number": {
    ///      "type": "string"
    ///    },
    ///    "bic": {
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usd",
    ///        "eur"
    ///      ]
    ///    },
    ///    "deposit_message": {
    ///      "type": "string"
    ///    },
    ///    "iban": {
    ///      "type": "string"
    ///    },
    ///    "payment_rail": {
    ///      "type": "string",
    ///      "enum": [
    ///        "sepa",
    ///        "ach_push",
    ///        "wire"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InitiateUserFiatOnrampResponseDepositInstructions {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_holder_name: ::std::option::Option<::std::string::String>,
        pub amount: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bic: ::std::option::Option<::std::string::String>,
        pub currency: InitiateUserFiatOnrampResponseDepositInstructionsCurrency,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deposit_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub iban: ::std::option::Option<::std::string::String>,
        pub payment_rail: InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail,
    }

    impl ::std::convert::From<&InitiateUserFiatOnrampResponseDepositInstructions>
        for InitiateUserFiatOnrampResponseDepositInstructions
    {
        fn from(value: &InitiateUserFiatOnrampResponseDepositInstructions) -> Self {
            value.clone()
        }
    }

    ///`InitiateUserFiatOnrampResponseDepositInstructionsCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usd",
    ///    "eur"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampResponseDepositInstructionsCurrency {
        #[serde(rename = "usd")]
        Usd,
        #[serde(rename = "eur")]
        Eur,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampResponseDepositInstructionsCurrency {
        fn from(value: &InitiateUserFiatOnrampResponseDepositInstructionsCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampResponseDepositInstructionsCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
                Self::Eur => f.write_str("eur"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampResponseDepositInstructionsCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                "eur" => Ok(Self::Eur),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampResponseDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOnrampResponseDepositInstructionsCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOnrampResponseDepositInstructionsCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "sepa",
    ///    "ach_push",
    ///    "wire"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail {
        #[serde(rename = "sepa")]
        Sepa,
        #[serde(rename = "ach_push")]
        AchPush,
        #[serde(rename = "wire")]
        Wire,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail {
        fn from(value: &InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sepa => f.write_str("sepa"),
                Self::AchPush => f.write_str("ach_push"),
                Self::Wire => f.write_str("wire"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sepa" => Ok(Self::Sepa),
                "ach_push" => Ok(Self::AchPush),
                "wire" => Ok(Self::Wire),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for InitiateUserFiatOnrampResponseDepositInstructionsPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`InitiateUserFiatOnrampResponseStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awaiting_funds",
    ///    "in_review",
    ///    "funds_received",
    ///    "payment_submitted",
    ///    "payment_processed",
    ///    "canceled",
    ///    "error",
    ///    "undeliverable",
    ///    "returned",
    ///    "refunded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum InitiateUserFiatOnrampResponseStatus {
        #[serde(rename = "awaiting_funds")]
        AwaitingFunds,
        #[serde(rename = "in_review")]
        InReview,
        #[serde(rename = "funds_received")]
        FundsReceived,
        #[serde(rename = "payment_submitted")]
        PaymentSubmitted,
        #[serde(rename = "payment_processed")]
        PaymentProcessed,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "undeliverable")]
        Undeliverable,
        #[serde(rename = "returned")]
        Returned,
        #[serde(rename = "refunded")]
        Refunded,
    }

    impl ::std::convert::From<&Self> for InitiateUserFiatOnrampResponseStatus {
        fn from(value: &InitiateUserFiatOnrampResponseStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InitiateUserFiatOnrampResponseStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwaitingFunds => f.write_str("awaiting_funds"),
                Self::InReview => f.write_str("in_review"),
                Self::FundsReceived => f.write_str("funds_received"),
                Self::PaymentSubmitted => f.write_str("payment_submitted"),
                Self::PaymentProcessed => f.write_str("payment_processed"),
                Self::Canceled => f.write_str("canceled"),
                Self::Error => f.write_str("error"),
                Self::Undeliverable => f.write_str("undeliverable"),
                Self::Returned => f.write_str("returned"),
                Self::Refunded => f.write_str("refunded"),
            }
        }
    }

    impl ::std::str::FromStr for InitiateUserFiatOnrampResponseStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awaiting_funds" => Ok(Self::AwaitingFunds),
                "in_review" => Ok(Self::InReview),
                "funds_received" => Ok(Self::FundsReceived),
                "payment_submitted" => Ok(Self::PaymentSubmitted),
                "payment_processed" => Ok(Self::PaymentProcessed),
                "canceled" => Ok(Self::Canceled),
                "error" => Ok(Self::Error),
                "undeliverable" => Ok(Self::Undeliverable),
                "returned" => Ok(Self::Returned),
                "refunded" => Ok(Self::Refunded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InitiateUserFiatOnrampResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InitiateUserFiatOnrampResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InitiateUserFiatOnrampResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`KeyQuorum`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "authorization_keys": [
    ///        {
    ///          "display_name": null,
    ///          "public_key": "-----BEGIN PUBLIC
    /// KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/
    /// ckqE2CItVIG\n1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/
    /// C9yjhboIuoPD3g==\n-----END PUBLIC KEY-----"
    ///        },
    ///        {
    ///          "display_name": null,
    ///          "public_key": "-----BEGIN PUBLIC
    /// KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAErzZtQr/bMIh3Y8f9ZqseB9i/
    /// AfjQ\nhu+agbNqXcJy/TfoNqvc/Y3Mh7gIZ8ZLXQEykycx4mYSpqrxp1lBKqsZDQ==\
    /// n-----END PUBLIC KEY-----\","
    ///        }
    ///      ],
    ///      "authorization_threshold": 1,
    ///      "display_name": "Prod key quorum",
    ///      "id": "tb54eps4z44ed0jepousxi4n"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "authorization_keys",
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "authorization_keys": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "display_name",
    ///          "public_key"
    ///        ],
    ///        "properties": {
    ///          "display_name": {
    ///            "type": [
    ///              "string",
    ///              "null"
    ///            ],
    ///            "maxLength": 50
    ///          },
    ///          "public_key": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "authorization_threshold": {
    ///      "type": "number",
    ///      "minimum": 1.0
    ///    },
    ///    "display_name": {
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "user_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KeyQuorum {
        pub authorization_keys: ::std::vec::Vec<KeyQuorumAuthorizationKeysItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authorization_threshold: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<KeyQuorumDisplayName>,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub user_ids: ::std::vec::Vec<::std::string::String>,
    }

    impl ::std::convert::From<&KeyQuorum> for KeyQuorum {
        fn from(value: &KeyQuorum) -> Self {
            value.clone()
        }
    }

    ///`KeyQuorumAuthorizationKeysItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "public_key"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "maxLength": 50
    ///    },
    ///    "public_key": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KeyQuorumAuthorizationKeysItem {
        pub display_name: ::std::option::Option<KeyQuorumAuthorizationKeysItemDisplayName>,
        pub public_key: ::std::string::String,
    }

    impl ::std::convert::From<&KeyQuorumAuthorizationKeysItem> for KeyQuorumAuthorizationKeysItem {
        fn from(value: &KeyQuorumAuthorizationKeysItem) -> Self {
            value.clone()
        }
    }

    ///`KeyQuorumAuthorizationKeysItemDisplayName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct KeyQuorumAuthorizationKeysItemDisplayName(::std::string::String);
    impl ::std::ops::Deref for KeyQuorumAuthorizationKeysItemDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<KeyQuorumAuthorizationKeysItemDisplayName> for ::std::string::String {
        fn from(value: KeyQuorumAuthorizationKeysItemDisplayName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&KeyQuorumAuthorizationKeysItemDisplayName>
        for KeyQuorumAuthorizationKeysItemDisplayName
    {
        fn from(value: &KeyQuorumAuthorizationKeysItemDisplayName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for KeyQuorumAuthorizationKeysItemDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for KeyQuorumAuthorizationKeysItemDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for KeyQuorumAuthorizationKeysItemDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for KeyQuorumAuthorizationKeysItemDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for KeyQuorumAuthorizationKeysItemDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`KeyQuorumDisplayName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct KeyQuorumDisplayName(::std::string::String);
    impl ::std::ops::Deref for KeyQuorumDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<KeyQuorumDisplayName> for ::std::string::String {
        fn from(value: KeyQuorumDisplayName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&KeyQuorumDisplayName> for KeyQuorumDisplayName {
        fn from(value: &KeyQuorumDisplayName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for KeyQuorumDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for KeyQuorumDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for KeyQuorumDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for KeyQuorumDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for KeyQuorumDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`KycStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "status",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "provider_user_id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "not_found",
    ///        "active",
    ///        "awaiting_questionnaire",
    ///        "awaiting_ubo",
    ///        "incomplete",
    ///        "not_started",
    ///        "offboarded",
    ///        "paused",
    ///        "rejected",
    ///        "under_review"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KycStatus {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub provider_user_id: ::std::option::Option<::std::string::String>,
        pub status: KycStatusStatus,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&KycStatus> for KycStatus {
        fn from(value: &KycStatus) -> Self {
            value.clone()
        }
    }

    ///`KycStatusStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "not_found",
    ///    "active",
    ///    "awaiting_questionnaire",
    ///    "awaiting_ubo",
    ///    "incomplete",
    ///    "not_started",
    ///    "offboarded",
    ///    "paused",
    ///    "rejected",
    ///    "under_review"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum KycStatusStatus {
        #[serde(rename = "not_found")]
        NotFound,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "awaiting_questionnaire")]
        AwaitingQuestionnaire,
        #[serde(rename = "awaiting_ubo")]
        AwaitingUbo,
        #[serde(rename = "incomplete")]
        Incomplete,
        #[serde(rename = "not_started")]
        NotStarted,
        #[serde(rename = "offboarded")]
        Offboarded,
        #[serde(rename = "paused")]
        Paused,
        #[serde(rename = "rejected")]
        Rejected,
        #[serde(rename = "under_review")]
        UnderReview,
    }

    impl ::std::convert::From<&Self> for KycStatusStatus {
        fn from(value: &KycStatusStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for KycStatusStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NotFound => f.write_str("not_found"),
                Self::Active => f.write_str("active"),
                Self::AwaitingQuestionnaire => f.write_str("awaiting_questionnaire"),
                Self::AwaitingUbo => f.write_str("awaiting_ubo"),
                Self::Incomplete => f.write_str("incomplete"),
                Self::NotStarted => f.write_str("not_started"),
                Self::Offboarded => f.write_str("offboarded"),
                Self::Paused => f.write_str("paused"),
                Self::Rejected => f.write_str("rejected"),
                Self::UnderReview => f.write_str("under_review"),
            }
        }
    }

    impl ::std::str::FromStr for KycStatusStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "not_found" => Ok(Self::NotFound),
                "active" => Ok(Self::Active),
                "awaiting_questionnaire" => Ok(Self::AwaitingQuestionnaire),
                "awaiting_ubo" => Ok(Self::AwaitingUbo),
                "incomplete" => Ok(Self::Incomplete),
                "not_started" => Ok(Self::NotStarted),
                "offboarded" => Ok(Self::Offboarded),
                "paused" => Ok(Self::Paused),
                "rejected" => Ok(Self::Rejected),
                "under_review" => Ok(Self::UnderReview),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for KycStatusStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for KycStatusStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for KycStatusStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkEmailRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "LinkEmailRequestBody",
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "email",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "type": "string",
    ///      "maxLength": 6,
    ///      "minLength": 6
    ///    },
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkEmailRequestBody {
        pub code: LinkEmailRequestBodyCode,
        pub email: ::std::string::String,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&LinkEmailRequestBody> for LinkEmailRequestBody {
        fn from(value: &LinkEmailRequestBody) -> Self {
            value.clone()
        }
    }

    ///`LinkEmailRequestBodyCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 6,
    ///  "minLength": 6
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkEmailRequestBodyCode(::std::string::String);
    impl ::std::ops::Deref for LinkEmailRequestBodyCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkEmailRequestBodyCode> for ::std::string::String {
        fn from(value: LinkEmailRequestBodyCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkEmailRequestBodyCode> for LinkEmailRequestBodyCode {
        fn from(value: &LinkEmailRequestBodyCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkEmailRequestBodyCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 6usize {
                return Err("longer than 6 characters".into());
            }
            if value.chars().count() < 6usize {
                return Err("shorter than 6 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkEmailRequestBodyCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountAppleInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Apple",
    ///  "type": "object",
    ///  "required": [
    ///    "subject",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "apple_oauth"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountAppleInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountAppleInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountAppleInputType,
    }

    impl ::std::convert::From<&LinkedAccountAppleInput> for LinkedAccountAppleInput {
        fn from(value: &LinkedAccountAppleInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountAppleInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountAppleInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountAppleInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountAppleInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountAppleInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountAppleInputSubject> for LinkedAccountAppleInputSubject {
        fn from(value: &LinkedAccountAppleInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountAppleInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountAppleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAppleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAppleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountAppleInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountAppleInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "apple_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountAppleInputType {
        #[serde(rename = "apple_oauth")]
        AppleOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountAppleInputType {
        fn from(value: &LinkedAccountAppleInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountAppleInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AppleOauth => f.write_str("apple_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountAppleInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "apple_oauth" => Ok(Self::AppleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountAppleInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAppleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAppleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountAppleOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Apple",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "subject",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "apple_oauth"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountAppleOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountAppleOauthType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountAppleOauth> for LinkedAccountAppleOauth {
        fn from(value: &LinkedAccountAppleOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountAppleOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "apple_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountAppleOauthType {
        #[serde(rename = "apple_oauth")]
        AppleOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountAppleOauthType {
        fn from(value: &LinkedAccountAppleOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountAppleOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AppleOauth => f.write_str("apple_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountAppleOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "apple_oauth" => Ok(Self::AppleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountAppleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAppleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAppleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountAuthorizationKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Authorization Key",
    ///  "type": "object",
    ///  "required": [
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "public_key",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "authorization_key"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountAuthorizationKey {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub public_key: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountAuthorizationKeyType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountAuthorizationKey> for LinkedAccountAuthorizationKey {
        fn from(value: &LinkedAccountAuthorizationKey) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountAuthorizationKeyType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "authorization_key"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountAuthorizationKeyType {
        #[serde(rename = "authorization_key")]
        AuthorizationKey,
    }

    impl ::std::convert::From<&Self> for LinkedAccountAuthorizationKeyType {
        fn from(value: &LinkedAccountAuthorizationKeyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountAuthorizationKeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AuthorizationKey => f.write_str("authorization_key"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountAuthorizationKeyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "authorization_key" => Ok(Self::AuthorizationKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountAuthorizationKeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountAuthorizationKeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountAuthorizationKeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinSegwitEmbeddedWallet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Bitcoin Segwit Embedded Wallet",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_id",
    ///    "chain_type",
    ///    "connector_type",
    ///    "delegated",
    ///    "first_verified_at",
    ///    "id",
    ///    "imported",
    ///    "latest_verified_at",
    ///    "public_key",
    ///    "recovery_method",
    ///    "type",
    ///    "verified_at",
    ///    "wallet_client",
    ///    "wallet_client_type",
    ///    "wallet_index"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_id": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bitcoin-segwit"
    ///      ]
    ///    },
    ///    "connector_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "embedded"
    ///      ]
    ///    },
    ///    "delegated": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "imported": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "type": "string"
    ///    },
    ///    "recovery_method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy",
    ///        "user-passcode",
    ///        "google-drive",
    ///        "icloud",
    ///        "recovery-encryption-key",
    ///        "privy-v2"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "wallet"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    },
    ///    "wallet_client": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_client_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_index": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountBitcoinSegwitEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountBitcoinSegwitEmbeddedWalletChainType,
        pub connector_type: LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub public_key: ::std::string::String,
        pub recovery_method: LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountBitcoinSegwitEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }

    impl ::std::convert::From<&LinkedAccountBitcoinSegwitEmbeddedWallet>
        for LinkedAccountBitcoinSegwitEmbeddedWallet
    {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWallet) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountBitcoinSegwitEmbeddedWalletChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bitcoin-segwit"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "embedded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy",
    ///    "user-passcode",
    ///    "google-drive",
    ///    "icloud",
    ///    "recovery-encryption-key",
    ///    "privy-v2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinSegwitEmbeddedWalletType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinSegwitEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinTaprootEmbeddedWallet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Bitcoin Taproot Embedded Wallet",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_id",
    ///    "chain_type",
    ///    "connector_type",
    ///    "delegated",
    ///    "first_verified_at",
    ///    "id",
    ///    "imported",
    ///    "latest_verified_at",
    ///    "public_key",
    ///    "recovery_method",
    ///    "type",
    ///    "verified_at",
    ///    "wallet_client",
    ///    "wallet_client_type",
    ///    "wallet_index"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_id": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bitcoin-taproot"
    ///      ]
    ///    },
    ///    "connector_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "embedded"
    ///      ]
    ///    },
    ///    "delegated": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "imported": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "type": "string"
    ///    },
    ///    "recovery_method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy",
    ///        "user-passcode",
    ///        "google-drive",
    ///        "icloud",
    ///        "recovery-encryption-key",
    ///        "privy-v2"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "wallet"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    },
    ///    "wallet_client": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_client_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_index": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountBitcoinTaprootEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountBitcoinTaprootEmbeddedWalletChainType,
        pub connector_type: LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub public_key: ::std::string::String,
        pub recovery_method: LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountBitcoinTaprootEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }

    impl ::std::convert::From<&LinkedAccountBitcoinTaprootEmbeddedWallet>
        for LinkedAccountBitcoinTaprootEmbeddedWallet
    {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWallet) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountBitcoinTaprootEmbeddedWalletChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bitcoin-taproot"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        #[serde(rename = "bitcoin-taproot")]
        BitcoinTaproot,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::BitcoinTaproot => f.write_str("bitcoin-taproot"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bitcoin-taproot" => Ok(Self::BitcoinTaproot),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "embedded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy",
    ///    "user-passcode",
    ///    "google-drive",
    ///    "icloud",
    ///    "recovery-encryption-key",
    ///    "privy-v2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinTaprootEmbeddedWalletType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountBitcoinTaprootEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountCrossApp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "CrossApp",
    ///  "type": "object",
    ///  "required": [
    ///    "embedded_wallets",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "provider_app_id",
    ///    "smart_wallets",
    ///    "subject",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "embedded_wallets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "address"
    ///        ],
    ///        "properties": {
    ///          "address": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "provider_app_id": {
    ///      "type": "string"
    ///    },
    ///    "smart_wallets": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "address"
    ///        ],
    ///        "properties": {
    ///          "address": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "cross_app"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCrossApp {
        pub embedded_wallets: ::std::vec::Vec<LinkedAccountCrossAppEmbeddedWalletsItem>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub provider_app_id: ::std::string::String,
        pub smart_wallets: ::std::vec::Vec<LinkedAccountCrossAppSmartWalletsItem>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountCrossAppType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountCrossApp> for LinkedAccountCrossApp {
        fn from(value: &LinkedAccountCrossApp) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountCrossAppEmbeddedWalletsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCrossAppEmbeddedWalletsItem {
        pub address: ::std::string::String,
    }

    impl ::std::convert::From<&LinkedAccountCrossAppEmbeddedWalletsItem>
        for LinkedAccountCrossAppEmbeddedWalletsItem
    {
        fn from(value: &LinkedAccountCrossAppEmbeddedWalletsItem) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountCrossAppSmartWalletsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCrossAppSmartWalletsItem {
        pub address: ::std::string::String,
    }

    impl ::std::convert::From<&LinkedAccountCrossAppSmartWalletsItem>
        for LinkedAccountCrossAppSmartWalletsItem
    {
        fn from(value: &LinkedAccountCrossAppSmartWalletsItem) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountCrossAppType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "cross_app"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountCrossAppType {
        #[serde(rename = "cross_app")]
        CrossApp,
    }

    impl ::std::convert::From<&Self> for LinkedAccountCrossAppType {
        fn from(value: &LinkedAccountCrossAppType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountCrossAppType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CrossApp => f.write_str("cross_app"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountCrossAppType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "cross_app" => Ok(Self::CrossApp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountCrossAppType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCrossAppType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCrossAppType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountCustomJwt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Custom Jwt",
    ///  "type": "object",
    ///  "required": [
    ///    "custom_user_id",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "custom_user_id": {
    ///      "type": "string"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "custom_auth"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCustomJwt {
        pub custom_user_id: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountCustomJwtType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountCustomJwt> for LinkedAccountCustomJwt {
        fn from(value: &LinkedAccountCustomJwt) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountCustomJwtInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Custom JWT",
    ///  "type": "object",
    ///  "required": [
    ///    "custom_user_id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "custom_user_id": {
    ///      "type": "string",
    ///      "maxLength": 256,
    ///      "minLength": 1
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "custom_auth"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountCustomJwtInput {
        pub custom_user_id: LinkedAccountCustomJwtInputCustomUserId,
        #[serde(rename = "type")]
        pub type_: LinkedAccountCustomJwtInputType,
    }

    impl ::std::convert::From<&LinkedAccountCustomJwtInput> for LinkedAccountCustomJwtInput {
        fn from(value: &LinkedAccountCustomJwtInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountCustomJwtInputCustomUserId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountCustomJwtInputCustomUserId(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountCustomJwtInputCustomUserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountCustomJwtInputCustomUserId> for ::std::string::String {
        fn from(value: LinkedAccountCustomJwtInputCustomUserId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountCustomJwtInputCustomUserId>
        for LinkedAccountCustomJwtInputCustomUserId
    {
        fn from(value: &LinkedAccountCustomJwtInputCustomUserId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountCustomJwtInputCustomUserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountCustomJwtInputCustomUserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCustomJwtInputCustomUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCustomJwtInputCustomUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountCustomJwtInputCustomUserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountCustomJwtInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "custom_auth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountCustomJwtInputType {
        #[serde(rename = "custom_auth")]
        CustomAuth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountCustomJwtInputType {
        fn from(value: &LinkedAccountCustomJwtInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountCustomJwtInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CustomAuth => f.write_str("custom_auth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountCustomJwtInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom_auth" => Ok(Self::CustomAuth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountCustomJwtInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCustomJwtInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCustomJwtInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountCustomJwtType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "custom_auth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountCustomJwtType {
        #[serde(rename = "custom_auth")]
        CustomAuth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountCustomJwtType {
        fn from(value: &LinkedAccountCustomJwtType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountCustomJwtType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CustomAuth => f.write_str("custom_auth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountCustomJwtType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "custom_auth" => Ok(Self::CustomAuth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountCustomJwtType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountCustomJwtType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountCustomJwtType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountDiscordInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Discord",
    ///  "type": "object",
    ///  "required": [
    ///    "subject",
    ///    "type",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "discord_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string",
    ///      "pattern":
    /// "^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountDiscordInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountDiscordInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountDiscordInputType,
        pub username: LinkedAccountDiscordInputUsername,
    }

    impl ::std::convert::From<&LinkedAccountDiscordInput> for LinkedAccountDiscordInput {
        fn from(value: &LinkedAccountDiscordInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountDiscordInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountDiscordInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountDiscordInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountDiscordInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountDiscordInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountDiscordInputSubject> for LinkedAccountDiscordInputSubject {
        fn from(value: &LinkedAccountDiscordInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountDiscordInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountDiscordInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountDiscordInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "discord_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountDiscordInputType {
        #[serde(rename = "discord_oauth")]
        DiscordOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountDiscordInputType {
        fn from(value: &LinkedAccountDiscordInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountDiscordInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::DiscordOauth => f.write_str("discord_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountDiscordInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "discord_oauth" => Ok(Self::DiscordOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountDiscordInputUsername`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern":
    /// "^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountDiscordInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountDiscordInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountDiscordInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountDiscordInputUsername) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountDiscordInputUsername>
        for LinkedAccountDiscordInputUsername
    {
        fn from(value: &LinkedAccountDiscordInputUsername) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountDiscordInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new(
                        "^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$",
                    )
                    .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err ("doesn't match pattern \"^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$\"" . into ()) ;
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountDiscordInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountDiscordOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Discord",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "subject",
    ///    "type",
    ///    "username",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "discord_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountDiscordOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountDiscordOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountDiscordOauth> for LinkedAccountDiscordOauth {
        fn from(value: &LinkedAccountDiscordOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountDiscordOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "discord_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountDiscordOauthType {
        #[serde(rename = "discord_oauth")]
        DiscordOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountDiscordOauthType {
        fn from(value: &LinkedAccountDiscordOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountDiscordOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::DiscordOauth => f.write_str("discord_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountDiscordOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "discord_oauth" => Ok(Self::DiscordOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountDiscordOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountDiscordOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountDiscordOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEmail`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Email",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "email"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEmail {
        pub address: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEmailType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountEmail> for LinkedAccountEmail {
        fn from(value: &LinkedAccountEmail) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountEmailInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Email",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "email"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEmailInput {
        pub address: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEmailInputType,
    }

    impl ::std::convert::From<&LinkedAccountEmailInput> for LinkedAccountEmailInput {
        fn from(value: &LinkedAccountEmailInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountEmailInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "email"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEmailInputType {
        #[serde(rename = "email")]
        Email,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEmailInputType {
        fn from(value: &LinkedAccountEmailInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEmailInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEmailInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEmailInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEmailInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEmailInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEmailType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "email"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEmailType {
        #[serde(rename = "email")]
        Email,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEmailType {
        fn from(value: &LinkedAccountEmailType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEmailType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEmailType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEmailType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEmailType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEmailType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereum`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Ethereum",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_type",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "type",
    ///    "verified_at",
    ///    "wallet_client"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_id": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "connector_type": {
    ///      "type": "string"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "wallet"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    },
    ///    "wallet_client": {
    ///      "type": "string",
    ///      "enum": [
    ///        "unknown"
    ///      ]
    ///    },
    ///    "wallet_client_type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEthereum {
        pub address: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_id: ::std::option::Option<::std::string::String>,
        pub chain_type: LinkedAccountEthereumChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connector_type: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEthereumType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountEthereumWalletClient,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub wallet_client_type: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LinkedAccountEthereum> for LinkedAccountEthereum {
        fn from(value: &LinkedAccountEthereum) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountEthereumChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumChainType {
        fn from(value: &LinkedAccountEthereumChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumEmbeddedWallet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Ethereum Embedded Wallet",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_id",
    ///    "chain_type",
    ///    "connector_type",
    ///    "delegated",
    ///    "first_verified_at",
    ///    "id",
    ///    "imported",
    ///    "latest_verified_at",
    ///    "recovery_method",
    ///    "type",
    ///    "verified_at",
    ///    "wallet_client",
    ///    "wallet_client_type",
    ///    "wallet_index"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_id": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum"
    ///      ]
    ///    },
    ///    "connector_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "embedded"
    ///      ]
    ///    },
    ///    "delegated": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "imported": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "recovery_method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy",
    ///        "user-passcode",
    ///        "google-drive",
    ///        "icloud",
    ///        "recovery-encryption-key",
    ///        "privy-v2"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "wallet"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    },
    ///    "wallet_client": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_client_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_index": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountEthereumEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountEthereumEmbeddedWalletChainType,
        pub connector_type: LinkedAccountEthereumEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub recovery_method: LinkedAccountEthereumEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountEthereumEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountEthereumEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountEthereumEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }

    impl ::std::convert::From<&LinkedAccountEthereumEmbeddedWallet>
        for LinkedAccountEthereumEmbeddedWallet
    {
        fn from(value: &LinkedAccountEthereumEmbeddedWallet) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountEthereumEmbeddedWalletChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletChainType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumEmbeddedWalletConnectorType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "embedded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumEmbeddedWalletRecoveryMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy",
    ///    "user-passcode",
    ///    "google-drive",
    ///    "icloud",
    ///    "recovery-encryption-key",
    ///    "privy-v2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumEmbeddedWalletType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumEmbeddedWalletWalletClient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumEmbeddedWalletWalletClientType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountEthereumEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountEthereumEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumType {
        #[serde(rename = "wallet")]
        Wallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumType {
        fn from(value: &LinkedAccountEthereumType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountEthereumWalletClient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "unknown"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountEthereumWalletClient {
        #[serde(rename = "unknown")]
        Unknown,
    }

    impl ::std::convert::From<&Self> for LinkedAccountEthereumWalletClient {
        fn from(value: &LinkedAccountEthereumWalletClient) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountEthereumWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => f.write_str("unknown"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountEthereumWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "unknown" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountEthereumWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountEthereumWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountEthereumWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountFarcaster`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Farcaster",
    ///  "type": "object",
    ///  "required": [
    ///    "fid",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "owner_address",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "bio": {
    ///      "type": "string"
    ///    },
    ///    "display_name": {
    ///      "type": "string"
    ///    },
    ///    "fid": {
    ///      "type": "number"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "homepage_url": {
    ///      "type": "string"
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "owner_address": {
    ///      "type": "string"
    ///    },
    ///    "profile_picture": {
    ///      "type": "string"
    ///    },
    ///    "profile_picture_url": {
    ///      "type": "string"
    ///    },
    ///    "signer_public_key": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "farcaster"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string"
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountFarcaster {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bio: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<::std::string::String>,
        pub fid: f64,
        pub first_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub homepage_url: ::std::option::Option<::std::string::String>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub owner_address: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signer_public_key: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountFarcasterType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountFarcaster> for LinkedAccountFarcaster {
        fn from(value: &LinkedAccountFarcaster) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountFarcasterInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Farcaster",
    ///  "type": "object",
    ///  "required": [
    ///    "fid",
    ///    "owner_address",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "bio": {
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "display_name": {
    ///      "type": "string",
    ///      "maxLength": 32
    ///    },
    ///    "fid": {
    ///      "type": "integer"
    ///    },
    ///    "homepage_url": {
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "owner_address": {
    ///      "type": "string"
    ///    },
    ///    "profile_picture_url": {
    ///      "type": "string",
    ///      "maxLength": 256
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "farcaster"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string",
    ///      "maxLength": 256
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountFarcasterInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bio: ::std::option::Option<LinkedAccountFarcasterInputBio>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<LinkedAccountFarcasterInputDisplayName>,
        pub fid: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub homepage_url: ::std::option::Option<LinkedAccountFarcasterInputHomepageUrl>,
        pub owner_address: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url:
            ::std::option::Option<LinkedAccountFarcasterInputProfilePictureUrl>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountFarcasterInputType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<LinkedAccountFarcasterInputUsername>,
    }

    impl ::std::convert::From<&LinkedAccountFarcasterInput> for LinkedAccountFarcasterInput {
        fn from(value: &LinkedAccountFarcasterInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountFarcasterInputBio`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputBio(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputBio {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountFarcasterInputBio> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputBio) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountFarcasterInputBio> for LinkedAccountFarcasterInputBio {
        fn from(value: &LinkedAccountFarcasterInputBio) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountFarcasterInputBio {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputBio {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputBio {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputBio {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputBio {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountFarcasterInputDisplayName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 32
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputDisplayName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountFarcasterInputDisplayName> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputDisplayName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountFarcasterInputDisplayName>
        for LinkedAccountFarcasterInputDisplayName
    {
        fn from(value: &LinkedAccountFarcasterInputDisplayName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountFarcasterInputDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 32usize {
                return Err("longer than 32 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountFarcasterInputHomepageUrl`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputHomepageUrl(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputHomepageUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountFarcasterInputHomepageUrl> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputHomepageUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountFarcasterInputHomepageUrl>
        for LinkedAccountFarcasterInputHomepageUrl
    {
        fn from(value: &LinkedAccountFarcasterInputHomepageUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountFarcasterInputHomepageUrl {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputHomepageUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputHomepageUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputHomepageUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputHomepageUrl {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountFarcasterInputProfilePictureUrl`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputProfilePictureUrl(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputProfilePictureUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountFarcasterInputProfilePictureUrl> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputProfilePictureUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountFarcasterInputProfilePictureUrl>
        for LinkedAccountFarcasterInputProfilePictureUrl
    {
        fn from(value: &LinkedAccountFarcasterInputProfilePictureUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountFarcasterInputProfilePictureUrl {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputProfilePictureUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountFarcasterInputProfilePictureUrl
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountFarcasterInputProfilePictureUrl
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputProfilePictureUrl {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountFarcasterInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "farcaster"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountFarcasterInputType {
        #[serde(rename = "farcaster")]
        Farcaster,
    }

    impl ::std::convert::From<&Self> for LinkedAccountFarcasterInputType {
        fn from(value: &LinkedAccountFarcasterInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountFarcasterInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Farcaster => f.write_str("farcaster"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountFarcasterInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "farcaster" => Ok(Self::Farcaster),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountFarcasterInputUsername`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountFarcasterInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountFarcasterInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountFarcasterInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountFarcasterInputUsername) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountFarcasterInputUsername>
        for LinkedAccountFarcasterInputUsername
    {
        fn from(value: &LinkedAccountFarcasterInputUsername) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountFarcasterInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountFarcasterInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountFarcasterType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "farcaster"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountFarcasterType {
        #[serde(rename = "farcaster")]
        Farcaster,
    }

    impl ::std::convert::From<&Self> for LinkedAccountFarcasterType {
        fn from(value: &LinkedAccountFarcasterType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountFarcasterType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Farcaster => f.write_str("farcaster"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountFarcasterType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "farcaster" => Ok(Self::Farcaster),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountFarcasterType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountFarcasterType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountFarcasterType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountGithubInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Github",
    ///  "type": "object",
    ///  "required": [
    ///    "subject",
    ///    "type",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "github_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string",
    ///      "maxLength": 39,
    ///      "pattern": "^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountGithubInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountGithubInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGithubInputType,
        pub username: LinkedAccountGithubInputUsername,
    }

    impl ::std::convert::From<&LinkedAccountGithubInput> for LinkedAccountGithubInput {
        fn from(value: &LinkedAccountGithubInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountGithubInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountGithubInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountGithubInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountGithubInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountGithubInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountGithubInputSubject> for LinkedAccountGithubInputSubject {
        fn from(value: &LinkedAccountGithubInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountGithubInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountGithubInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountGithubInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "github_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGithubInputType {
        #[serde(rename = "github_oauth")]
        GithubOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountGithubInputType {
        fn from(value: &LinkedAccountGithubInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountGithubInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GithubOauth => f.write_str("github_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountGithubInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "github_oauth" => Ok(Self::GithubOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountGithubInputUsername`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 39,
    ///  "pattern": "^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountGithubInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountGithubInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountGithubInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountGithubInputUsername) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountGithubInputUsername> for LinkedAccountGithubInputUsername {
        fn from(value: &LinkedAccountGithubInputUsername) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountGithubInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 39usize {
                return Err("longer than 39 characters".into());
            }
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountGithubInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountGithubOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Github",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "name",
    ///    "subject",
    ///    "type",
    ///    "username",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "github_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountGithubOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGithubOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountGithubOauth> for LinkedAccountGithubOauth {
        fn from(value: &LinkedAccountGithubOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountGithubOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "github_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGithubOauthType {
        #[serde(rename = "github_oauth")]
        GithubOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountGithubOauthType {
        fn from(value: &LinkedAccountGithubOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountGithubOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GithubOauth => f.write_str("github_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountGithubOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "github_oauth" => Ok(Self::GithubOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountGithubOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGithubOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGithubOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountGoogleInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Google",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "name",
    ///    "subject",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "google_oauth"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountGoogleInput {
        pub email: ::std::string::String,
        pub name: ::std::string::String,
        pub subject: LinkedAccountGoogleInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGoogleInputType,
    }

    impl ::std::convert::From<&LinkedAccountGoogleInput> for LinkedAccountGoogleInput {
        fn from(value: &LinkedAccountGoogleInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountGoogleInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountGoogleInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountGoogleInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountGoogleInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountGoogleInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountGoogleInputSubject> for LinkedAccountGoogleInputSubject {
        fn from(value: &LinkedAccountGoogleInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountGoogleInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountGoogleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGoogleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGoogleInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountGoogleInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountGoogleInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "google_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGoogleInputType {
        #[serde(rename = "google_oauth")]
        GoogleOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountGoogleInputType {
        fn from(value: &LinkedAccountGoogleInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountGoogleInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoogleOauth => f.write_str("google_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountGoogleInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "google_oauth" => Ok(Self::GoogleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountGoogleInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGoogleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGoogleInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountGoogleOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Google",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "name",
    ///    "subject",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "google_oauth"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountGoogleOauth {
        pub email: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountGoogleOauthType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountGoogleOauth> for LinkedAccountGoogleOauth {
        fn from(value: &LinkedAccountGoogleOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountGoogleOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "google_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountGoogleOauthType {
        #[serde(rename = "google_oauth")]
        GoogleOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountGoogleOauthType {
        fn from(value: &LinkedAccountGoogleOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountGoogleOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::GoogleOauth => f.write_str("google_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountGoogleOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "google_oauth" => Ok(Self::GoogleOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountGoogleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountGoogleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountGoogleOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The input for adding a linked account to a user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "LinkedAccountInput",
    ///  "description": "The input for adding a linked account to a user.",
    ///  "examples": [
    ///    {
    ///      "address": "tom.bombadill@privy.io",
    ///      "type": "email"
    ///    }
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountWalletInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountEmailInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountPhoneInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountGoogleInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountTwitterInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountDiscordInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountGithubInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountSpotifyInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountInstagramInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountTiktokInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountLineInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountAppleInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountLinkedInInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountFarcasterInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountTelegramInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountCustomJWTInput"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum LinkedAccountInput {
        WalletInput(LinkedAccountWalletInput),
        EmailInput(LinkedAccountEmailInput),
        PhoneInput(LinkedAccountPhoneInput),
        GoogleInput(LinkedAccountGoogleInput),
        TwitterInput(LinkedAccountTwitterInput),
        DiscordInput(LinkedAccountDiscordInput),
        GithubInput(LinkedAccountGithubInput),
        SpotifyInput(LinkedAccountSpotifyInput),
        InstagramInput(LinkedAccountInstagramInput),
        TiktokInput(LinkedAccountTiktokInput),
        LineInput(LinkedAccountLineInput),
        AppleInput(LinkedAccountAppleInput),
        LinkedInInput(LinkedAccountLinkedInInput),
        FarcasterInput(LinkedAccountFarcasterInput),
        TelegramInput(LinkedAccountTelegramInput),
        CustomJwtInput(LinkedAccountCustomJwtInput),
    }

    impl ::std::convert::From<&Self> for LinkedAccountInput {
        fn from(value: &LinkedAccountInput) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<LinkedAccountWalletInput> for LinkedAccountInput {
        fn from(value: LinkedAccountWalletInput) -> Self {
            Self::WalletInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountEmailInput> for LinkedAccountInput {
        fn from(value: LinkedAccountEmailInput) -> Self {
            Self::EmailInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountPhoneInput> for LinkedAccountInput {
        fn from(value: LinkedAccountPhoneInput) -> Self {
            Self::PhoneInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountGoogleInput> for LinkedAccountInput {
        fn from(value: LinkedAccountGoogleInput) -> Self {
            Self::GoogleInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountTwitterInput> for LinkedAccountInput {
        fn from(value: LinkedAccountTwitterInput) -> Self {
            Self::TwitterInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountDiscordInput> for LinkedAccountInput {
        fn from(value: LinkedAccountDiscordInput) -> Self {
            Self::DiscordInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountGithubInput> for LinkedAccountInput {
        fn from(value: LinkedAccountGithubInput) -> Self {
            Self::GithubInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountSpotifyInput> for LinkedAccountInput {
        fn from(value: LinkedAccountSpotifyInput) -> Self {
            Self::SpotifyInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountInstagramInput> for LinkedAccountInput {
        fn from(value: LinkedAccountInstagramInput) -> Self {
            Self::InstagramInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountTiktokInput> for LinkedAccountInput {
        fn from(value: LinkedAccountTiktokInput) -> Self {
            Self::TiktokInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountLineInput> for LinkedAccountInput {
        fn from(value: LinkedAccountLineInput) -> Self {
            Self::LineInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountAppleInput> for LinkedAccountInput {
        fn from(value: LinkedAccountAppleInput) -> Self {
            Self::AppleInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountLinkedInInput> for LinkedAccountInput {
        fn from(value: LinkedAccountLinkedInInput) -> Self {
            Self::LinkedInInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountFarcasterInput> for LinkedAccountInput {
        fn from(value: LinkedAccountFarcasterInput) -> Self {
            Self::FarcasterInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountTelegramInput> for LinkedAccountInput {
        fn from(value: LinkedAccountTelegramInput) -> Self {
            Self::TelegramInput(value)
        }
    }

    impl ::std::convert::From<LinkedAccountCustomJwtInput> for LinkedAccountInput {
        fn from(value: LinkedAccountCustomJwtInput) -> Self {
            Self::CustomJwtInput(value)
        }
    }

    ///`LinkedAccountInstagramInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Instagram",
    ///  "type": "object",
    ///  "required": [
    ///    "subject",
    ///    "type",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "instagram_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string",
    ///      "pattern": "^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountInstagramInput {
        pub subject: LinkedAccountInstagramInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountInstagramInputType,
        pub username: LinkedAccountInstagramInputUsername,
    }

    impl ::std::convert::From<&LinkedAccountInstagramInput> for LinkedAccountInstagramInput {
        fn from(value: &LinkedAccountInstagramInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountInstagramInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountInstagramInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountInstagramInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountInstagramInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountInstagramInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountInstagramInputSubject>
        for LinkedAccountInstagramInputSubject
    {
        fn from(value: &LinkedAccountInstagramInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountInstagramInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountInstagramInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountInstagramInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "instagram_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountInstagramInputType {
        #[serde(rename = "instagram_oauth")]
        InstagramOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountInstagramInputType {
        fn from(value: &LinkedAccountInstagramInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountInstagramInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstagramOauth => f.write_str("instagram_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountInstagramInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instagram_oauth" => Ok(Self::InstagramOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountInstagramInputUsername`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountInstagramInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountInstagramInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountInstagramInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountInstagramInputUsername) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountInstagramInputUsername>
        for LinkedAccountInstagramInputUsername
    {
        fn from(value: &LinkedAccountInstagramInputUsername) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountInstagramInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$")
                        .unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountInstagramInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountInstagramOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Instagram",
    ///  "type": "object",
    ///  "required": [
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "subject",
    ///    "type",
    ///    "username",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "instagram_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountInstagramOauth {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountInstagramOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountInstagramOauth> for LinkedAccountInstagramOauth {
        fn from(value: &LinkedAccountInstagramOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountInstagramOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "instagram_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountInstagramOauthType {
        #[serde(rename = "instagram_oauth")]
        InstagramOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountInstagramOauthType {
        fn from(value: &LinkedAccountInstagramOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountInstagramOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstagramOauth => f.write_str("instagram_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountInstagramOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instagram_oauth" => Ok(Self::InstagramOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountInstagramOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountInstagramOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountInstagramOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountLineInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "LINE",
    ///  "type": "object",
    ///  "required": [
    ///    "subject",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "name": {
    ///      "type": "string",
    ///      "maxLength": 30,
    ///      "minLength": 1
    ///    },
    ///    "profile_picture_url": {
    ///      "type": "string",
    ///      "format": "uri"
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "line_oauth"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountLineInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<LinkedAccountLineInputName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountLineInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLineInputType,
    }

    impl ::std::convert::From<&LinkedAccountLineInput> for LinkedAccountLineInput {
        fn from(value: &LinkedAccountLineInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountLineInputName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 30,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountLineInputName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountLineInputName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountLineInputName> for ::std::string::String {
        fn from(value: LinkedAccountLineInputName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountLineInputName> for LinkedAccountLineInputName {
        fn from(value: &LinkedAccountLineInputName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountLineInputName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 30usize {
                return Err("longer than 30 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountLineInputName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountLineInputName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountLineInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountLineInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountLineInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountLineInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountLineInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountLineInputSubject> for LinkedAccountLineInputSubject {
        fn from(value: &LinkedAccountLineInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountLineInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountLineInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountLineInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountLineInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "line_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLineInputType {
        #[serde(rename = "line_oauth")]
        LineOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountLineInputType {
        fn from(value: &LinkedAccountLineInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountLineInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LineOauth => f.write_str("line_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountLineInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "line_oauth" => Ok(Self::LineOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountLineInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountLineOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Line",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "name",
    ///    "profile_picture_url",
    ///    "subject",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "profile_picture_url": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "line_oauth"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountLineOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLineOauthType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountLineOauth> for LinkedAccountLineOauth {
        fn from(value: &LinkedAccountLineOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountLineOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "line_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLineOauthType {
        #[serde(rename = "line_oauth")]
        LineOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountLineOauthType {
        fn from(value: &LinkedAccountLineOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountLineOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LineOauth => f.write_str("line_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountLineOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "line_oauth" => Ok(Self::LineOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountLineOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLineOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLineOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountLinkedInInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "LinkedIn",
    ///  "type": "object",
    ///  "required": [
    ///    "subject",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "linkedin_oauth"
    ///      ]
    ///    },
    ///    "vanityName": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountLinkedInInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountLinkedInInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLinkedInInputType,
        #[serde(
            rename = "vanityName",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        pub vanity_name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LinkedAccountLinkedInInput> for LinkedAccountLinkedInInput {
        fn from(value: &LinkedAccountLinkedInInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountLinkedInInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountLinkedInInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountLinkedInInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountLinkedInInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountLinkedInInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountLinkedInInputSubject>
        for LinkedAccountLinkedInInputSubject
    {
        fn from(value: &LinkedAccountLinkedInInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountLinkedInInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountLinkedInInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLinkedInInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLinkedInInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountLinkedInInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountLinkedInInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "linkedin_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLinkedInInputType {
        #[serde(rename = "linkedin_oauth")]
        LinkedinOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountLinkedInInputType {
        fn from(value: &LinkedAccountLinkedInInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountLinkedInInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LinkedinOauth => f.write_str("linkedin_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountLinkedInInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "linkedin_oauth" => Ok(Self::LinkedinOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountLinkedInInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLinkedInInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLinkedInInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountLinkedInOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "LinkedIn",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "subject",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "linkedin_oauth"
    ///      ]
    ///    },
    ///    "vanity_name": {
    ///      "type": "string"
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountLinkedInOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountLinkedInOauthType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vanity_name: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountLinkedInOauth> for LinkedAccountLinkedInOauth {
        fn from(value: &LinkedAccountLinkedInOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountLinkedInOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "linkedin_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountLinkedInOauthType {
        #[serde(rename = "linkedin_oauth")]
        LinkedinOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountLinkedInOauthType {
        fn from(value: &LinkedAccountLinkedInOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountLinkedInOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::LinkedinOauth => f.write_str("linkedin_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountLinkedInOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "linkedin_oauth" => Ok(Self::LinkedinOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountLinkedInOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountLinkedInOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountLinkedInOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountPasskey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Passkey",
    ///  "type": "object",
    ///  "required": [
    ///    "credential_id",
    ///    "enrolled_in_mfa",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "authenticator_name": {
    ///      "type": "string"
    ///    },
    ///    "created_with_browser": {
    ///      "type": "string"
    ///    },
    ///    "created_with_device": {
    ///      "type": "string"
    ///    },
    ///    "created_with_os": {
    ///      "type": "string"
    ///    },
    ///    "credential_id": {
    ///      "type": "string"
    ///    },
    ///    "enrolled_in_mfa": {
    ///      "type": "boolean"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passkey"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountPasskey {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authenticator_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_with_browser: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_with_device: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub created_with_os: ::std::option::Option<::std::string::String>,
        pub credential_id: ::std::string::String,
        pub enrolled_in_mfa: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_key: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountPasskeyType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountPasskey> for LinkedAccountPasskey {
        fn from(value: &LinkedAccountPasskey) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountPasskeyType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passkey"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountPasskeyType {
        #[serde(rename = "passkey")]
        Passkey,
    }

    impl ::std::convert::From<&Self> for LinkedAccountPasskeyType {
        fn from(value: &LinkedAccountPasskeyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountPasskeyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passkey => f.write_str("passkey"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountPasskeyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passkey" => Ok(Self::Passkey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountPasskeyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountPasskeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountPasskeyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountPhone`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Phone",
    ///  "type": "object",
    ///  "required": [
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "phoneNumber",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "number": {
    ///      "type": "string"
    ///    },
    ///    "phoneNumber": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "phone"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountPhone {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub number: ::std::option::Option<::std::string::String>,
        #[serde(rename = "phoneNumber")]
        pub phone_number: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountPhoneType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountPhone> for LinkedAccountPhone {
        fn from(value: &LinkedAccountPhone) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountPhoneInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Phone",
    ///  "type": "object",
    ///  "required": [
    ///    "number",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "number": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "phone"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountPhoneInput {
        pub number: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountPhoneInputType,
    }

    impl ::std::convert::From<&LinkedAccountPhoneInput> for LinkedAccountPhoneInput {
        fn from(value: &LinkedAccountPhoneInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountPhoneInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "phone"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountPhoneInputType {
        #[serde(rename = "phone")]
        Phone,
    }

    impl ::std::convert::From<&Self> for LinkedAccountPhoneInputType {
        fn from(value: &LinkedAccountPhoneInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountPhoneInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Phone => f.write_str("phone"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountPhoneInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "phone" => Ok(Self::Phone),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountPhoneInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountPhoneInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountPhoneInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountPhoneType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "phone"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountPhoneType {
        #[serde(rename = "phone")]
        Phone,
    }

    impl ::std::convert::From<&Self> for LinkedAccountPhoneType {
        fn from(value: &LinkedAccountPhoneType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountPhoneType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Phone => f.write_str("phone"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountPhoneType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "phone" => Ok(Self::Phone),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountPhoneType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountPhoneType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountPhoneType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSmartWallet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Smart Wallet",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "smart_wallet_type",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "smart_wallet_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "safe",
    ///        "kernel",
    ///        "biconomy",
    ///        "light_account",
    ///        "coinbase_smart_wallet",
    ///        "thirdweb"
    ///      ]
    ///    },
    ///    "smart_wallet_version": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "smart_wallet"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSmartWallet {
        pub address: ::std::string::String,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub smart_wallet_type: LinkedAccountSmartWalletSmartWalletType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub smart_wallet_version: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSmartWalletType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountSmartWallet> for LinkedAccountSmartWallet {
        fn from(value: &LinkedAccountSmartWallet) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountSmartWalletSmartWalletType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "safe",
    ///    "kernel",
    ///    "biconomy",
    ///    "light_account",
    ///    "coinbase_smart_wallet",
    ///    "thirdweb"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSmartWalletSmartWalletType {
        #[serde(rename = "safe")]
        Safe,
        #[serde(rename = "kernel")]
        Kernel,
        #[serde(rename = "biconomy")]
        Biconomy,
        #[serde(rename = "light_account")]
        LightAccount,
        #[serde(rename = "coinbase_smart_wallet")]
        CoinbaseSmartWallet,
        #[serde(rename = "thirdweb")]
        Thirdweb,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSmartWalletSmartWalletType {
        fn from(value: &LinkedAccountSmartWalletSmartWalletType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSmartWalletSmartWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Safe => f.write_str("safe"),
                Self::Kernel => f.write_str("kernel"),
                Self::Biconomy => f.write_str("biconomy"),
                Self::LightAccount => f.write_str("light_account"),
                Self::CoinbaseSmartWallet => f.write_str("coinbase_smart_wallet"),
                Self::Thirdweb => f.write_str("thirdweb"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSmartWalletSmartWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "safe" => Ok(Self::Safe),
                "kernel" => Ok(Self::Kernel),
                "biconomy" => Ok(Self::Biconomy),
                "light_account" => Ok(Self::LightAccount),
                "coinbase_smart_wallet" => Ok(Self::CoinbaseSmartWallet),
                "thirdweb" => Ok(Self::Thirdweb),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSmartWalletSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSmartWalletSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSmartWalletSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSmartWalletType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "smart_wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSmartWalletType {
        #[serde(rename = "smart_wallet")]
        SmartWallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSmartWalletType {
        fn from(value: &LinkedAccountSmartWalletType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSmartWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SmartWallet => f.write_str("smart_wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSmartWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "smart_wallet" => Ok(Self::SmartWallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSmartWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolana`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Solana",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_type",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "type",
    ///    "verified_at",
    ///    "wallet_client"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana"
    ///      ]
    ///    },
    ///    "connector_type": {
    ///      "type": "string"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "wallet"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    },
    ///    "wallet_client": {
    ///      "type": "string",
    ///      "enum": [
    ///        "unknown"
    ///      ]
    ///    },
    ///    "wallet_client_type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSolana {
        pub address: ::std::string::String,
        pub chain_type: LinkedAccountSolanaChainType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub connector_type: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSolanaType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountSolanaWalletClient,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub wallet_client_type: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LinkedAccountSolana> for LinkedAccountSolana {
        fn from(value: &LinkedAccountSolana) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountSolanaChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaChainType {
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaChainType {
        fn from(value: &LinkedAccountSolanaChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaEmbeddedWallet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Solana Embedded Wallet",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_id",
    ///    "chain_type",
    ///    "connector_type",
    ///    "delegated",
    ///    "first_verified_at",
    ///    "id",
    ///    "imported",
    ///    "latest_verified_at",
    ///    "recovery_method",
    ///    "type",
    ///    "verified_at",
    ///    "wallet_client",
    ///    "wallet_client_type",
    ///    "wallet_index"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_id": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana"
    ///      ]
    ///    },
    ///    "connector_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "embedded"
    ///      ]
    ///    },
    ///    "delegated": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "imported": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "type": "string"
    ///    },
    ///    "recovery_method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy",
    ///        "user-passcode",
    ///        "google-drive",
    ///        "icloud",
    ///        "recovery-encryption-key",
    ///        "privy-v2"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "wallet"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    },
    ///    "wallet_client": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_client_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "privy"
    ///      ]
    ///    },
    ///    "wallet_index": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSolanaEmbeddedWallet {
        pub address: ::std::string::String,
        pub chain_id: ::std::string::String,
        pub chain_type: LinkedAccountSolanaEmbeddedWalletChainType,
        pub connector_type: LinkedAccountSolanaEmbeddedWalletConnectorType,
        pub delegated: bool,
        pub first_verified_at: ::std::option::Option<f64>,
        pub id: ::std::option::Option<::std::string::String>,
        pub imported: bool,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_key: ::std::option::Option<::std::string::String>,
        pub recovery_method: LinkedAccountSolanaEmbeddedWalletRecoveryMethod,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSolanaEmbeddedWalletType,
        pub verified_at: f64,
        pub wallet_client: LinkedAccountSolanaEmbeddedWalletWalletClient,
        pub wallet_client_type: LinkedAccountSolanaEmbeddedWalletWalletClientType,
        pub wallet_index: f64,
    }

    impl ::std::convert::From<&LinkedAccountSolanaEmbeddedWallet>
        for LinkedAccountSolanaEmbeddedWallet
    {
        fn from(value: &LinkedAccountSolanaEmbeddedWallet) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountSolanaEmbeddedWalletChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletChainType {
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletChainType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaEmbeddedWalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaEmbeddedWalletConnectorType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "embedded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletConnectorType {
        #[serde(rename = "embedded")]
        Embedded,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletConnectorType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletConnectorType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletConnectorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Embedded => f.write_str("embedded"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletConnectorType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "embedded" => Ok(Self::Embedded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletConnectorType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletConnectorType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaEmbeddedWalletRecoveryMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy",
    ///    "user-passcode",
    ///    "google-drive",
    ///    "icloud",
    ///    "recovery-encryption-key",
    ///    "privy-v2"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        #[serde(rename = "privy")]
        Privy,
        #[serde(rename = "user-passcode")]
        UserPasscode,
        #[serde(rename = "google-drive")]
        GoogleDrive,
        #[serde(rename = "icloud")]
        Icloud,
        #[serde(rename = "recovery-encryption-key")]
        RecoveryEncryptionKey,
        #[serde(rename = "privy-v2")]
        PrivyV2,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletRecoveryMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
                Self::UserPasscode => f.write_str("user-passcode"),
                Self::GoogleDrive => f.write_str("google-drive"),
                Self::Icloud => f.write_str("icloud"),
                Self::RecoveryEncryptionKey => f.write_str("recovery-encryption-key"),
                Self::PrivyV2 => f.write_str("privy-v2"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                "user-passcode" => Ok(Self::UserPasscode),
                "google-drive" => Ok(Self::GoogleDrive),
                "icloud" => Ok(Self::Icloud),
                "recovery-encryption-key" => Ok(Self::RecoveryEncryptionKey),
                "privy-v2" => Ok(Self::PrivyV2),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletRecoveryMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletRecoveryMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaEmbeddedWalletType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletType {
        #[serde(rename = "wallet")]
        Wallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaEmbeddedWalletType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaEmbeddedWalletWalletClient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletWalletClient {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletWalletClient {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletWalletClient) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClient
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaEmbeddedWalletWalletClientType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "privy"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaEmbeddedWalletWalletClientType {
        #[serde(rename = "privy")]
        Privy,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        fn from(value: &LinkedAccountSolanaEmbeddedWalletWalletClientType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Privy => f.write_str("privy"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "privy" => Ok(Self::Privy),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaEmbeddedWalletWalletClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for LinkedAccountSolanaEmbeddedWalletWalletClientType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaType {
        #[serde(rename = "wallet")]
        Wallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaType {
        fn from(value: &LinkedAccountSolanaType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSolanaWalletClient`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "unknown"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSolanaWalletClient {
        #[serde(rename = "unknown")]
        Unknown,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSolanaWalletClient {
        fn from(value: &LinkedAccountSolanaWalletClient) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSolanaWalletClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Unknown => f.write_str("unknown"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSolanaWalletClient {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "unknown" => Ok(Self::Unknown),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSolanaWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSolanaWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSolanaWalletClient {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSpotifyInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Spotify",
    ///  "type": "object",
    ///  "required": [
    ///    "subject",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "spotify_oauth"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSpotifyInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub email: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSpotifyInputType,
    }

    impl ::std::convert::From<&LinkedAccountSpotifyInput> for LinkedAccountSpotifyInput {
        fn from(value: &LinkedAccountSpotifyInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountSpotifyInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "spotify_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSpotifyInputType {
        #[serde(rename = "spotify_oauth")]
        SpotifyOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSpotifyInputType {
        fn from(value: &LinkedAccountSpotifyInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSpotifyInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SpotifyOauth => f.write_str("spotify_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSpotifyInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "spotify_oauth" => Ok(Self::SpotifyOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSpotifyInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSpotifyInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSpotifyInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountSpotifyOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Spotify",
    ///  "type": "object",
    ///  "required": [
    ///    "email",
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "name",
    ///    "subject",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "spotify_oauth"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountSpotifyOauth {
        pub email: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountSpotifyOauthType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountSpotifyOauth> for LinkedAccountSpotifyOauth {
        fn from(value: &LinkedAccountSpotifyOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountSpotifyOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "spotify_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountSpotifyOauthType {
        #[serde(rename = "spotify_oauth")]
        SpotifyOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountSpotifyOauthType {
        fn from(value: &LinkedAccountSpotifyOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountSpotifyOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SpotifyOauth => f.write_str("spotify_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountSpotifyOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "spotify_oauth" => Ok(Self::SpotifyOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountSpotifyOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountSpotifyOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountSpotifyOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountTelegram`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Telegram",
    ///  "type": "object",
    ///  "required": [
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "telegram_user_id",
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "first_name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "last_name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "photo_url": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "telegram_user_id": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "telegram"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTelegram {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_name: ::std::option::Option<::std::string::String>,
        pub first_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_name: ::std::option::Option<::std::string::String>,
        pub latest_verified_at: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub photo_url: ::std::option::Option<::std::string::String>,
        pub telegram_user_id: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTelegramType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountTelegram> for LinkedAccountTelegram {
        fn from(value: &LinkedAccountTelegram) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountTelegramInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Telegram",
    ///  "type": "object",
    ///  "required": [
    ///    "telegram_user_id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "first_name": {
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "last_name": {
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "photo_url": {
    ///      "type": "string",
    ///      "maxLength": 255
    ///    },
    ///    "telegram_user_id": {
    ///      "type": "string",
    ///      "maxLength": 255,
    ///      "minLength": 1
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "telegram"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string",
    ///      "maxLength": 255
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTelegramInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub first_name: ::std::option::Option<LinkedAccountTelegramInputFirstName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub last_name: ::std::option::Option<LinkedAccountTelegramInputLastName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub photo_url: ::std::option::Option<LinkedAccountTelegramInputPhotoUrl>,
        pub telegram_user_id: LinkedAccountTelegramInputTelegramUserId,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTelegramInputType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub username: ::std::option::Option<LinkedAccountTelegramInputUsername>,
    }

    impl ::std::convert::From<&LinkedAccountTelegramInput> for LinkedAccountTelegramInput {
        fn from(value: &LinkedAccountTelegramInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountTelegramInputFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputFirstName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTelegramInputFirstName> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTelegramInputFirstName>
        for LinkedAccountTelegramInputFirstName
    {
        fn from(value: &LinkedAccountTelegramInputFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTelegramInputFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTelegramInputLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputLastName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTelegramInputLastName> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTelegramInputLastName>
        for LinkedAccountTelegramInputLastName
    {
        fn from(value: &LinkedAccountTelegramInputLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTelegramInputLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTelegramInputPhotoUrl`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputPhotoUrl(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputPhotoUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTelegramInputPhotoUrl> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputPhotoUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTelegramInputPhotoUrl>
        for LinkedAccountTelegramInputPhotoUrl
    {
        fn from(value: &LinkedAccountTelegramInputPhotoUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTelegramInputPhotoUrl {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputPhotoUrl {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputPhotoUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputPhotoUrl {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputPhotoUrl {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTelegramInputTelegramUserId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 255,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputTelegramUserId(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputTelegramUserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTelegramInputTelegramUserId> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputTelegramUserId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTelegramInputTelegramUserId>
        for LinkedAccountTelegramInputTelegramUserId
    {
        fn from(value: &LinkedAccountTelegramInputTelegramUserId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTelegramInputTelegramUserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputTelegramUserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputTelegramUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputTelegramUserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputTelegramUserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTelegramInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "telegram"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTelegramInputType {
        #[serde(rename = "telegram")]
        Telegram,
    }

    impl ::std::convert::From<&Self> for LinkedAccountTelegramInputType {
        fn from(value: &LinkedAccountTelegramInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountTelegramInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Telegram => f.write_str("telegram"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountTelegramInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "telegram" => Ok(Self::Telegram),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountTelegramInputUsername`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 255
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTelegramInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTelegramInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTelegramInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountTelegramInputUsername) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTelegramInputUsername>
        for LinkedAccountTelegramInputUsername
    {
        fn from(value: &LinkedAccountTelegramInputUsername) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTelegramInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 255usize {
                return Err("longer than 255 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTelegramInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTelegramType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "telegram"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTelegramType {
        #[serde(rename = "telegram")]
        Telegram,
    }

    impl ::std::convert::From<&Self> for LinkedAccountTelegramType {
        fn from(value: &LinkedAccountTelegramType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountTelegramType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Telegram => f.write_str("telegram"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountTelegramType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "telegram" => Ok(Self::Telegram),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTelegramType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTelegramType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTelegramType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountTiktokInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Tiktok",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "subject",
    ///    "type",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "maxLength": 30,
    ///      "minLength": 1
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "tiktok_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string",
    ///      "pattern": "^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTiktokInput {
        pub name: ::std::option::Option<LinkedAccountTiktokInputName>,
        pub subject: LinkedAccountTiktokInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTiktokInputType,
        pub username: LinkedAccountTiktokInputUsername,
    }

    impl ::std::convert::From<&LinkedAccountTiktokInput> for LinkedAccountTiktokInput {
        fn from(value: &LinkedAccountTiktokInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountTiktokInputName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 30,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTiktokInputName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTiktokInputName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTiktokInputName> for ::std::string::String {
        fn from(value: LinkedAccountTiktokInputName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTiktokInputName> for LinkedAccountTiktokInputName {
        fn from(value: &LinkedAccountTiktokInputName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTiktokInputName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 30usize {
                return Err("longer than 30 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTiktokInputName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTiktokInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTiktokInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTiktokInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTiktokInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountTiktokInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTiktokInputSubject> for LinkedAccountTiktokInputSubject {
        fn from(value: &LinkedAccountTiktokInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTiktokInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTiktokInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTiktokInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "tiktok_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTiktokInputType {
        #[serde(rename = "tiktok_oauth")]
        TiktokOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountTiktokInputType {
        fn from(value: &LinkedAccountTiktokInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountTiktokInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TiktokOauth => f.write_str("tiktok_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountTiktokInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "tiktok_oauth" => Ok(Self::TiktokOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountTiktokInputUsername`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTiktokInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTiktokInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTiktokInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountTiktokInputUsername) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTiktokInputUsername> for LinkedAccountTiktokInputUsername {
        fn from(value: &LinkedAccountTiktokInputUsername) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTiktokInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTiktokInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTiktokOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Tiktok",
    ///  "type": "object",
    ///  "required": [
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "name",
    ///    "subject",
    ///    "type",
    ///    "username",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "tiktok_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTiktokOauth {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTiktokOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountTiktokOauth> for LinkedAccountTiktokOauth {
        fn from(value: &LinkedAccountTiktokOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountTiktokOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "tiktok_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTiktokOauthType {
        #[serde(rename = "tiktok_oauth")]
        TiktokOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountTiktokOauthType {
        fn from(value: &LinkedAccountTiktokOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountTiktokOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TiktokOauth => f.write_str("tiktok_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountTiktokOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "tiktok_oauth" => Ok(Self::TiktokOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTiktokOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTiktokOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTiktokOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountTwitterInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Twitter",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "subject",
    ///    "type",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "type": "string",
    ///      "maxLength": 50,
    ///      "minLength": 1
    ///    },
    ///    "profile_picture_url": {
    ///      "type": "string",
    ///      "format": "uri"
    ///    },
    ///    "subject": {
    ///      "type": "string",
    ///      "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "twitter_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": "string",
    ///      "pattern": "^[0-9a-zA-Z|\\_]{1,15}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTwitterInput {
        pub name: LinkedAccountTwitterInputName,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: LinkedAccountTwitterInputSubject,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTwitterInputType,
        pub username: LinkedAccountTwitterInputUsername,
    }

    impl ::std::convert::From<&LinkedAccountTwitterInput> for LinkedAccountTwitterInput {
        fn from(value: &LinkedAccountTwitterInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountTwitterInputName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTwitterInputName(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTwitterInputName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTwitterInputName> for ::std::string::String {
        fn from(value: LinkedAccountTwitterInputName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTwitterInputName> for LinkedAccountTwitterInputName {
        fn from(value: &LinkedAccountTwitterInputName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTwitterInputName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTwitterInputName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTwitterInputSubject`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[\\x00-\\x7F]{1,256}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTwitterInputSubject(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTwitterInputSubject {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTwitterInputSubject> for ::std::string::String {
        fn from(value: LinkedAccountTwitterInputSubject) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTwitterInputSubject> for LinkedAccountTwitterInputSubject {
        fn from(value: &LinkedAccountTwitterInputSubject) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTwitterInputSubject {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[\\x00-\\x7F]{1,256}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[\\x00-\\x7F]{1,256}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputSubject {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTwitterInputSubject {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTwitterInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "twitter_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTwitterInputType {
        #[serde(rename = "twitter_oauth")]
        TwitterOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountTwitterInputType {
        fn from(value: &LinkedAccountTwitterInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountTwitterInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TwitterOauth => f.write_str("twitter_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountTwitterInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "twitter_oauth" => Ok(Self::TwitterOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountTwitterInputUsername`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-zA-Z|\\_]{1,15}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct LinkedAccountTwitterInputUsername(::std::string::String);
    impl ::std::ops::Deref for LinkedAccountTwitterInputUsername {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<LinkedAccountTwitterInputUsername> for ::std::string::String {
        fn from(value: LinkedAccountTwitterInputUsername) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&LinkedAccountTwitterInputUsername>
        for LinkedAccountTwitterInputUsername
    {
        fn from(value: &LinkedAccountTwitterInputUsername) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LinkedAccountTwitterInputUsername {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[0-9a-zA-Z|\\_]{1,15}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^[0-9a-zA-Z|\\_]{1,15}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterInputUsername {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LinkedAccountTwitterInputUsername {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`LinkedAccountTwitterOauth`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Twitter",
    ///  "type": "object",
    ///  "required": [
    ///    "first_verified_at",
    ///    "latest_verified_at",
    ///    "name",
    ///    "profile_picture_url",
    ///    "subject",
    ///    "type",
    ///    "username",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "first_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "latest_verified_at": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "profile_picture_url": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "subject": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "twitter_oauth"
    ///      ]
    ///    },
    ///    "username": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountTwitterOauth {
        pub first_verified_at: ::std::option::Option<f64>,
        pub latest_verified_at: ::std::option::Option<f64>,
        pub name: ::std::option::Option<::std::string::String>,
        pub profile_picture_url: ::std::option::Option<::std::string::String>,
        pub subject: ::std::string::String,
        #[serde(rename = "type")]
        pub type_: LinkedAccountTwitterOauthType,
        pub username: ::std::option::Option<::std::string::String>,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&LinkedAccountTwitterOauth> for LinkedAccountTwitterOauth {
        fn from(value: &LinkedAccountTwitterOauth) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountTwitterOauthType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "twitter_oauth"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountTwitterOauthType {
        #[serde(rename = "twitter_oauth")]
        TwitterOauth,
    }

    impl ::std::convert::From<&Self> for LinkedAccountTwitterOauthType {
        fn from(value: &LinkedAccountTwitterOauthType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountTwitterOauthType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TwitterOauth => f.write_str("twitter_oauth"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountTwitterOauthType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "twitter_oauth" => Ok(Self::TwitterOauth),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountTwitterOauthType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountTwitterOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountTwitterOauthType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountWalletInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Wallet",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_type",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "string"
    ///        }
    ///      ]
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum",
    ///        "solana"
    ///      ]
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "wallet"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinkedAccountWalletInput {
        pub address: LinkedAccountWalletInputAddress,
        pub chain_type: LinkedAccountWalletInputChainType,
        #[serde(rename = "type")]
        pub type_: LinkedAccountWalletInputType,
    }

    impl ::std::convert::From<&LinkedAccountWalletInput> for LinkedAccountWalletInput {
        fn from(value: &LinkedAccountWalletInput) -> Self {
            value.clone()
        }
    }

    ///`LinkedAccountWalletInputAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "string"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum LinkedAccountWalletInputAddress {
        Variant0(::std::string::String),
        Variant1(::std::string::String),
    }

    impl ::std::convert::From<&Self> for LinkedAccountWalletInputAddress {
        fn from(value: &LinkedAccountWalletInputAddress) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountWalletInputAddress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    ///`LinkedAccountWalletInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountWalletInputChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for LinkedAccountWalletInputChainType {
        fn from(value: &LinkedAccountWalletInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountWalletInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountWalletInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountWalletInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountWalletInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountWalletInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LinkedAccountWalletInputType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "wallet"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LinkedAccountWalletInputType {
        #[serde(rename = "wallet")]
        Wallet,
    }

    impl ::std::convert::From<&Self> for LinkedAccountWalletInputType {
        fn from(value: &LinkedAccountWalletInputType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkedAccountWalletInputType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Wallet => f.write_str("wallet"),
            }
        }
    }

    impl ::std::str::FromStr for LinkedAccountWalletInputType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "wallet" => Ok(Self::Wallet),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkedAccountWalletInputType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkedAccountWalletInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkedAccountWalletInputType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`LookUpUserByCustomAuthIdBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "custom_user_id"
    ///  ],
    ///  "properties": {
    ///    "custom_user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByCustomAuthIdBody {
        pub custom_user_id: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByCustomAuthIdBody> for LookUpUserByCustomAuthIdBody {
        fn from(value: &LookUpUserByCustomAuthIdBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByDiscordUsernameBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByDiscordUsernameBody {
        pub username: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByDiscordUsernameBody> for LookUpUserByDiscordUsernameBody {
        fn from(value: &LookUpUserByDiscordUsernameBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByEmailBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string",
    ///      "format": "email"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByEmailBody {
        pub address: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByEmailBody> for LookUpUserByEmailBody {
        fn from(value: &LookUpUserByEmailBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByFarcasterIdBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "fid"
    ///  ],
    ///  "properties": {
    ///    "fid": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByFarcasterIdBody {
        pub fid: f64,
    }

    impl ::std::convert::From<&LookUpUserByFarcasterIdBody> for LookUpUserByFarcasterIdBody {
        fn from(value: &LookUpUserByFarcasterIdBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByGithubUsernameBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByGithubUsernameBody {
        pub username: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByGithubUsernameBody> for LookUpUserByGithubUsernameBody {
        fn from(value: &LookUpUserByGithubUsernameBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByPhoneNumberBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "number"
    ///  ],
    ///  "properties": {
    ///    "number": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByPhoneNumberBody {
        pub number: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByPhoneNumberBody> for LookUpUserByPhoneNumberBody {
        fn from(value: &LookUpUserByPhoneNumberBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserBySmartWalletAddressBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserBySmartWalletAddressBody {
        pub address: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserBySmartWalletAddressBody>
        for LookUpUserBySmartWalletAddressBody
    {
        fn from(value: &LookUpUserBySmartWalletAddressBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByTelegramUserIdBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "telegram_user_id"
    ///  ],
    ///  "properties": {
    ///    "telegram_user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByTelegramUserIdBody {
        pub telegram_user_id: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByTelegramUserIdBody> for LookUpUserByTelegramUserIdBody {
        fn from(value: &LookUpUserByTelegramUserIdBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByTelegramUsernameBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByTelegramUsernameBody {
        pub username: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByTelegramUsernameBody> for LookUpUserByTelegramUsernameBody {
        fn from(value: &LookUpUserByTelegramUsernameBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByTwitterSubjectBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "subject"
    ///  ],
    ///  "properties": {
    ///    "subject": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByTwitterSubjectBody {
        pub subject: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByTwitterSubjectBody> for LookUpUserByTwitterSubjectBody {
        fn from(value: &LookUpUserByTwitterSubjectBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByTwitterUsernameBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "username": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByTwitterUsernameBody {
        pub username: ::std::string::String,
    }

    impl ::std::convert::From<&LookUpUserByTwitterUsernameBody> for LookUpUserByTwitterUsernameBody {
        fn from(value: &LookUpUserByTwitterUsernameBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByWalletAddressBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string"
    ///        },
    ///        {
    ///          "type": "string"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LookUpUserByWalletAddressBody {
        pub address: LookUpUserByWalletAddressBodyAddress,
    }

    impl ::std::convert::From<&LookUpUserByWalletAddressBody> for LookUpUserByWalletAddressBody {
        fn from(value: &LookUpUserByWalletAddressBody) -> Self {
            value.clone()
        }
    }

    ///`LookUpUserByWalletAddressBodyAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "string"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum LookUpUserByWalletAddressBodyAddress {
        Variant0(::std::string::String),
        Variant1(::std::string::String),
    }

    impl ::std::convert::From<&Self> for LookUpUserByWalletAddressBodyAddress {
        fn from(value: &LookUpUserByWalletAddressBodyAddress) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LookUpUserByWalletAddressBodyAddress {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    ///OAuth tokens associated with the user.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "OAuthTokens",
    ///  "description": "OAuth tokens associated with the user.",
    ///  "type": "object",
    ///  "required": [
    ///    "access_token",
    ///    "provider"
    ///  ],
    ///  "properties": {
    ///    "access_token": {
    ///      "type": "string"
    ///    },
    ///    "access_token_expires_in_seconds": {
    ///      "type": "number"
    ///    },
    ///    "provider": {
    ///      "type": "string"
    ///    },
    ///    "refresh_token": {
    ///      "type": "string"
    ///    },
    ///    "refresh_token_expires_in_seconds": {
    ///      "type": "number"
    ///    },
    ///    "scopes": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OAuthTokens {
        pub access_token: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub access_token_expires_in_seconds: ::std::option::Option<f64>,
        pub provider: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refresh_token: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub refresh_token_expires_in_seconds: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub scopes: ::std::vec::Vec<::std::string::String>,
    }

    impl ::std::convert::From<&OAuthTokens> for OAuthTokens {
        fn from(value: &OAuthTokens) -> Self {
            value.clone()
        }
    }

    ///`Offramp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "deposit_instructions",
    ///    "id",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "deposit_instructions": {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "chain",
    ///        "currency",
    ///        "from_address",
    ///        "to_address"
    ///      ],
    ///      "properties": {
    ///        "amount": {
    ///          "type": "string"
    ///        },
    ///        "chain": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ethereum",
    ///            "base",
    ///            "arbitrum",
    ///            "polygon",
    ///            "optimism"
    ///          ]
    ///        },
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usdc"
    ///          ]
    ///        },
    ///        "from_address": {
    ///          "type": "string"
    ///        },
    ///        "to_address": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awaiting_funds",
    ///        "in_review",
    ///        "funds_received",
    ///        "payment_submitted",
    ///        "payment_processed",
    ///        "canceled",
    ///        "error",
    ///        "undeliverable",
    ///        "returned",
    ///        "refunded"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Offramp {
        pub deposit_instructions: OfframpDepositInstructions,
        pub id: ::std::string::String,
        pub status: OfframpStatus,
    }

    impl ::std::convert::From<&Offramp> for Offramp {
        fn from(value: &Offramp) -> Self {
            value.clone()
        }
    }

    ///`OfframpDepositInstructions`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "chain",
    ///    "currency",
    ///    "from_address",
    ///    "to_address"
    ///  ],
    ///  "properties": {
    ///    "amount": {
    ///      "type": "string"
    ///    },
    ///    "chain": {
    ///      "type": "string",
    ///      "enum": [
    ///        "ethereum",
    ///        "base",
    ///        "arbitrum",
    ///        "polygon",
    ///        "optimism"
    ///      ]
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usdc"
    ///      ]
    ///    },
    ///    "from_address": {
    ///      "type": "string"
    ///    },
    ///    "to_address": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OfframpDepositInstructions {
        pub amount: ::std::string::String,
        pub chain: OfframpDepositInstructionsChain,
        pub currency: OfframpDepositInstructionsCurrency,
        pub from_address: ::std::string::String,
        pub to_address: ::std::string::String,
    }

    impl ::std::convert::From<&OfframpDepositInstructions> for OfframpDepositInstructions {
        fn from(value: &OfframpDepositInstructions) -> Self {
            value.clone()
        }
    }

    ///`OfframpDepositInstructionsChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "base",
    ///    "arbitrum",
    ///    "polygon",
    ///    "optimism"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OfframpDepositInstructionsChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
    }

    impl ::std::convert::From<&Self> for OfframpDepositInstructionsChain {
        fn from(value: &OfframpDepositInstructionsChain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OfframpDepositInstructionsChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Base => f.write_str("base"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
            }
        }
    }

    impl ::std::str::FromStr for OfframpDepositInstructionsChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "base" => Ok(Self::Base),
                "arbitrum" => Ok(Self::Arbitrum),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OfframpDepositInstructionsChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OfframpDepositInstructionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OfframpDepositInstructionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`OfframpDepositInstructionsCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OfframpDepositInstructionsCurrency {
        #[serde(rename = "usdc")]
        Usdc,
    }

    impl ::std::convert::From<&Self> for OfframpDepositInstructionsCurrency {
        fn from(value: &OfframpDepositInstructionsCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OfframpDepositInstructionsCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
            }
        }
    }

    impl ::std::str::FromStr for OfframpDepositInstructionsCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OfframpDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OfframpDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OfframpDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`OfframpStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awaiting_funds",
    ///    "in_review",
    ///    "funds_received",
    ///    "payment_submitted",
    ///    "payment_processed",
    ///    "canceled",
    ///    "error",
    ///    "undeliverable",
    ///    "returned",
    ///    "refunded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OfframpStatus {
        #[serde(rename = "awaiting_funds")]
        AwaitingFunds,
        #[serde(rename = "in_review")]
        InReview,
        #[serde(rename = "funds_received")]
        FundsReceived,
        #[serde(rename = "payment_submitted")]
        PaymentSubmitted,
        #[serde(rename = "payment_processed")]
        PaymentProcessed,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "undeliverable")]
        Undeliverable,
        #[serde(rename = "returned")]
        Returned,
        #[serde(rename = "refunded")]
        Refunded,
    }

    impl ::std::convert::From<&Self> for OfframpStatus {
        fn from(value: &OfframpStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OfframpStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwaitingFunds => f.write_str("awaiting_funds"),
                Self::InReview => f.write_str("in_review"),
                Self::FundsReceived => f.write_str("funds_received"),
                Self::PaymentSubmitted => f.write_str("payment_submitted"),
                Self::PaymentProcessed => f.write_str("payment_processed"),
                Self::Canceled => f.write_str("canceled"),
                Self::Error => f.write_str("error"),
                Self::Undeliverable => f.write_str("undeliverable"),
                Self::Returned => f.write_str("returned"),
                Self::Refunded => f.write_str("refunded"),
            }
        }
    }

    impl ::std::str::FromStr for OfframpStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awaiting_funds" => Ok(Self::AwaitingFunds),
                "in_review" => Ok(Self::InReview),
                "funds_received" => Ok(Self::FundsReceived),
                "payment_submitted" => Ok(Self::PaymentSubmitted),
                "payment_processed" => Ok(Self::PaymentProcessed),
                "canceled" => Ok(Self::Canceled),
                "error" => Ok(Self::Error),
                "undeliverable" => Ok(Self::Undeliverable),
                "returned" => Ok(Self::Returned),
                "refunded" => Ok(Self::Refunded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OfframpStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OfframpStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OfframpStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`Onramp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "deposit_instructions",
    ///    "id",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "deposit_instructions": {
    ///      "type": "object",
    ///      "required": [
    ///        "amount",
    ///        "currency",
    ///        "payment_rail"
    ///      ],
    ///      "properties": {
    ///        "account_holder_name": {
    ///          "type": "string"
    ///        },
    ///        "amount": {
    ///          "type": "string"
    ///        },
    ///        "bank_account_number": {
    ///          "type": "string"
    ///        },
    ///        "bank_address": {
    ///          "type": "string"
    ///        },
    ///        "bank_beneficiary_address": {
    ///          "type": "string"
    ///        },
    ///        "bank_beneficiary_name": {
    ///          "type": "string"
    ///        },
    ///        "bank_name": {
    ///          "type": "string"
    ///        },
    ///        "bank_routing_number": {
    ///          "type": "string"
    ///        },
    ///        "bic": {
    ///          "type": "string"
    ///        },
    ///        "currency": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usd",
    ///            "eur"
    ///          ]
    ///        },
    ///        "deposit_message": {
    ///          "type": "string"
    ///        },
    ///        "iban": {
    ///          "type": "string"
    ///        },
    ///        "payment_rail": {
    ///          "type": "string",
    ///          "enum": [
    ///            "sepa",
    ///            "ach_push",
    ///            "wire"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "awaiting_funds",
    ///        "in_review",
    ///        "funds_received",
    ///        "payment_submitted",
    ///        "payment_processed",
    ///        "canceled",
    ///        "error",
    ///        "undeliverable",
    ///        "returned",
    ///        "refunded"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Onramp {
        pub deposit_instructions: OnrampDepositInstructions,
        pub id: ::std::string::String,
        pub status: OnrampStatus,
    }

    impl ::std::convert::From<&Onramp> for Onramp {
        fn from(value: &Onramp) -> Self {
            value.clone()
        }
    }

    ///`OnrampDepositInstructions`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "currency",
    ///    "payment_rail"
    ///  ],
    ///  "properties": {
    ///    "account_holder_name": {
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "type": "string"
    ///    },
    ///    "bank_account_number": {
    ///      "type": "string"
    ///    },
    ///    "bank_address": {
    ///      "type": "string"
    ///    },
    ///    "bank_beneficiary_address": {
    ///      "type": "string"
    ///    },
    ///    "bank_beneficiary_name": {
    ///      "type": "string"
    ///    },
    ///    "bank_name": {
    ///      "type": "string"
    ///    },
    ///    "bank_routing_number": {
    ///      "type": "string"
    ///    },
    ///    "bic": {
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usd",
    ///        "eur"
    ///      ]
    ///    },
    ///    "deposit_message": {
    ///      "type": "string"
    ///    },
    ///    "iban": {
    ///      "type": "string"
    ///    },
    ///    "payment_rail": {
    ///      "type": "string",
    ///      "enum": [
    ///        "sepa",
    ///        "ach_push",
    ///        "wire"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct OnrampDepositInstructions {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_holder_name: ::std::option::Option<::std::string::String>,
        pub amount: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bic: ::std::option::Option<::std::string::String>,
        pub currency: OnrampDepositInstructionsCurrency,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deposit_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub iban: ::std::option::Option<::std::string::String>,
        pub payment_rail: OnrampDepositInstructionsPaymentRail,
    }

    impl ::std::convert::From<&OnrampDepositInstructions> for OnrampDepositInstructions {
        fn from(value: &OnrampDepositInstructions) -> Self {
            value.clone()
        }
    }

    ///`OnrampDepositInstructionsCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usd",
    ///    "eur"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampDepositInstructionsCurrency {
        #[serde(rename = "usd")]
        Usd,
        #[serde(rename = "eur")]
        Eur,
    }

    impl ::std::convert::From<&Self> for OnrampDepositInstructionsCurrency {
        fn from(value: &OnrampDepositInstructionsCurrency) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OnrampDepositInstructionsCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
                Self::Eur => f.write_str("eur"),
            }
        }
    }

    impl ::std::str::FromStr for OnrampDepositInstructionsCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                "eur" => Ok(Self::Eur),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OnrampDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OnrampDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OnrampDepositInstructionsCurrency {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`OnrampDepositInstructionsPaymentRail`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "sepa",
    ///    "ach_push",
    ///    "wire"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampDepositInstructionsPaymentRail {
        #[serde(rename = "sepa")]
        Sepa,
        #[serde(rename = "ach_push")]
        AchPush,
        #[serde(rename = "wire")]
        Wire,
    }

    impl ::std::convert::From<&Self> for OnrampDepositInstructionsPaymentRail {
        fn from(value: &OnrampDepositInstructionsPaymentRail) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OnrampDepositInstructionsPaymentRail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sepa => f.write_str("sepa"),
                Self::AchPush => f.write_str("ach_push"),
                Self::Wire => f.write_str("wire"),
            }
        }
    }

    impl ::std::str::FromStr for OnrampDepositInstructionsPaymentRail {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sepa" => Ok(Self::Sepa),
                "ach_push" => Ok(Self::AchPush),
                "wire" => Ok(Self::Wire),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OnrampDepositInstructionsPaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OnrampDepositInstructionsPaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OnrampDepositInstructionsPaymentRail {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`OnrampStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awaiting_funds",
    ///    "in_review",
    ///    "funds_received",
    ///    "payment_submitted",
    ///    "payment_processed",
    ///    "canceled",
    ///    "error",
    ///    "undeliverable",
    ///    "returned",
    ///    "refunded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OnrampStatus {
        #[serde(rename = "awaiting_funds")]
        AwaitingFunds,
        #[serde(rename = "in_review")]
        InReview,
        #[serde(rename = "funds_received")]
        FundsReceived,
        #[serde(rename = "payment_submitted")]
        PaymentSubmitted,
        #[serde(rename = "payment_processed")]
        PaymentProcessed,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "undeliverable")]
        Undeliverable,
        #[serde(rename = "returned")]
        Returned,
        #[serde(rename = "refunded")]
        Refunded,
    }

    impl ::std::convert::From<&Self> for OnrampStatus {
        fn from(value: &OnrampStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for OnrampStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwaitingFunds => f.write_str("awaiting_funds"),
                Self::InReview => f.write_str("in_review"),
                Self::FundsReceived => f.write_str("funds_received"),
                Self::PaymentSubmitted => f.write_str("payment_submitted"),
                Self::PaymentProcessed => f.write_str("payment_processed"),
                Self::Canceled => f.write_str("canceled"),
                Self::Error => f.write_str("error"),
                Self::Undeliverable => f.write_str("undeliverable"),
                Self::Returned => f.write_str("returned"),
                Self::Refunded => f.write_str("refunded"),
            }
        }
    }

    impl ::std::str::FromStr for OnrampStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awaiting_funds" => Ok(Self::AwaitingFunds),
                "in_review" => Ok(Self::InReview),
                "funds_received" => Ok(Self::FundsReceived),
                "payment_submitted" => Ok(Self::PaymentSubmitted),
                "payment_processed" => Ok(Self::PaymentProcessed),
                "canceled" => Ok(Self::Canceled),
                "error" => Ok(Self::Error),
                "undeliverable" => Ok(Self::Undeliverable),
                "returned" => Ok(Self::Returned),
                "refunded" => Ok(Self::Refunded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for OnrampStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for OnrampStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for OnrampStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The key quorum ID to set as the owner of the resource. If you provide
    /// this, do not specify an owner.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The key quorum ID to set as the owner of the resource.
    /// If you provide this, do not specify an owner.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct OwnerIdInput(pub ::std::string::String);
    impl ::std::ops::Deref for OwnerIdInput {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<OwnerIdInput> for ::std::string::String {
        fn from(value: OwnerIdInput) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&OwnerIdInput> for OwnerIdInput {
        fn from(value: &OwnerIdInput) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for OwnerIdInput {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for OwnerIdInput {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for OwnerIdInput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///The owner of the resource. If you provide this, do not specify an
    /// owner_id as it will be generated automatically. When updating a wallet,
    /// you can set the owner to null to remove the owner.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The owner of the resource. If you provide this, do not
    /// specify an owner_id as it will be generated automatically. When updating
    /// a wallet, you can set the owner to null to remove the owner.",
    ///  "oneOf": [
    ///    {
    ///      "title": "Public key owner",
    ///      "description": "The P-256 public key of the owner of the resource.
    /// If you provide this, do not specify an owner_id as it will be generated
    /// automatically.",
    ///      "type": "object",
    ///      "required": [
    ///        "public_key"
    ///      ],
    ///      "properties": {
    ///        "public_key": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "title": "User owner",
    ///      "description": "The user ID of the owner of the resource. The user
    /// must already exist, and this value must start with \"did:privy:\". If
    /// you provide this, do not specify an owner_id as it will be generated
    /// automatically.",
    ///      "type": "object",
    ///      "required": [
    ///        "user_id"
    ///      ],
    ///      "properties": {
    ///        "user_id": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub enum OwnerInput {
        ///The P-256 public key of the owner of the resource. If you provide
        /// this, do not specify an owner_id as it will be generated
        /// automatically.
        #[serde(rename = "public_key")]
        PublicKey(::std::string::String),
        ///The user ID of the owner of the resource. The user must already
        /// exist, and this value must start with "did:privy:". If you provide
        /// this, do not specify an owner_id as it will be generated
        /// automatically.
        #[serde(rename = "user_id")]
        UserId(::std::string::String),
    }

    impl ::std::convert::From<&Self> for OwnerInput {
        fn from(value: &OwnerInput) -> Self {
            value.clone()
        }
    }

    ///The passkey authentication credential.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PasskeyAuthenticatorAuthenticationCredential",
    ///  "description": "The passkey authentication credential.",
    ///  "type": "object",
    ///  "required": [
    ///    "client_extension_results",
    ///    "id",
    ///    "raw_id",
    ///    "response",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "authenticator_attachment": {
    ///      "type": "string"
    ///    },
    ///    "client_extension_results": {
    ///      "type": "object",
    ///      "properties": {
    ///        "app_id": {
    ///          "type": "boolean"
    ///        },
    ///        "cred_props": {
    ///          "type": "object",
    ///          "properties": {
    ///            "rk": {
    ///              "type": "boolean"
    ///            }
    ///          }
    ///        },
    ///        "hmac_create_secret": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "raw_id": {
    ///      "type": "string"
    ///    },
    ///    "response": {
    ///      "type": "object",
    ///      "required": [
    ///        "authenticator_data",
    ///        "client_data_json",
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "authenticator_data": {
    ///          "type": "string"
    ///        },
    ///        "client_data_json": {
    ///          "type": "string"
    ///        },
    ///        "signature": {
    ///          "type": "string"
    ///        },
    ///        "user_handle": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "public-key"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorAuthenticationCredential {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authenticator_attachment: ::std::option::Option<::std::string::String>,
        pub client_extension_results:
            PasskeyAuthenticatorAuthenticationCredentialClientExtensionResults,
        pub id: ::std::string::String,
        pub raw_id: ::std::string::String,
        pub response: PasskeyAuthenticatorAuthenticationCredentialResponse,
        #[serde(rename = "type")]
        pub type_: PasskeyAuthenticatorAuthenticationCredentialType,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorAuthenticationCredential>
        for PasskeyAuthenticatorAuthenticationCredential
    {
        fn from(value: &PasskeyAuthenticatorAuthenticationCredential) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorAuthenticationCredentialClientExtensionResults`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "app_id": {
    ///      "type": "boolean"
    ///    },
    ///    "cred_props": {
    ///      "type": "object",
    ///      "properties": {
    ///        "rk": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "hmac_create_secret": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorAuthenticationCredentialClientExtensionResults {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub app_id: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cred_props: ::std::option::Option<
            PasskeyAuthenticatorAuthenticationCredentialClientExtensionResultsCredProps,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hmac_create_secret: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorAuthenticationCredentialClientExtensionResults>
        for PasskeyAuthenticatorAuthenticationCredentialClientExtensionResults
    {
        fn from(
            value: &PasskeyAuthenticatorAuthenticationCredentialClientExtensionResults,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default
        for PasskeyAuthenticatorAuthenticationCredentialClientExtensionResults
    {
        fn default() -> Self {
            Self {
                app_id: Default::default(),
                cred_props: Default::default(),
                hmac_create_secret: Default::default(),
            }
        }
    }

    ///`PasskeyAuthenticatorAuthenticationCredentialClientExtensionResultsCredProps`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "rk": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorAuthenticationCredentialClientExtensionResultsCredProps {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rk: ::std::option::Option<bool>,
    }

    impl
        ::std::convert::From<
            &PasskeyAuthenticatorAuthenticationCredentialClientExtensionResultsCredProps,
        > for PasskeyAuthenticatorAuthenticationCredentialClientExtensionResultsCredProps
    {
        fn from(
            value: &PasskeyAuthenticatorAuthenticationCredentialClientExtensionResultsCredProps,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default
        for PasskeyAuthenticatorAuthenticationCredentialClientExtensionResultsCredProps
    {
        fn default() -> Self {
            Self {
                rk: Default::default(),
            }
        }
    }

    ///`PasskeyAuthenticatorAuthenticationCredentialResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "authenticator_data",
    ///    "client_data_json",
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "authenticator_data": {
    ///      "type": "string"
    ///    },
    ///    "client_data_json": {
    ///      "type": "string"
    ///    },
    ///    "signature": {
    ///      "type": "string"
    ///    },
    ///    "user_handle": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorAuthenticationCredentialResponse {
        pub authenticator_data: ::std::string::String,
        pub client_data_json: ::std::string::String,
        pub signature: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_handle: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorAuthenticationCredentialResponse>
        for PasskeyAuthenticatorAuthenticationCredentialResponse
    {
        fn from(value: &PasskeyAuthenticatorAuthenticationCredentialResponse) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorAuthenticationCredentialType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "public-key"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PasskeyAuthenticatorAuthenticationCredentialType {
        #[serde(rename = "public-key")]
        PublicKey,
    }

    impl ::std::convert::From<&Self> for PasskeyAuthenticatorAuthenticationCredentialType {
        fn from(value: &PasskeyAuthenticatorAuthenticationCredentialType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PasskeyAuthenticatorAuthenticationCredentialType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PublicKey => f.write_str("public-key"),
            }
        }
    }

    impl ::std::str::FromStr for PasskeyAuthenticatorAuthenticationCredentialType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "public-key" => Ok(Self::PublicKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PasskeyAuthenticatorAuthenticationCredentialType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for PasskeyAuthenticatorAuthenticationCredentialType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for PasskeyAuthenticatorAuthenticationCredentialType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The passkey authentication options.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PasskeyAuthenticatorAuthenticationOptions",
    ///  "description": "The passkey authentication options.",
    ///  "type": "object",
    ///  "required": [
    ///    "challenge"
    ///  ],
    ///  "properties": {
    ///    "allow_credentials": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "id",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "id": {
    ///            "type": "string"
    ///          },
    ///          "transports": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "string"
    ///            }
    ///          },
    ///          "type": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "challenge": {
    ///      "type": "string"
    ///    },
    ///    "extensions": {
    ///      "type": "object",
    ///      "properties": {
    ///        "app_id": {
    ///          "type": "string"
    ///        },
    ///        "cred_props": {
    ///          "type": "boolean"
    ///        },
    ///        "hmac_create_secret": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "rp_id": {
    ///      "type": "string"
    ///    },
    ///    "timeout": {
    ///      "type": "number"
    ///    },
    ///    "user_verification": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorAuthenticationOptions {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub allow_credentials:
            ::std::vec::Vec<PasskeyAuthenticatorAuthenticationOptionsAllowCredentialsItem>,
        pub challenge: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub extensions: ::std::option::Option<PasskeyAuthenticatorAuthenticationOptionsExtensions>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rp_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub timeout: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_verification: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorAuthenticationOptions>
        for PasskeyAuthenticatorAuthenticationOptions
    {
        fn from(value: &PasskeyAuthenticatorAuthenticationOptions) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorAuthenticationOptionsAllowCredentialsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "transports": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorAuthenticationOptionsAllowCredentialsItem {
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transports: ::std::vec::Vec<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorAuthenticationOptionsAllowCredentialsItem>
        for PasskeyAuthenticatorAuthenticationOptionsAllowCredentialsItem
    {
        fn from(value: &PasskeyAuthenticatorAuthenticationOptionsAllowCredentialsItem) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorAuthenticationOptionsExtensions`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "app_id": {
    ///      "type": "string"
    ///    },
    ///    "cred_props": {
    ///      "type": "boolean"
    ///    },
    ///    "hmac_create_secret": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorAuthenticationOptionsExtensions {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub app_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cred_props: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hmac_create_secret: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorAuthenticationOptionsExtensions>
        for PasskeyAuthenticatorAuthenticationOptionsExtensions
    {
        fn from(value: &PasskeyAuthenticatorAuthenticationOptionsExtensions) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PasskeyAuthenticatorAuthenticationOptionsExtensions {
        fn default() -> Self {
            Self {
                app_id: Default::default(),
                cred_props: Default::default(),
                hmac_create_secret: Default::default(),
            }
        }
    }

    ///The passkey registration credential.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PasskeyAuthenticatorRegistrationCredential",
    ///  "description": "The passkey registration credential.",
    ///  "type": "object",
    ///  "required": [
    ///    "client_extension_results",
    ///    "id",
    ///    "raw_id",
    ///    "response",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "authenticator_attachment": {
    ///      "type": "string"
    ///    },
    ///    "client_extension_results": {
    ///      "type": "object",
    ///      "properties": {
    ///        "app_id": {
    ///          "type": "boolean"
    ///        },
    ///        "cred_props": {
    ///          "type": "object",
    ///          "properties": {
    ///            "rk": {
    ///              "type": "boolean"
    ///            }
    ///          }
    ///        },
    ///        "hmac_create_secret": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "raw_id": {
    ///      "type": "string"
    ///    },
    ///    "response": {
    ///      "type": "object",
    ///      "required": [
    ///        "attestation_object",
    ///        "client_data_json"
    ///      ],
    ///      "properties": {
    ///        "attestation_object": {
    ///          "type": "string"
    ///        },
    ///        "authenticator_data": {
    ///          "type": "string"
    ///        },
    ///        "client_data_json": {
    ///          "type": "string"
    ///        },
    ///        "public_key": {
    ///          "type": "string"
    ///        },
    ///        "public_key_algorithm": {
    ///          "type": "number"
    ///        },
    ///        "transports": {
    ///          "type": "array",
    ///          "items": {}
    ///        }
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "public-key"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationCredential {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authenticator_attachment: ::std::option::Option<::std::string::String>,
        pub client_extension_results:
            PasskeyAuthenticatorRegistrationCredentialClientExtensionResults,
        pub id: ::std::string::String,
        pub raw_id: ::std::string::String,
        pub response: PasskeyAuthenticatorRegistrationCredentialResponse,
        #[serde(rename = "type")]
        pub type_: PasskeyAuthenticatorRegistrationCredentialType,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationCredential>
        for PasskeyAuthenticatorRegistrationCredential
    {
        fn from(value: &PasskeyAuthenticatorRegistrationCredential) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorRegistrationCredentialClientExtensionResults`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "app_id": {
    ///      "type": "boolean"
    ///    },
    ///    "cred_props": {
    ///      "type": "object",
    ///      "properties": {
    ///        "rk": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "hmac_create_secret": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationCredentialClientExtensionResults {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub app_id: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cred_props: ::std::option::Option<
            PasskeyAuthenticatorRegistrationCredentialClientExtensionResultsCredProps,
        >,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hmac_create_secret: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationCredentialClientExtensionResults>
        for PasskeyAuthenticatorRegistrationCredentialClientExtensionResults
    {
        fn from(value: &PasskeyAuthenticatorRegistrationCredentialClientExtensionResults) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PasskeyAuthenticatorRegistrationCredentialClientExtensionResults {
        fn default() -> Self {
            Self {
                app_id: Default::default(),
                cred_props: Default::default(),
                hmac_create_secret: Default::default(),
            }
        }
    }

    ///`PasskeyAuthenticatorRegistrationCredentialClientExtensionResultsCredProps`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "rk": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationCredentialClientExtensionResultsCredProps {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rk: ::std::option::Option<bool>,
    }

    impl
        ::std::convert::From<
            &PasskeyAuthenticatorRegistrationCredentialClientExtensionResultsCredProps,
        > for PasskeyAuthenticatorRegistrationCredentialClientExtensionResultsCredProps
    {
        fn from(
            value: &PasskeyAuthenticatorRegistrationCredentialClientExtensionResultsCredProps,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default
        for PasskeyAuthenticatorRegistrationCredentialClientExtensionResultsCredProps
    {
        fn default() -> Self {
            Self {
                rk: Default::default(),
            }
        }
    }

    ///`PasskeyAuthenticatorRegistrationCredentialResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "attestation_object",
    ///    "client_data_json"
    ///  ],
    ///  "properties": {
    ///    "attestation_object": {
    ///      "type": "string"
    ///    },
    ///    "authenticator_data": {
    ///      "type": "string"
    ///    },
    ///    "client_data_json": {
    ///      "type": "string"
    ///    },
    ///    "public_key": {
    ///      "type": "string"
    ///    },
    ///    "public_key_algorithm": {
    ///      "type": "number"
    ///    },
    ///    "transports": {
    ///      "type": "array",
    ///      "items": {}
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationCredentialResponse {
        pub attestation_object: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authenticator_data: ::std::option::Option<::std::string::String>,
        pub client_data_json: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_key: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_key_algorithm: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transports: ::std::vec::Vec<::serde_json::Value>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationCredentialResponse>
        for PasskeyAuthenticatorRegistrationCredentialResponse
    {
        fn from(value: &PasskeyAuthenticatorRegistrationCredentialResponse) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorRegistrationCredentialType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "public-key"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PasskeyAuthenticatorRegistrationCredentialType {
        #[serde(rename = "public-key")]
        PublicKey,
    }

    impl ::std::convert::From<&Self> for PasskeyAuthenticatorRegistrationCredentialType {
        fn from(value: &PasskeyAuthenticatorRegistrationCredentialType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PasskeyAuthenticatorRegistrationCredentialType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PublicKey => f.write_str("public-key"),
            }
        }
    }

    impl ::std::str::FromStr for PasskeyAuthenticatorRegistrationCredentialType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "public-key" => Ok(Self::PublicKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PasskeyAuthenticatorRegistrationCredentialType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for PasskeyAuthenticatorRegistrationCredentialType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for PasskeyAuthenticatorRegistrationCredentialType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The passkey registration options.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PasskeyAuthenticatorRegistrationOptions",
    ///  "description": "The passkey registration options.",
    ///  "type": "object",
    ///  "required": [
    ///    "challenge",
    ///    "pub_key_cred_params",
    ///    "rp",
    ///    "user"
    ///  ],
    ///  "properties": {
    ///    "attestation": {
    ///      "type": "string"
    ///    },
    ///    "authenticator_selection": {
    ///      "type": "object",
    ///      "properties": {
    ///        "authenticator_attachment": {
    ///          "type": "string"
    ///        },
    ///        "require_resident_key": {
    ///          "type": "boolean"
    ///        },
    ///        "resident_key": {
    ///          "type": "string"
    ///        },
    ///        "user_verification": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "challenge": {
    ///      "type": "string"
    ///    },
    ///    "exclude_credentials": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "id",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "id": {
    ///            "type": "string"
    ///          },
    ///          "transports": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "string"
    ///            }
    ///          },
    ///          "type": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "extensions": {
    ///      "type": "object",
    ///      "properties": {
    ///        "app_id": {
    ///          "type": "string"
    ///        },
    ///        "cred_props": {
    ///          "type": "object",
    ///          "properties": {
    ///            "rk": {
    ///              "type": "boolean"
    ///            }
    ///          }
    ///        },
    ///        "hmac_create_secret": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "pub_key_cred_params": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "alg",
    ///          "type"
    ///        ],
    ///        "properties": {
    ///          "alg": {
    ///            "type": "number"
    ///          },
    ///          "type": {
    ///            "type": "string",
    ///            "enum": [
    ///              "public-key"
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "rp": {
    ///      "type": "object",
    ///      "required": [
    ///        "name"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string"
    ///        },
    ///        "name": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "timeout": {
    ///      "type": "number"
    ///    },
    ///    "user": {
    ///      "type": "object",
    ///      "required": [
    ///        "display_name",
    ///        "id",
    ///        "name"
    ///      ],
    ///      "properties": {
    ///        "display_name": {
    ///          "type": "string"
    ///        },
    ///        "id": {
    ///          "type": "string"
    ///        },
    ///        "name": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptions {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub attestation: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authenticator_selection:
            ::std::option::Option<PasskeyAuthenticatorRegistrationOptionsAuthenticatorSelection>,
        pub challenge: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub exclude_credentials:
            ::std::vec::Vec<PasskeyAuthenticatorRegistrationOptionsExcludeCredentialsItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub extensions: ::std::option::Option<PasskeyAuthenticatorRegistrationOptionsExtensions>,
        pub pub_key_cred_params:
            ::std::vec::Vec<PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItem>,
        pub rp: PasskeyAuthenticatorRegistrationOptionsRp,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub timeout: ::std::option::Option<f64>,
        pub user: PasskeyAuthenticatorRegistrationOptionsUser,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptions>
        for PasskeyAuthenticatorRegistrationOptions
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptions) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsAuthenticatorSelection`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "authenticator_attachment": {
    ///      "type": "string"
    ///    },
    ///    "require_resident_key": {
    ///      "type": "boolean"
    ///    },
    ///    "resident_key": {
    ///      "type": "string"
    ///    },
    ///    "user_verification": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptionsAuthenticatorSelection {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authenticator_attachment: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub require_resident_key: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resident_key: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub user_verification: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptionsAuthenticatorSelection>
        for PasskeyAuthenticatorRegistrationOptionsAuthenticatorSelection
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsAuthenticatorSelection) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PasskeyAuthenticatorRegistrationOptionsAuthenticatorSelection {
        fn default() -> Self {
            Self {
                authenticator_attachment: Default::default(),
                require_resident_key: Default::default(),
                resident_key: Default::default(),
                user_verification: Default::default(),
            }
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsExcludeCredentialsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "transports": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptionsExcludeCredentialsItem {
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transports: ::std::vec::Vec<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptionsExcludeCredentialsItem>
        for PasskeyAuthenticatorRegistrationOptionsExcludeCredentialsItem
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsExcludeCredentialsItem) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsExtensions`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "app_id": {
    ///      "type": "string"
    ///    },
    ///    "cred_props": {
    ///      "type": "object",
    ///      "properties": {
    ///        "rk": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    },
    ///    "hmac_create_secret": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptionsExtensions {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub app_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cred_props:
            ::std::option::Option<PasskeyAuthenticatorRegistrationOptionsExtensionsCredProps>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hmac_create_secret: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptionsExtensions>
        for PasskeyAuthenticatorRegistrationOptionsExtensions
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsExtensions) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PasskeyAuthenticatorRegistrationOptionsExtensions {
        fn default() -> Self {
            Self {
                app_id: Default::default(),
                cred_props: Default::default(),
                hmac_create_secret: Default::default(),
            }
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsExtensionsCredProps`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "rk": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptionsExtensionsCredProps {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rk: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptionsExtensionsCredProps>
        for PasskeyAuthenticatorRegistrationOptionsExtensionsCredProps
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsExtensionsCredProps) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for PasskeyAuthenticatorRegistrationOptionsExtensionsCredProps {
        fn default() -> Self {
            Self {
                rk: Default::default(),
            }
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "alg",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "alg": {
    ///      "type": "number"
    ///    },
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "public-key"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItem {
        pub alg: f64,
        #[serde(rename = "type")]
        pub type_: PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItem>
        for PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItem
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItem) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "public-key"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType {
        #[serde(rename = "public-key")]
        PublicKey,
    }

    impl ::std::convert::From<&Self>
        for PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PublicKey => f.write_str("public-key"),
            }
        }
    }

    impl ::std::str::FromStr for PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "public-key" => Ok(Self::PublicKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for PasskeyAuthenticatorRegistrationOptionsPubKeyCredParamsItemType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsRp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptionsRp {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub id: ::std::option::Option<::std::string::String>,
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptionsRp>
        for PasskeyAuthenticatorRegistrationOptionsRp
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsRp) -> Self {
            value.clone()
        }
    }

    ///`PasskeyAuthenticatorRegistrationOptionsUser`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyAuthenticatorRegistrationOptionsUser {
        pub display_name: ::std::string::String,
        pub id: ::std::string::String,
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&PasskeyAuthenticatorRegistrationOptionsUser>
        for PasskeyAuthenticatorRegistrationOptionsUser
    {
        fn from(value: &PasskeyAuthenticatorRegistrationOptionsUser) -> Self {
            value.clone()
        }
    }

    ///`PasskeyMfaMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Passkey",
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passkey"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PasskeyMfaMethod {
        #[serde(rename = "type")]
        pub type_: PasskeyMfaMethodType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&PasskeyMfaMethod> for PasskeyMfaMethod {
        fn from(value: &PasskeyMfaMethod) -> Self {
            value.clone()
        }
    }

    ///`PasskeyMfaMethodType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passkey"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PasskeyMfaMethodType {
        #[serde(rename = "passkey")]
        Passkey,
    }

    impl ::std::convert::From<&Self> for PasskeyMfaMethodType {
        fn from(value: &PasskeyMfaMethodType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PasskeyMfaMethodType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passkey => f.write_str("passkey"),
            }
        }
    }

    impl ::std::str::FromStr for PasskeyMfaMethodType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passkey" => Ok(Self::Passkey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PasskeyMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PasskeyMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PasskeyMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PasskeyRelyingPartyUrl`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PasskeyRelyingPartyUrl",
    ///  "type": "string",
    ///  "format": "uri"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(transparent)]
    pub struct PasskeyRelyingPartyUrl(pub ::std::string::String);
    impl ::std::ops::Deref for PasskeyRelyingPartyUrl {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PasskeyRelyingPartyUrl> for ::std::string::String {
        fn from(value: PasskeyRelyingPartyUrl) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PasskeyRelyingPartyUrl> for PasskeyRelyingPartyUrl {
        fn from(value: &PasskeyRelyingPartyUrl) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::string::String> for PasskeyRelyingPartyUrl {
        fn from(value: ::std::string::String) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for PasskeyRelyingPartyUrl {
        type Err = ::std::convert::Infallible;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::fmt::Display for PasskeyRelyingPartyUrl {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    ///`Policy`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "chain_type": "ethereum",
    ///      "created_at": 1741833088894,
    ///      "id": "tb54eps4z44ed0jepousxi4n",
    ///      "name": "Allowlisted stablecoins",
    ///      "owner_id": null,
    ///      "rules": [
    ///        {
    ///          "action": "ALLOW",
    ///          "conditions": [
    ///            {
    ///              "field": "to",
    ///              "field_source": "ethereum_transaction",
    ///              "operator": "eq",
    ///              "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///            }
    ///          ],
    ///          "id": "bdyfoa65pro1eez6iwtzanol",
    ///          "method": "eth_sendTransaction",
    ///          "name": "Allowlist USDC contract on Base"
    ///        }
    ///      ],
    ///      "version": "1.0"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "chain_type",
    ///    "created_at",
    ///    "id",
    ///    "name",
    ///    "owner_id",
    ///    "rules",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/PolicyChainType"
    ///    },
    ///    "created_at": {
    ///      "description": "Unix timestamp of when the policy was created in
    /// milliseconds.",
    ///      "type": "number"
    ///    },
    ///    "id": {
    ///      "description": "Unique ID of the created policy. This will be the
    /// primary identifier when using the policy in the future.",
    ///      "type": "string",
    ///      "maxLength": 24,
    ///      "minLength": 24
    ///    },
    ///    "name": {
    ///      "description": "Name to assign to policy.",
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "owner_id": {
    ///      "description": "The key quorum ID of the owner of the policy.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PolicyRuleResponse"
    ///      }
    ///    },
    ///    "version": {
    ///      "description": "Version of the policy. Currently, 1.0 is the only
    /// version.",
    ///      "type": "string",
    ///      "enum": [
    ///        "1.0"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Policy {
        pub chain_type: PolicyChainType,
        pub created_at: f64,
        ///Unique ID of the created policy. This will be the primary identifier
        /// when using the policy in the future.
        pub id: PolicyId,
        ///Name to assign to policy.
        pub name: PolicyName,
        ///The key quorum ID of the owner of the policy.
        pub owner_id: ::std::option::Option<::std::string::String>,
        pub rules: ::std::vec::Vec<PolicyRuleResponse>,
        ///Version of the policy. Currently, 1.0 is the only version.
        pub version: PolicyVersion,
    }

    impl ::std::convert::From<&Policy> for Policy {
        fn from(value: &Policy) -> Self {
            value.clone()
        }
    }

    ///Action to take if the conditions are true.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PolicyAction",
    ///  "description": "Action to take if the conditions are true.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ALLOW",
    ///    "DENY"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyAction {
        #[serde(rename = "ALLOW")]
        Allow,
        #[serde(rename = "DENY")]
        Deny,
    }

    impl ::std::convert::From<&Self> for PolicyAction {
        fn from(value: &PolicyAction) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PolicyAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Allow => f.write_str("ALLOW"),
                Self::Deny => f.write_str("DENY"),
            }
        }
    }

    impl ::std::str::FromStr for PolicyAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ALLOW" => Ok(Self::Allow),
                "DENY" => Ok(Self::Deny),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The chain type the policy applies to.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The chain type the policy applies to.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyChainType {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for PolicyChainType {
        fn from(value: &PolicyChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PolicyChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for PolicyChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///A condition that must be true for the rule action to be applied.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PolicyCondition",
    ///  "description": "A condition that must be true for the rule action to be
    /// applied.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EthereumTransactionCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumCalldataCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumTypedDataDomainCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumTypedDataMessageCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/Ethereum7702AuthorizationCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolanaProgramInstructionCondition"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/SolanaSystemProgramInstructionCondition"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/SolanaTokenProgramInstructionCondition"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SystemCondition"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PolicyCondition {
        EthereumTransactionCondition(EthereumTransactionCondition),
        EthereumCalldataCondition(EthereumCalldataCondition),
        EthereumTypedDataDomainCondition(EthereumTypedDataDomainCondition),
        EthereumTypedDataMessageCondition(EthereumTypedDataMessageCondition),
        Ethereum7702AuthorizationCondition(Ethereum7702AuthorizationCondition),
        SolanaProgramInstructionCondition(SolanaProgramInstructionCondition),
        SolanaSystemProgramInstructionCondition(SolanaSystemProgramInstructionCondition),
        SolanaTokenProgramInstructionCondition(SolanaTokenProgramInstructionCondition),
        SystemCondition(SystemCondition),
    }

    impl ::std::convert::From<&Self> for PolicyCondition {
        fn from(value: &PolicyCondition) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EthereumTransactionCondition> for PolicyCondition {
        fn from(value: EthereumTransactionCondition) -> Self {
            Self::EthereumTransactionCondition(value)
        }
    }

    impl ::std::convert::From<EthereumCalldataCondition> for PolicyCondition {
        fn from(value: EthereumCalldataCondition) -> Self {
            Self::EthereumCalldataCondition(value)
        }
    }

    impl ::std::convert::From<EthereumTypedDataDomainCondition> for PolicyCondition {
        fn from(value: EthereumTypedDataDomainCondition) -> Self {
            Self::EthereumTypedDataDomainCondition(value)
        }
    }

    impl ::std::convert::From<EthereumTypedDataMessageCondition> for PolicyCondition {
        fn from(value: EthereumTypedDataMessageCondition) -> Self {
            Self::EthereumTypedDataMessageCondition(value)
        }
    }

    impl ::std::convert::From<Ethereum7702AuthorizationCondition> for PolicyCondition {
        fn from(value: Ethereum7702AuthorizationCondition) -> Self {
            Self::Ethereum7702AuthorizationCondition(value)
        }
    }

    impl ::std::convert::From<SolanaProgramInstructionCondition> for PolicyCondition {
        fn from(value: SolanaProgramInstructionCondition) -> Self {
            Self::SolanaProgramInstructionCondition(value)
        }
    }

    impl ::std::convert::From<SolanaSystemProgramInstructionCondition> for PolicyCondition {
        fn from(value: SolanaSystemProgramInstructionCondition) -> Self {
            Self::SolanaSystemProgramInstructionCondition(value)
        }
    }

    impl ::std::convert::From<SolanaTokenProgramInstructionCondition> for PolicyCondition {
        fn from(value: SolanaTokenProgramInstructionCondition) -> Self {
            Self::SolanaTokenProgramInstructionCondition(value)
        }
    }

    impl ::std::convert::From<SystemCondition> for PolicyCondition {
        fn from(value: SystemCondition) -> Self {
            Self::SystemCondition(value)
        }
    }

    ///Unique ID of the created policy. This will be the primary identifier
    /// when using the policy in the future.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unique ID of the created policy. This will be the
    /// primary identifier when using the policy in the future.",
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyId(::std::string::String);
    impl ::std::ops::Deref for PolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PolicyId> for ::std::string::String {
        fn from(value: PolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PolicyId> for PolicyId {
        fn from(value: &PolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`PolicyMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "eth_sendTransaction",
    ///    "eth_signTransaction",
    ///    "eth_signTypedData_v4",
    ///    "eth_sign7702Authorization",
    ///    "signTransaction",
    ///    "signAndSendTransaction",
    ///    "exportPrivateKey",
    ///    "*"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyMethod {
        #[serde(rename = "eth_sendTransaction")]
        EthSendTransaction,
        #[serde(rename = "eth_signTransaction")]
        EthSignTransaction,
        #[serde(rename = "eth_signTypedData_v4")]
        EthSignTypedDataV4,
        #[serde(rename = "eth_sign7702Authorization")]
        EthSign7702Authorization,
        #[serde(rename = "signTransaction")]
        SignTransaction,
        #[serde(rename = "signAndSendTransaction")]
        SignAndSendTransaction,
        #[serde(rename = "exportPrivateKey")]
        ExportPrivateKey,
        #[serde(rename = "*")]
        X,
    }

    impl ::std::convert::From<&Self> for PolicyMethod {
        fn from(value: &PolicyMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PolicyMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::EthSendTransaction => f.write_str("eth_sendTransaction"),
                Self::EthSignTransaction => f.write_str("eth_signTransaction"),
                Self::EthSignTypedDataV4 => f.write_str("eth_signTypedData_v4"),
                Self::EthSign7702Authorization => f.write_str("eth_sign7702Authorization"),
                Self::SignTransaction => f.write_str("signTransaction"),
                Self::SignAndSendTransaction => f.write_str("signAndSendTransaction"),
                Self::ExportPrivateKey => f.write_str("exportPrivateKey"),
                Self::X => f.write_str("*"),
            }
        }
    }

    impl ::std::str::FromStr for PolicyMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "eth_sendTransaction" => Ok(Self::EthSendTransaction),
                "eth_signTransaction" => Ok(Self::EthSignTransaction),
                "eth_signTypedData_v4" => Ok(Self::EthSignTypedDataV4),
                "eth_sign7702Authorization" => Ok(Self::EthSign7702Authorization),
                "signTransaction" => Ok(Self::SignTransaction),
                "signAndSendTransaction" => Ok(Self::SignAndSendTransaction),
                "exportPrivateKey" => Ok(Self::ExportPrivateKey),
                "*" => Ok(Self::X),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Name to assign to policy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Name to assign to policy.",
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyName(::std::string::String);
    impl ::std::ops::Deref for PolicyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PolicyName> for ::std::string::String {
        fn from(value: PolicyName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PolicyName> for PolicyName {
        fn from(value: &PolicyName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PolicyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PolicyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Unique ID of the policy to take actions on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unique ID of the policy to take actions on.",
    ///  "type": "object",
    ///  "required": [
    ///    "policy_id"
    ///  ],
    ///  "properties": {
    ///    "policy_id": {
    ///      "type": "string",
    ///      "maxLength": 24,
    ///      "minLength": 24
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PolicyRequestBody {
        pub policy_id: PolicyRequestBodyPolicyId,
    }

    impl ::std::convert::From<&PolicyRequestBody> for PolicyRequestBody {
        fn from(value: &PolicyRequestBody) -> Self {
            value.clone()
        }
    }

    ///`PolicyRequestBodyPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyRequestBodyPolicyId(::std::string::String);
    impl ::std::ops::Deref for PolicyRequestBodyPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PolicyRequestBodyPolicyId> for ::std::string::String {
        fn from(value: PolicyRequestBodyPolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PolicyRequestBodyPolicyId> for PolicyRequestBodyPolicyId {
        fn from(value: &PolicyRequestBodyPolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PolicyRequestBodyPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyRequestBodyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRequestBodyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyRequestBodyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PolicyRequestBodyPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The rules that apply to each method the policy covers.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PolicyRuleRequestBody",
    ///  "description": "The rules that apply to each method the policy
    /// covers.",
    ///  "type": "object",
    ///  "required": [
    ///    "action",
    ///    "conditions",
    ///    "method",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "$ref": "#/components/schemas/PolicyAction"
    ///    },
    ///    "conditions": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PolicyCondition"
    ///      }
    ///    },
    ///    "method": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/PolicyMethod"
    ///        },
    ///        {
    ///          "description": "Method the rule applies to."
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "type": "string",
    ///      "maxLength": 50
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PolicyRuleRequestBody {
        pub action: PolicyAction,
        pub conditions: ::std::vec::Vec<PolicyCondition>,
        pub method: PolicyMethod,
        pub name: PolicyRuleRequestBodyName,
    }

    impl ::std::convert::From<&PolicyRuleRequestBody> for PolicyRuleRequestBody {
        fn from(value: &PolicyRuleRequestBody) -> Self {
            value.clone()
        }
    }

    ///`PolicyRuleRequestBodyName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyRuleRequestBodyName(::std::string::String);
    impl ::std::ops::Deref for PolicyRuleRequestBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PolicyRuleRequestBodyName> for ::std::string::String {
        fn from(value: PolicyRuleRequestBodyName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PolicyRuleRequestBodyName> for PolicyRuleRequestBodyName {
        fn from(value: &PolicyRuleRequestBodyName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PolicyRuleRequestBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyRuleRequestBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRuleRequestBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyRuleRequestBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PolicyRuleRequestBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Unique IDs of the policy and the rule within the policy to take actions
    /// on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unique IDs of the policy and the rule within the policy
    /// to take actions on.",
    ///  "type": "object",
    ///  "required": [
    ///    "policy_id",
    ///    "rule_id"
    ///  ],
    ///  "properties": {
    ///    "policy_id": {
    ///      "type": "string",
    ///      "maxLength": 24,
    ///      "minLength": 24
    ///    },
    ///    "rule_id": {
    ///      "type": "string",
    ///      "maxLength": 24,
    ///      "minLength": 24
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PolicyRuleRequestParams {
        pub policy_id: PolicyRuleRequestParamsPolicyId,
        pub rule_id: PolicyRuleRequestParamsRuleId,
    }

    impl ::std::convert::From<&PolicyRuleRequestParams> for PolicyRuleRequestParams {
        fn from(value: &PolicyRuleRequestParams) -> Self {
            value.clone()
        }
    }

    ///`PolicyRuleRequestParamsPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyRuleRequestParamsPolicyId(::std::string::String);
    impl ::std::ops::Deref for PolicyRuleRequestParamsPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PolicyRuleRequestParamsPolicyId> for ::std::string::String {
        fn from(value: PolicyRuleRequestParamsPolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PolicyRuleRequestParamsPolicyId> for PolicyRuleRequestParamsPolicyId {
        fn from(value: &PolicyRuleRequestParamsPolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PolicyRuleRequestParamsPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyRuleRequestParamsPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRuleRequestParamsPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyRuleRequestParamsPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PolicyRuleRequestParamsPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`PolicyRuleRequestParamsRuleId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyRuleRequestParamsRuleId(::std::string::String);
    impl ::std::ops::Deref for PolicyRuleRequestParamsRuleId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PolicyRuleRequestParamsRuleId> for ::std::string::String {
        fn from(value: PolicyRuleRequestParamsRuleId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PolicyRuleRequestParamsRuleId> for PolicyRuleRequestParamsRuleId {
        fn from(value: &PolicyRuleRequestParamsRuleId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PolicyRuleRequestParamsRuleId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyRuleRequestParamsRuleId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRuleRequestParamsRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyRuleRequestParamsRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PolicyRuleRequestParamsRuleId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///A rule that defines the conditions and action to take if the conditions
    /// are true.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "PolicyRuleResponse",
    ///  "description": "A rule that defines the conditions and action to take
    /// if the conditions are true.",
    ///  "examples": [
    ///    {
    ///      "action": "ALLOW",
    ///      "conditions": [
    ///        {
    ///          "field": "to",
    ///          "field_source": "ethereum_transaction",
    ///          "operator": "eq",
    ///          "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///        }
    ///      ],
    ///      "id": "rule_123",
    ///      "method": "eth_sendTransaction",
    ///      "name": "Allowlist USDC contract on Base"
    ///    }
    ///  ],
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PolicyRuleRequestBody"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PolicyRuleResponse {
        pub action: PolicyAction,
        pub conditions: ::std::vec::Vec<PolicyCondition>,
        pub id: ::std::string::String,
        pub method: PolicyMethod,
        pub name: PolicyRuleResponseName,
    }

    impl ::std::convert::From<&PolicyRuleResponse> for PolicyRuleResponse {
        fn from(value: &PolicyRuleResponse) -> Self {
            value.clone()
        }
    }

    ///`PolicyRuleResponseName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct PolicyRuleResponseName(::std::string::String);
    impl ::std::ops::Deref for PolicyRuleResponseName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<PolicyRuleResponseName> for ::std::string::String {
        fn from(value: PolicyRuleResponseName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&PolicyRuleResponseName> for PolicyRuleResponseName {
        fn from(value: &PolicyRuleResponseName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PolicyRuleResponseName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyRuleResponseName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyRuleResponseName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyRuleResponseName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PolicyRuleResponseName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Version of the policy. Currently, 1.0 is the only version.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Version of the policy. Currently, 1.0 is the only
    /// version.",
    ///  "type": "string",
    ///  "enum": [
    ///    "1.0"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyVersion {
        #[serde(rename = "1.0")]
        X10,
    }

    impl ::std::convert::From<&Self> for PolicyVersion {
        fn from(value: &PolicyVersion) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PolicyVersion {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::X10 => f.write_str("1.0"),
            }
        }
    }

    impl ::std::str::FromStr for PolicyVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "1.0" => Ok(Self::X10),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PolicyVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PolicyVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PolicyVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The input for private key wallets.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The input for private key wallets.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_type",
    ///    "encryption_type",
    ///    "entropy_type"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address of the wallet to import.",
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/WalletImportSupportedChains"
    ///    },
    ///    "encryption_type": {
    ///      "$ref": "#/components/schemas/HPKEEncryption"
    ///    },
    ///    "entropy_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "private-key"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PrivateKeyInitInput {
        ///The address of the wallet to import.
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        pub encryption_type: HpkeEncryption,
        pub entropy_type: PrivateKeyInitInputEntropyType,
    }

    impl ::std::convert::From<&PrivateKeyInitInput> for PrivateKeyInitInput {
        fn from(value: &PrivateKeyInitInput) -> Self {
            value.clone()
        }
    }

    ///`PrivateKeyInitInputEntropyType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "private-key"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrivateKeyInitInputEntropyType {
        #[serde(rename = "private-key")]
        PrivateKey,
    }

    impl ::std::convert::From<&Self> for PrivateKeyInitInputEntropyType {
        fn from(value: &PrivateKeyInitInputEntropyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PrivateKeyInitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PrivateKey => f.write_str("private-key"),
            }
        }
    }

    impl ::std::str::FromStr for PrivateKeyInitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "private-key" => Ok(Self::PrivateKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PrivateKeyInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PrivateKeyInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PrivateKeyInitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`PrivateKeySubmitInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain_type",
    ///    "ciphertext",
    ///    "encapsulated_key",
    ///    "encryption_type",
    ///    "entropy_type"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address of the wallet to import.",
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/WalletImportSupportedChains"
    ///    },
    ///    "ciphertext": {
    ///      "description": "The encrypted entropy of the wallet to import.",
    ///      "type": "string"
    ///    },
    ///    "encapsulated_key": {
    ///      "description": "The base64-encoded encapsulated key that was generated during encryption, for use during decryption inside the TEE.",
    ///      "type": "string"
    ///    },
    ///    "encryption_type": {
    ///      "$ref": "#/components/schemas/HPKEEncryption"
    ///    },
    ///    "entropy_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "private-key"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PrivateKeySubmitInput {
        ///The address of the wallet to import.
        pub address: ::std::string::String,
        pub chain_type: WalletImportSupportedChains,
        ///The encrypted entropy of the wallet to import.
        pub ciphertext: ::std::string::String,
        ///The base64-encoded encapsulated key that was generated during
        /// encryption, for use during decryption inside the TEE.
        pub encapsulated_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
        pub entropy_type: PrivateKeySubmitInputEntropyType,
    }

    impl ::std::convert::From<&PrivateKeySubmitInput> for PrivateKeySubmitInput {
        fn from(value: &PrivateKeySubmitInput) -> Self {
            value.clone()
        }
    }

    ///`PrivateKeySubmitInputEntropyType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "private-key"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PrivateKeySubmitInputEntropyType {
        #[serde(rename = "private-key")]
        PrivateKey,
    }

    impl ::std::convert::From<&Self> for PrivateKeySubmitInputEntropyType {
        fn from(value: &PrivateKeySubmitInputEntropyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PrivateKeySubmitInputEntropyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::PrivateKey => f.write_str("private-key"),
            }
        }
    }

    impl ::std::str::FromStr for PrivateKeySubmitInputEntropyType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "private-key" => Ok(Self::PrivateKey),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PrivateKeySubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PrivateKeySubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PrivateKeySubmitInputEntropyType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`RawSign`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "raw_sign",
    ///  "examples": [
    ///    {
    ///      "params": {
    ///        "hash":
    /// "0x0775aeed9c9ce6e0fbc4db25c5e4e6368029651c905c286f813126a09025a21e"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "params": {
    ///      "properties": {
    ///        "hash": {
    ///          "description": "The hash to sign. Must start with `0x`.",
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RawSign {
        pub params: RawSignParams,
    }

    impl ::std::convert::From<&RawSign> for RawSign {
        fn from(value: &RawSign) -> Self {
            value.clone()
        }
    }

    ///`RawSignParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "properties": {
    ///    "hash": {
    ///      "description": "The hash to sign. Must start with `0x`.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RawSignParams {
        ///The hash to sign. Must start with `0x`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hash: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RawSignParams> for RawSignParams {
        fn from(value: &RawSignParams) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for RawSignParams {
        fn default() -> Self {
            Self {
                hash: Default::default(),
            }
        }
    }

    ///`RawSignResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "hex"
    ///          ]
    ///        },
    ///        "signature": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RawSignResponse {
        pub data: RawSignResponseData,
    }

    impl ::std::convert::From<&RawSignResponse> for RawSignResponse {
        fn from(value: &RawSignResponse) -> Self {
            value.clone()
        }
    }

    ///`RawSignResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "hex"
    ///      ]
    ///    },
    ///    "signature": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RawSignResponseData {
        pub encoding: RawSignResponseDataEncoding,
        pub signature: ::std::string::String,
    }

    impl ::std::convert::From<&RawSignResponseData> for RawSignResponseData {
        fn from(value: &RawSignResponseData) -> Self {
            value.clone()
        }
    }

    ///`RawSignResponseDataEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "hex"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RawSignResponseDataEncoding {
        #[serde(rename = "hex")]
        Hex,
    }

    impl ::std::convert::From<&Self> for RawSignResponseDataEncoding {
        fn from(value: &RawSignResponseDataEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RawSignResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hex => f.write_str("hex"),
            }
        }
    }

    impl ::std::str::FromStr for RawSignResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "hex" => Ok(Self::Hex),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RawSignResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RawSignResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RawSignResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SearchUsersBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "search_term"
    ///      ],
    ///      "properties": {
    ///        "search_term": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "emails",
    ///        "phoneNumbers",
    ///        "walletAddresses"
    ///      ],
    ///      "properties": {
    ///        "emails": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string",
    ///            "format": "email"
    ///          }
    ///        },
    ///        "phoneNumbers": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "walletAddresses": {
    ///          "type": "array",
    ///          "items": {
    ///            "oneOf": [
    ///              {
    ///                "type": "string"
    ///              },
    ///              {
    ///                "type": "string"
    ///              }
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SearchUsersBody {
        Variant0 {
            search_term: ::std::string::String,
        },
        Variant1 {
            emails: ::std::vec::Vec<::std::string::String>,
            #[serde(rename = "phoneNumbers")]
            phone_numbers: ::std::vec::Vec<::std::string::String>,
            #[serde(rename = "walletAddresses")]
            wallet_addresses: ::std::vec::Vec<SearchUsersBodyVariant1WalletAddressesItem>,
        },
    }

    impl ::std::convert::From<&Self> for SearchUsersBody {
        fn from(value: &SearchUsersBody) -> Self {
            value.clone()
        }
    }

    ///`SearchUsersBodyVariant1WalletAddressesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string"
    ///    },
    ///    {
    ///      "type": "string"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SearchUsersBodyVariant1WalletAddressesItem {
        Variant0(::std::string::String),
        Variant1(::std::string::String),
    }

    impl ::std::convert::From<&Self> for SearchUsersBodyVariant1WalletAddressesItem {
        fn from(value: &SearchUsersBodyVariant1WalletAddressesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SearchUsersBodyVariant1WalletAddressesItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    ///`SendCodeToEmailRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SendCodeToEmailRequestBody",
    ///  "type": "object",
    ///  "required": [
    ///    "email"
    ///  ],
    ///  "properties": {
    ///    "email": {
    ///      "type": "string",
    ///      "format": "email"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SendCodeToEmailRequestBody {
        pub email: ::std::string::String,
    }

    impl ::std::convert::From<&SendCodeToEmailRequestBody> for SendCodeToEmailRequestBody {
        fn from(value: &SendCodeToEmailRequestBody) -> Self {
            value.clone()
        }
    }

    ///`SendCodeToEmailResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SendCodeToEmailResponseBody",
    ///  "type": "object",
    ///  "required": [
    ///    "success"
    ///  ],
    ///  "properties": {
    ///    "success": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SendCodeToEmailResponseBody {
        pub success: bool,
    }

    impl ::std::convert::From<&SendCodeToEmailResponseBody> for SendCodeToEmailResponseBody {
        fn from(value: &SendCodeToEmailResponseBody) -> Self {
            value.clone()
        }
    }

    ///`SmsMfaMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SMS",
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "sms"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmsMfaMethod {
        #[serde(rename = "type")]
        pub type_: SmsMfaMethodType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&SmsMfaMethod> for SmsMfaMethod {
        fn from(value: &SmsMfaMethod) -> Self {
            value.clone()
        }
    }

    ///`SmsMfaMethodType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "sms"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SmsMfaMethodType {
        #[serde(rename = "sms")]
        Sms,
    }

    impl ::std::convert::From<&Self> for SmsMfaMethodType {
        fn from(value: &SmsMfaMethodType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SmsMfaMethodType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sms => f.write_str("sms"),
            }
        }
    }

    impl ::std::str::FromStr for SmsMfaMethodType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sms" => Ok(Self::Sms),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SmsMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SmsMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SmsMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Solana Program attributes, enables allowlisting Solana Programs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "solana_program_instruction",
    ///  "description": "Solana Program attributes, enables allowlisting Solana
    /// Programs.",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "title": "SolanaProgramInstructionConditionField",
    ///      "type": "string",
    ///      "enum": [
    ///        "programId"
    ///      ]
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana_program_instruction"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaProgramInstructionCondition {
        pub field: SolanaProgramInstructionConditionField,
        pub field_source: SolanaProgramInstructionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&SolanaProgramInstructionCondition>
        for SolanaProgramInstructionCondition
    {
        fn from(value: &SolanaProgramInstructionCondition) -> Self {
            value.clone()
        }
    }

    ///`SolanaProgramInstructionConditionField`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolanaProgramInstructionConditionField",
    ///  "type": "string",
    ///  "enum": [
    ///    "programId"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaProgramInstructionConditionField {
        #[serde(rename = "programId")]
        ProgramId,
    }

    impl ::std::convert::From<&Self> for SolanaProgramInstructionConditionField {
        fn from(value: &SolanaProgramInstructionConditionField) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaProgramInstructionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ProgramId => f.write_str("programId"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaProgramInstructionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "programId" => Ok(Self::ProgramId),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaProgramInstructionConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana_program_instruction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaProgramInstructionConditionFieldSource {
        #[serde(rename = "solana_program_instruction")]
        SolanaProgramInstruction,
    }

    impl ::std::convert::From<&Self> for SolanaProgramInstructionConditionFieldSource {
        fn from(value: &SolanaProgramInstructionConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaProgramInstructionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolanaProgramInstruction => f.write_str("solana_program_instruction"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaProgramInstructionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana_program_instruction" => Ok(Self::SolanaProgramInstruction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaProgramInstructionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignAndSendTransactionRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "caip2",
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "caip2": {
    ///      "type": "string",
    ///      "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "signAndSendTransaction"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "transaction"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64"
    ///          ]
    ///        },
    ///        "transaction": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "sponsor": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignAndSendTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        pub caip2: SolanaSignAndSendTransactionRpcInputCaip2,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<SolanaSignAndSendTransactionRpcInputChainType>,
        pub method: SolanaSignAndSendTransactionRpcInputMethod,
        pub params: SolanaSignAndSendTransactionRpcInputParams,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsor: ::std::option::Option<bool>,
    }

    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcInput>
        for SolanaSignAndSendTransactionRpcInput
    {
        fn from(value: &SolanaSignAndSendTransactionRpcInput) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignAndSendTransactionRpcInputCaip2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaSignAndSendTransactionRpcInputCaip2(::std::string::String);
    impl ::std::ops::Deref for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SolanaSignAndSendTransactionRpcInputCaip2> for ::std::string::String {
        fn from(value: SolanaSignAndSendTransactionRpcInputCaip2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcInputCaip2>
        for SolanaSignAndSendTransactionRpcInputCaip2
    {
        fn from(value: &SolanaSignAndSendTransactionRpcInputCaip2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignAndSendTransactionRpcInputCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SolanaSignAndSendTransactionRpcInputCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`SolanaSignAndSendTransactionRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcInputChainType {
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcInputChainType {
        fn from(value: &SolanaSignAndSendTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcInputChainType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignAndSendTransactionRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "signAndSendTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcInputMethod {
        #[serde(rename = "signAndSendTransaction")]
        SignAndSendTransaction,
    }

    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcInputMethod {
        fn from(value: &SolanaSignAndSendTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignAndSendTransaction => f.write_str("signAndSendTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signAndSendTransaction" => Ok(Self::SignAndSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcInputMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignAndSendTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignAndSendTransactionRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "base64"
    ///      ]
    ///    },
    ///    "transaction": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignAndSendTransactionRpcInputParams {
        pub encoding: SolanaSignAndSendTransactionRpcInputParamsEncoding,
        pub transaction: ::std::string::String,
    }

    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcInputParams>
        for SolanaSignAndSendTransactionRpcInputParams
    {
        fn from(value: &SolanaSignAndSendTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignAndSendTransactionRpcInputParamsEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "base64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcInputParamsEncoding {
        #[serde(rename = "base64")]
        Base64,
    }

    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        fn from(value: &SolanaSignAndSendTransactionRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignAndSendTransactionRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "caip2",
    ///        "hash"
    ///      ],
    ///      "properties": {
    ///        "caip2": {
    ///          "type": "string",
    ///          "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///        },
    ///        "hash": {
    ///          "type": "string"
    ///        },
    ///        "transaction_id": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "signAndSendTransaction"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignAndSendTransactionRpcResponse {
        pub data: SolanaSignAndSendTransactionRpcResponseData,
        pub method: SolanaSignAndSendTransactionRpcResponseMethod,
    }

    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcResponse>
        for SolanaSignAndSendTransactionRpcResponse
    {
        fn from(value: &SolanaSignAndSendTransactionRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignAndSendTransactionRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "caip2",
    ///    "hash"
    ///  ],
    ///  "properties": {
    ///    "caip2": {
    ///      "type": "string",
    ///      "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///    },
    ///    "hash": {
    ///      "type": "string"
    ///    },
    ///    "transaction_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignAndSendTransactionRpcResponseData {
        pub caip2: SolanaSignAndSendTransactionRpcResponseDataCaip2,
        pub hash: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcResponseData>
        for SolanaSignAndSendTransactionRpcResponseData
    {
        fn from(value: &SolanaSignAndSendTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignAndSendTransactionRpcResponseDataCaip2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct SolanaSignAndSendTransactionRpcResponseDataCaip2(::std::string::String);
    impl ::std::ops::Deref for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SolanaSignAndSendTransactionRpcResponseDataCaip2>
        for ::std::string::String
    {
        fn from(value: SolanaSignAndSendTransactionRpcResponseDataCaip2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SolanaSignAndSendTransactionRpcResponseDataCaip2>
        for SolanaSignAndSendTransactionRpcResponseDataCaip2
    {
        fn from(value: &SolanaSignAndSendTransactionRpcResponseDataCaip2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err(
                    "doesn't match pattern \"^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseDataCaip2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SolanaSignAndSendTransactionRpcResponseDataCaip2 {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`SolanaSignAndSendTransactionRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "signAndSendTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignAndSendTransactionRpcResponseMethod {
        #[serde(rename = "signAndSendTransaction")]
        SignAndSendTransaction,
    }

    impl ::std::convert::From<&Self> for SolanaSignAndSendTransactionRpcResponseMethod {
        fn from(value: &SolanaSignAndSendTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignAndSendTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignAndSendTransaction => f.write_str("signAndSendTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignAndSendTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signAndSendTransaction" => Ok(Self::SignAndSendTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignAndSendTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignAndSendTransactionRpcResponseMethod
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignMessageRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "signMessage"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "message"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64"
    ///          ]
    ///        },
    ///        "message": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignMessageRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<SolanaSignMessageRpcInputChainType>,
        pub method: SolanaSignMessageRpcInputMethod,
        pub params: SolanaSignMessageRpcInputParams,
    }

    impl ::std::convert::From<&SolanaSignMessageRpcInput> for SolanaSignMessageRpcInput {
        fn from(value: &SolanaSignMessageRpcInput) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignMessageRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcInputChainType {
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for SolanaSignMessageRpcInputChainType {
        fn from(value: &SolanaSignMessageRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignMessageRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignMessageRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignMessageRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "signMessage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcInputMethod {
        #[serde(rename = "signMessage")]
        SignMessage,
    }

    impl ::std::convert::From<&Self> for SolanaSignMessageRpcInputMethod {
        fn from(value: &SolanaSignMessageRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignMessageRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignMessage => f.write_str("signMessage"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignMessageRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signMessage" => Ok(Self::SignMessage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignMessageRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "base64"
    ///      ]
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignMessageRpcInputParams {
        pub encoding: SolanaSignMessageRpcInputParamsEncoding,
        pub message: ::std::string::String,
    }

    impl ::std::convert::From<&SolanaSignMessageRpcInputParams> for SolanaSignMessageRpcInputParams {
        fn from(value: &SolanaSignMessageRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignMessageRpcInputParamsEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "base64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcInputParamsEncoding {
        #[serde(rename = "base64")]
        Base64,
    }

    impl ::std::convert::From<&Self> for SolanaSignMessageRpcInputParamsEncoding {
        fn from(value: &SolanaSignMessageRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignMessageRpcInputParamsEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignMessageRpcInputParamsEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignMessageRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "signature"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64"
    ///          ]
    ///        },
    ///        "signature": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "signMessage"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignMessageRpcResponse {
        pub data: SolanaSignMessageRpcResponseData,
        pub method: SolanaSignMessageRpcResponseMethod,
    }

    impl ::std::convert::From<&SolanaSignMessageRpcResponse> for SolanaSignMessageRpcResponse {
        fn from(value: &SolanaSignMessageRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignMessageRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "signature"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "base64"
    ///      ]
    ///    },
    ///    "signature": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignMessageRpcResponseData {
        pub encoding: SolanaSignMessageRpcResponseDataEncoding,
        pub signature: ::std::string::String,
    }

    impl ::std::convert::From<&SolanaSignMessageRpcResponseData> for SolanaSignMessageRpcResponseData {
        fn from(value: &SolanaSignMessageRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignMessageRpcResponseDataEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "base64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcResponseDataEncoding {
        #[serde(rename = "base64")]
        Base64,
    }

    impl ::std::convert::From<&Self> for SolanaSignMessageRpcResponseDataEncoding {
        fn from(value: &SolanaSignMessageRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignMessageRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignMessageRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignMessageRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "signMessage"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignMessageRpcResponseMethod {
        #[serde(rename = "signMessage")]
        SignMessage,
    }

    impl ::std::convert::From<&Self> for SolanaSignMessageRpcResponseMethod {
        fn from(value: &SolanaSignMessageRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignMessageRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignMessage => f.write_str("signMessage"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignMessageRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signMessage" => Ok(Self::SignMessage),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignMessageRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignMessageRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignMessageRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignTransactionRpcInput`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "params"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana"
    ///      ]
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "signTransaction"
    ///      ]
    ///    },
    ///    "params": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "transaction"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64"
    ///          ]
    ///        },
    ///        "transaction": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignTransactionRpcInput {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chain_type: ::std::option::Option<SolanaSignTransactionRpcInputChainType>,
        pub method: SolanaSignTransactionRpcInputMethod,
        pub params: SolanaSignTransactionRpcInputParams,
    }

    impl ::std::convert::From<&SolanaSignTransactionRpcInput> for SolanaSignTransactionRpcInput {
        fn from(value: &SolanaSignTransactionRpcInput) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignTransactionRpcInputChainType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcInputChainType {
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcInputChainType {
        fn from(value: &SolanaSignTransactionRpcInputChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignTransactionRpcInputChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignTransactionRpcInputChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignTransactionRpcInputChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignTransactionRpcInputMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "signTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcInputMethod {
        #[serde(rename = "signTransaction")]
        SignTransaction,
    }

    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcInputMethod {
        fn from(value: &SolanaSignTransactionRpcInputMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignTransactionRpcInputMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignTransaction => f.write_str("signTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignTransactionRpcInputMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signTransaction" => Ok(Self::SignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignTransactionRpcInputMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignTransactionRpcInputParams`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "transaction"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "base64"
    ///      ]
    ///    },
    ///    "transaction": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignTransactionRpcInputParams {
        pub encoding: SolanaSignTransactionRpcInputParamsEncoding,
        pub transaction: ::std::string::String,
    }

    impl ::std::convert::From<&SolanaSignTransactionRpcInputParams>
        for SolanaSignTransactionRpcInputParams
    {
        fn from(value: &SolanaSignTransactionRpcInputParams) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignTransactionRpcInputParamsEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "base64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcInputParamsEncoding {
        #[serde(rename = "base64")]
        Base64,
    }

    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcInputParamsEncoding {
        fn from(value: &SolanaSignTransactionRpcInputParamsEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignTransactionRpcInputParamsEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignTransactionRpcInputParamsEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcInputParamsEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignTransactionRpcInputParamsEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignTransactionRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "method"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "type": "object",
    ///      "required": [
    ///        "encoding",
    ///        "signed_transaction"
    ///      ],
    ///      "properties": {
    ///        "encoding": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64"
    ///          ]
    ///        },
    ///        "signed_transaction": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    "method": {
    ///      "type": "string",
    ///      "enum": [
    ///        "signTransaction"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignTransactionRpcResponse {
        pub data: SolanaSignTransactionRpcResponseData,
        pub method: SolanaSignTransactionRpcResponseMethod,
    }

    impl ::std::convert::From<&SolanaSignTransactionRpcResponse> for SolanaSignTransactionRpcResponse {
        fn from(value: &SolanaSignTransactionRpcResponse) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignTransactionRpcResponseData`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "encoding",
    ///    "signed_transaction"
    ///  ],
    ///  "properties": {
    ///    "encoding": {
    ///      "type": "string",
    ///      "enum": [
    ///        "base64"
    ///      ]
    ///    },
    ///    "signed_transaction": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSignTransactionRpcResponseData {
        pub encoding: SolanaSignTransactionRpcResponseDataEncoding,
        pub signed_transaction: ::std::string::String,
    }

    impl ::std::convert::From<&SolanaSignTransactionRpcResponseData>
        for SolanaSignTransactionRpcResponseData
    {
        fn from(value: &SolanaSignTransactionRpcResponseData) -> Self {
            value.clone()
        }
    }

    ///`SolanaSignTransactionRpcResponseDataEncoding`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "base64"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcResponseDataEncoding {
        #[serde(rename = "base64")]
        Base64,
    }

    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcResponseDataEncoding {
        fn from(value: &SolanaSignTransactionRpcResponseDataEncoding) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignTransactionRpcResponseDataEncoding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base64 => f.write_str("base64"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignTransactionRpcResponseDataEncoding {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base64" => Ok(Self::Base64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcResponseDataEncoding {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSignTransactionRpcResponseDataEncoding
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSignTransactionRpcResponseMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "signTransaction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSignTransactionRpcResponseMethod {
        #[serde(rename = "signTransaction")]
        SignTransaction,
    }

    impl ::std::convert::From<&Self> for SolanaSignTransactionRpcResponseMethod {
        fn from(value: &SolanaSignTransactionRpcResponseMethod) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSignTransactionRpcResponseMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SignTransaction => f.write_str("signTransaction"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSignTransactionRpcResponseMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "signTransaction" => Ok(Self::SignTransaction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SolanaSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SolanaSignTransactionRpcResponseMethod {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Solana System Program attributes, including more granular Transfer
    /// instruction fields.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "solana_system_program_instruction",
    ///  "description": "Solana System Program attributes, including more
    /// granular Transfer instruction fields.",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "title": "SolanaSystemProgramInstructionConditionField",
    ///      "type": "string",
    ///      "enum": [
    ///        "instructionName",
    ///        "Transfer.from",
    ///        "Transfer.to",
    ///        "Transfer.lamports"
    ///      ]
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana_system_program_instruction"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaSystemProgramInstructionCondition {
        pub field: SolanaSystemProgramInstructionConditionField,
        pub field_source: SolanaSystemProgramInstructionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&SolanaSystemProgramInstructionCondition>
        for SolanaSystemProgramInstructionCondition
    {
        fn from(value: &SolanaSystemProgramInstructionCondition) -> Self {
            value.clone()
        }
    }

    ///`SolanaSystemProgramInstructionConditionField`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolanaSystemProgramInstructionConditionField",
    ///  "type": "string",
    ///  "enum": [
    ///    "instructionName",
    ///    "Transfer.from",
    ///    "Transfer.to",
    ///    "Transfer.lamports"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSystemProgramInstructionConditionField {
        #[serde(rename = "instructionName")]
        InstructionName,
        #[serde(rename = "Transfer.from")]
        TransferFrom,
        #[serde(rename = "Transfer.to")]
        TransferTo,
        #[serde(rename = "Transfer.lamports")]
        TransferLamports,
    }

    impl ::std::convert::From<&Self> for SolanaSystemProgramInstructionConditionField {
        fn from(value: &SolanaSystemProgramInstructionConditionField) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSystemProgramInstructionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstructionName => f.write_str("instructionName"),
                Self::TransferFrom => f.write_str("Transfer.from"),
                Self::TransferTo => f.write_str("Transfer.to"),
                Self::TransferLamports => f.write_str("Transfer.lamports"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaSystemProgramInstructionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instructionName" => Ok(Self::InstructionName),
                "Transfer.from" => Ok(Self::TransferFrom),
                "Transfer.to" => Ok(Self::TransferTo),
                "Transfer.lamports" => Ok(Self::TransferLamports),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSystemProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSystemProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSystemProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaSystemProgramInstructionConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana_system_program_instruction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaSystemProgramInstructionConditionFieldSource {
        #[serde(rename = "solana_system_program_instruction")]
        SolanaSystemProgramInstruction,
    }

    impl ::std::convert::From<&Self> for SolanaSystemProgramInstructionConditionFieldSource {
        fn from(value: &SolanaSystemProgramInstructionConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaSystemProgramInstructionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolanaSystemProgramInstruction => {
                    f.write_str("solana_system_program_instruction")
                }
            }
        }
    }

    impl ::std::str::FromStr for SolanaSystemProgramInstructionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana_system_program_instruction" => Ok(Self::SolanaSystemProgramInstruction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaSystemProgramInstructionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaSystemProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaSystemProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Solana Token Program attributes, including more granular TransferChecked
    /// instruction fields.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "solana_token_program_instruction",
    ///  "description": "Solana Token Program attributes, including more
    /// granular TransferChecked instruction fields.",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "title": "SolanaTokenProgramInstructionConditionField",
    ///      "type": "string",
    ///      "enum": [
    ///        "instructionName",
    ///        "TransferChecked.source",
    ///        "TransferChecked.destination",
    ///        "TransferChecked.authority",
    ///        "TransferChecked.amount",
    ///        "TransferChecked.mint"
    ///      ]
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "solana_token_program_instruction"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SolanaTokenProgramInstructionCondition {
        pub field: SolanaTokenProgramInstructionConditionField,
        pub field_source: SolanaTokenProgramInstructionConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&SolanaTokenProgramInstructionCondition>
        for SolanaTokenProgramInstructionCondition
    {
        fn from(value: &SolanaTokenProgramInstructionCondition) -> Self {
            value.clone()
        }
    }

    ///`SolanaTokenProgramInstructionConditionField`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "SolanaTokenProgramInstructionConditionField",
    ///  "type": "string",
    ///  "enum": [
    ///    "instructionName",
    ///    "TransferChecked.source",
    ///    "TransferChecked.destination",
    ///    "TransferChecked.authority",
    ///    "TransferChecked.amount",
    ///    "TransferChecked.mint"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaTokenProgramInstructionConditionField {
        #[serde(rename = "instructionName")]
        InstructionName,
        #[serde(rename = "TransferChecked.source")]
        TransferCheckedSource,
        #[serde(rename = "TransferChecked.destination")]
        TransferCheckedDestination,
        #[serde(rename = "TransferChecked.authority")]
        TransferCheckedAuthority,
        #[serde(rename = "TransferChecked.amount")]
        TransferCheckedAmount,
        #[serde(rename = "TransferChecked.mint")]
        TransferCheckedMint,
    }

    impl ::std::convert::From<&Self> for SolanaTokenProgramInstructionConditionField {
        fn from(value: &SolanaTokenProgramInstructionConditionField) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaTokenProgramInstructionConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InstructionName => f.write_str("instructionName"),
                Self::TransferCheckedSource => f.write_str("TransferChecked.source"),
                Self::TransferCheckedDestination => f.write_str("TransferChecked.destination"),
                Self::TransferCheckedAuthority => f.write_str("TransferChecked.authority"),
                Self::TransferCheckedAmount => f.write_str("TransferChecked.amount"),
                Self::TransferCheckedMint => f.write_str("TransferChecked.mint"),
            }
        }
    }

    impl ::std::str::FromStr for SolanaTokenProgramInstructionConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instructionName" => Ok(Self::InstructionName),
                "TransferChecked.source" => Ok(Self::TransferCheckedSource),
                "TransferChecked.destination" => Ok(Self::TransferCheckedDestination),
                "TransferChecked.authority" => Ok(Self::TransferCheckedAuthority),
                "TransferChecked.amount" => Ok(Self::TransferCheckedAmount),
                "TransferChecked.mint" => Ok(Self::TransferCheckedMint),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaTokenProgramInstructionConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaTokenProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaTokenProgramInstructionConditionField
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SolanaTokenProgramInstructionConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "solana_token_program_instruction"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SolanaTokenProgramInstructionConditionFieldSource {
        #[serde(rename = "solana_token_program_instruction")]
        SolanaTokenProgramInstruction,
    }

    impl ::std::convert::From<&Self> for SolanaTokenProgramInstructionConditionFieldSource {
        fn from(value: &SolanaTokenProgramInstructionConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SolanaTokenProgramInstructionConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SolanaTokenProgramInstruction => {
                    f.write_str("solana_token_program_instruction")
                }
            }
        }
    }

    impl ::std::str::FromStr for SolanaTokenProgramInstructionConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana_token_program_instruction" => Ok(Self::SolanaTokenProgramInstruction),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SolanaTokenProgramInstructionConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for SolanaTokenProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for SolanaTokenProgramInstructionConditionFieldSource
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///System attributes, including current unix timestamp (in seconds).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "system",
    ///  "description": "System attributes, including current unix timestamp (in
    /// seconds).",
    ///  "type": "object",
    ///  "required": [
    ///    "field",
    ///    "field_source",
    ///    "operator",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "field": {
    ///      "type": "string",
    ///      "enum": [
    ///        "current_unix_timestamp"
    ///      ]
    ///    },
    ///    "field_source": {
    ///      "type": "string",
    ///      "enum": [
    ///        "system"
    ///      ]
    ///    },
    ///    "operator": {
    ///      "$ref": "#/components/schemas/ConditionOperator"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/ConditionValue"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SystemCondition {
        pub field: SystemConditionField,
        pub field_source: SystemConditionFieldSource,
        pub operator: ConditionOperator,
        pub value: ConditionValue,
    }

    impl ::std::convert::From<&SystemCondition> for SystemCondition {
        fn from(value: &SystemCondition) -> Self {
            value.clone()
        }
    }

    ///`SystemConditionField`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "current_unix_timestamp"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SystemConditionField {
        #[serde(rename = "current_unix_timestamp")]
        CurrentUnixTimestamp,
    }

    impl ::std::convert::From<&Self> for SystemConditionField {
        fn from(value: &SystemConditionField) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SystemConditionField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::CurrentUnixTimestamp => f.write_str("current_unix_timestamp"),
            }
        }
    }

    impl ::std::str::FromStr for SystemConditionField {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "current_unix_timestamp" => Ok(Self::CurrentUnixTimestamp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SystemConditionField {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SystemConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SystemConditionField {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`SystemConditionFieldSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "system"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SystemConditionFieldSource {
        #[serde(rename = "system")]
        System,
    }

    impl ::std::convert::From<&Self> for SystemConditionFieldSource {
        fn from(value: &SystemConditionFieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SystemConditionFieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::System => f.write_str("system"),
            }
        }
    }

    impl ::std::str::FromStr for SystemConditionFieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "system" => Ok(Self::System),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SystemConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SystemConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SystemConditionFieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`TotpMfaMethod`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "TOTP",
    ///  "type": "object",
    ///  "required": [
    ///    "type",
    ///    "verified_at"
    ///  ],
    ///  "properties": {
    ///    "type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "totp"
    ///      ]
    ///    },
    ///    "verified_at": {
    ///      "type": "number"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TotpMfaMethod {
        #[serde(rename = "type")]
        pub type_: TotpMfaMethodType,
        pub verified_at: f64,
    }

    impl ::std::convert::From<&TotpMfaMethod> for TotpMfaMethod {
        fn from(value: &TotpMfaMethod) -> Self {
            value.clone()
        }
    }

    ///`TotpMfaMethodType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "totp"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TotpMfaMethodType {
        #[serde(rename = "totp")]
        Totp,
    }

    impl ::std::convert::From<&Self> for TotpMfaMethodType {
        fn from(value: &TotpMfaMethodType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TotpMfaMethodType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Totp => f.write_str("totp"),
            }
        }
    }

    impl ::std::str::FromStr for TotpMfaMethodType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "totp" => Ok(Self::Totp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TotpMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TotpMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TotpMfaMethodType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`Transaction`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "caip2": "eip155:8453",
    ///      "created_at": 1631573050000,
    ///      "id": "cm7oxq1el000e11o8iwp7d0d0",
    ///      "status": "confirmed",
    ///      "transaction_hash":
    /// "0x2446f1fd773fbb9f080e674b60c6a033c7ed7427b8b9413cf28a2a4a6da9b56c",
    ///      "wallet_id": "fmfdj6yqly31huorjqzq38zc"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "caip2",
    ///    "created_at",
    ///    "id",
    ///    "status",
    ///    "transaction_hash",
    ///    "wallet_id"
    ///  ],
    ///  "properties": {
    ///    "caip2": {
    ///      "type": "string"
    ///    },
    ///    "created_at": {
    ///      "type": "number"
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "sponsored": {
    ///      "type": "boolean"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "broadcasted",
    ///        "confirmed",
    ///        "execution_reverted",
    ///        "failed",
    ///        "replaced",
    ///        "finalized"
    ///      ]
    ///    },
    ///    "transaction_hash": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "wallet_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Transaction {
        pub caip2: ::std::string::String,
        pub created_at: f64,
        pub id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsored: ::std::option::Option<bool>,
        pub status: TransactionStatus,
        pub transaction_hash: ::std::option::Option<::std::string::String>,
        pub wallet_id: ::std::string::String,
    }

    impl ::std::convert::From<&Transaction> for Transaction {
        fn from(value: &Transaction) -> Self {
            value.clone()
        }
    }

    ///`TransactionStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "broadcasted",
    ///    "confirmed",
    ///    "execution_reverted",
    ///    "failed",
    ///    "replaced",
    ///    "finalized"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TransactionStatus {
        #[serde(rename = "broadcasted")]
        Broadcasted,
        #[serde(rename = "confirmed")]
        Confirmed,
        #[serde(rename = "execution_reverted")]
        ExecutionReverted,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "replaced")]
        Replaced,
        #[serde(rename = "finalized")]
        Finalized,
    }

    impl ::std::convert::From<&Self> for TransactionStatus {
        fn from(value: &TransactionStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TransactionStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Broadcasted => f.write_str("broadcasted"),
                Self::Confirmed => f.write_str("confirmed"),
                Self::ExecutionReverted => f.write_str("execution_reverted"),
                Self::Failed => f.write_str("failed"),
                Self::Replaced => f.write_str("replaced"),
                Self::Finalized => f.write_str("finalized"),
            }
        }
    }

    impl ::std::str::FromStr for TransactionStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "broadcasted" => Ok(Self::Broadcasted),
                "confirmed" => Ok(Self::Confirmed),
                "execution_reverted" => Ok(Self::ExecutionReverted),
                "failed" => Ok(Self::Failed),
                "replaced" => Ok(Self::Replaced),
                "finalized" => Ok(Self::Finalized),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TransactionStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UnlinkEmailRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "UnlinkEmailRequestBody",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UnlinkEmailRequestBody {
        pub address: ::std::string::String,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&UnlinkEmailRequestBody> for UnlinkEmailRequestBody {
        fn from(value: &UnlinkEmailRequestBody) -> Self {
            value.clone()
        }
    }

    ///`UnlinkUserLinkedAccountBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "handle",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "handle": {
    ///      "type": "string"
    ///    },
    ///    "provider": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "oneOf": [
    ///        {
    ///          "type": "string",
    ///          "enum": [
    ///            "email",
    ///            "wallet",
    ///            "smart_wallet",
    ///            "farcaster",
    ///            "passkey",
    ///            "phone",
    ///            "google_oauth",
    ///            "discord_oauth",
    ///            "twitter_oauth",
    ///            "github_oauth",
    ///            "linkedin_oauth",
    ///            "apple_oauth",
    ///            "spotify_oauth",
    ///            "instagram_oauth",
    ///            "tiktok_oauth",
    ///            "line_oauth",
    ///            "custom_auth",
    ///            "telegram",
    ///            "cross_app",
    ///            "guest"
    ///          ]
    ///        },
    ///        {
    ///          "type": "string"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UnlinkUserLinkedAccountBody {
        pub handle: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub provider: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: UnlinkUserLinkedAccountBodyType,
    }

    impl ::std::convert::From<&UnlinkUserLinkedAccountBody> for UnlinkUserLinkedAccountBody {
        fn from(value: &UnlinkUserLinkedAccountBody) -> Self {
            value.clone()
        }
    }

    ///`UnlinkUserLinkedAccountBodyType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "email",
    ///        "wallet",
    ///        "smart_wallet",
    ///        "farcaster",
    ///        "passkey",
    ///        "phone",
    ///        "google_oauth",
    ///        "discord_oauth",
    ///        "twitter_oauth",
    ///        "github_oauth",
    ///        "linkedin_oauth",
    ///        "apple_oauth",
    ///        "spotify_oauth",
    ///        "instagram_oauth",
    ///        "tiktok_oauth",
    ///        "line_oauth",
    ///        "custom_auth",
    ///        "telegram",
    ///        "cross_app",
    ///        "guest"
    ///      ]
    ///    },
    ///    {
    ///      "type": "string"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UnlinkUserLinkedAccountBodyType {
        Variant0(UnlinkUserLinkedAccountBodyTypeVariant0),
        Variant1(::std::string::String),
    }

    impl ::std::convert::From<&Self> for UnlinkUserLinkedAccountBodyType {
        fn from(value: &UnlinkUserLinkedAccountBodyType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UnlinkUserLinkedAccountBodyType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Variant0(x) => x.fmt(f),
                Self::Variant1(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<UnlinkUserLinkedAccountBodyTypeVariant0>
        for UnlinkUserLinkedAccountBodyType
    {
        fn from(value: UnlinkUserLinkedAccountBodyTypeVariant0) -> Self {
            Self::Variant0(value)
        }
    }

    ///`UnlinkUserLinkedAccountBodyTypeVariant0`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "email",
    ///    "wallet",
    ///    "smart_wallet",
    ///    "farcaster",
    ///    "passkey",
    ///    "phone",
    ///    "google_oauth",
    ///    "discord_oauth",
    ///    "twitter_oauth",
    ///    "github_oauth",
    ///    "linkedin_oauth",
    ///    "apple_oauth",
    ///    "spotify_oauth",
    ///    "instagram_oauth",
    ///    "tiktok_oauth",
    ///    "line_oauth",
    ///    "custom_auth",
    ///    "telegram",
    ///    "cross_app",
    ///    "guest"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UnlinkUserLinkedAccountBodyTypeVariant0 {
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "wallet")]
        Wallet,
        #[serde(rename = "smart_wallet")]
        SmartWallet,
        #[serde(rename = "farcaster")]
        Farcaster,
        #[serde(rename = "passkey")]
        Passkey,
        #[serde(rename = "phone")]
        Phone,
        #[serde(rename = "google_oauth")]
        GoogleOauth,
        #[serde(rename = "discord_oauth")]
        DiscordOauth,
        #[serde(rename = "twitter_oauth")]
        TwitterOauth,
        #[serde(rename = "github_oauth")]
        GithubOauth,
        #[serde(rename = "linkedin_oauth")]
        LinkedinOauth,
        #[serde(rename = "apple_oauth")]
        AppleOauth,
        #[serde(rename = "spotify_oauth")]
        SpotifyOauth,
        #[serde(rename = "instagram_oauth")]
        InstagramOauth,
        #[serde(rename = "tiktok_oauth")]
        TiktokOauth,
        #[serde(rename = "line_oauth")]
        LineOauth,
        #[serde(rename = "custom_auth")]
        CustomAuth,
        #[serde(rename = "telegram")]
        Telegram,
        #[serde(rename = "cross_app")]
        CrossApp,
        #[serde(rename = "guest")]
        Guest,
    }

    impl ::std::convert::From<&Self> for UnlinkUserLinkedAccountBodyTypeVariant0 {
        fn from(value: &UnlinkUserLinkedAccountBodyTypeVariant0) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UnlinkUserLinkedAccountBodyTypeVariant0 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Email => f.write_str("email"),
                Self::Wallet => f.write_str("wallet"),
                Self::SmartWallet => f.write_str("smart_wallet"),
                Self::Farcaster => f.write_str("farcaster"),
                Self::Passkey => f.write_str("passkey"),
                Self::Phone => f.write_str("phone"),
                Self::GoogleOauth => f.write_str("google_oauth"),
                Self::DiscordOauth => f.write_str("discord_oauth"),
                Self::TwitterOauth => f.write_str("twitter_oauth"),
                Self::GithubOauth => f.write_str("github_oauth"),
                Self::LinkedinOauth => f.write_str("linkedin_oauth"),
                Self::AppleOauth => f.write_str("apple_oauth"),
                Self::SpotifyOauth => f.write_str("spotify_oauth"),
                Self::InstagramOauth => f.write_str("instagram_oauth"),
                Self::TiktokOauth => f.write_str("tiktok_oauth"),
                Self::LineOauth => f.write_str("line_oauth"),
                Self::CustomAuth => f.write_str("custom_auth"),
                Self::Telegram => f.write_str("telegram"),
                Self::CrossApp => f.write_str("cross_app"),
                Self::Guest => f.write_str("guest"),
            }
        }
    }

    impl ::std::str::FromStr for UnlinkUserLinkedAccountBodyTypeVariant0 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "email" => Ok(Self::Email),
                "wallet" => Ok(Self::Wallet),
                "smart_wallet" => Ok(Self::SmartWallet),
                "farcaster" => Ok(Self::Farcaster),
                "passkey" => Ok(Self::Passkey),
                "phone" => Ok(Self::Phone),
                "google_oauth" => Ok(Self::GoogleOauth),
                "discord_oauth" => Ok(Self::DiscordOauth),
                "twitter_oauth" => Ok(Self::TwitterOauth),
                "github_oauth" => Ok(Self::GithubOauth),
                "linkedin_oauth" => Ok(Self::LinkedinOauth),
                "apple_oauth" => Ok(Self::AppleOauth),
                "spotify_oauth" => Ok(Self::SpotifyOauth),
                "instagram_oauth" => Ok(Self::InstagramOauth),
                "tiktok_oauth" => Ok(Self::TiktokOauth),
                "line_oauth" => Ok(Self::LineOauth),
                "custom_auth" => Ok(Self::CustomAuth),
                "telegram" => Ok(Self::Telegram),
                "cross_app" => Ok(Self::CrossApp),
                "guest" => Ok(Self::Guest),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UnlinkUserLinkedAccountBodyTypeVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UnlinkUserLinkedAccountBodyTypeVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UnlinkUserLinkedAccountBodyTypeVariant0 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateEmailRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "UpdateEmailRequestBody",
    ///  "type": "object",
    ///  "required": [
    ///    "code",
    ///    "newAddress",
    ///    "oldAddress",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "code": {
    ///      "type": "string",
    ///      "maxLength": 6,
    ///      "minLength": 6
    ///    },
    ///    "newAddress": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "oldAddress": {
    ///      "type": "string",
    ///      "format": "email"
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateEmailRequestBody {
        pub code: UpdateEmailRequestBodyCode,
        #[serde(rename = "newAddress")]
        pub new_address: ::std::string::String,
        #[serde(rename = "oldAddress")]
        pub old_address: ::std::string::String,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&UpdateEmailRequestBody> for UpdateEmailRequestBody {
        fn from(value: &UpdateEmailRequestBody) -> Self {
            value.clone()
        }
    }

    ///`UpdateEmailRequestBodyCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 6,
    ///  "minLength": 6
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateEmailRequestBodyCode(::std::string::String);
    impl ::std::ops::Deref for UpdateEmailRequestBodyCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateEmailRequestBodyCode> for ::std::string::String {
        fn from(value: UpdateEmailRequestBodyCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateEmailRequestBodyCode> for UpdateEmailRequestBodyCode {
        fn from(value: &UpdateEmailRequestBodyCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateEmailRequestBodyCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 6usize {
                return Err("longer than 6 characters".into());
            }
            if value.chars().count() < 6usize {
                return Err("shorter than 6 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateEmailRequestBodyCode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateEmailRequestBodyCode {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateKeyQuorumBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "authorization_threshold": 1,
    ///      "display_name": "Prod key quorum",
    ///      "public_keys": [
    ///        "-----BEGIN PUBLIC
    /// KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEx4aoeD72yykviK+f/
    /// ckqE2CItVIG\n1rCnvC3/XZ1HgpOcMEMialRmTrqIK4oZlYd1RfxU3za/
    /// C9yjhboIuoPD3g==\n-----END PUBLIC KEY-----"
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "authorization_threshold": {
    ///      "type": "number",
    ///      "minimum": 1.0
    ///    },
    ///    "display_name": {
    ///      "type": "string",
    ///      "maxLength": 50
    ///    },
    ///    "public_keys": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "user_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateKeyQuorumBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub authorization_threshold: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub display_name: ::std::option::Option<UpdateKeyQuorumBodyDisplayName>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub public_keys: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub user_ids: ::std::vec::Vec<::std::string::String>,
    }

    impl ::std::convert::From<&UpdateKeyQuorumBody> for UpdateKeyQuorumBody {
        fn from(value: &UpdateKeyQuorumBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateKeyQuorumBody {
        fn default() -> Self {
            Self {
                authorization_threshold: Default::default(),
                display_name: Default::default(),
                public_keys: Default::default(),
                user_ids: Default::default(),
            }
        }
    }

    ///`UpdateKeyQuorumBodyDisplayName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateKeyQuorumBodyDisplayName(::std::string::String);
    impl ::std::ops::Deref for UpdateKeyQuorumBodyDisplayName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateKeyQuorumBodyDisplayName> for ::std::string::String {
        fn from(value: UpdateKeyQuorumBodyDisplayName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateKeyQuorumBodyDisplayName> for UpdateKeyQuorumBodyDisplayName {
        fn from(value: &UpdateKeyQuorumBodyDisplayName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateKeyQuorumBodyDisplayName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateKeyQuorumBodyDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateKeyQuorumBodyDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateKeyQuorumBodyDisplayName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateKeyQuorumBodyDisplayName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdatePolicyBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "name": {
    ///      "description": "Name to assign to policy.",
    ///      "type": "string",
    ///      "maxLength": 50,
    ///      "minLength": 1
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/OwnerInput"
    ///    },
    ///    "owner_id": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/OwnerIdInput"
    ///        },
    ///        {}
    ///      ]
    ///    },
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PolicyRuleRequestBody"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdatePolicyBody {
        ///Name to assign to policy.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<UpdatePolicyBodyName>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<OwnerInput>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<OwnerIdInput>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub rules: ::std::vec::Vec<PolicyRuleRequestBody>,
    }

    impl ::std::convert::From<&UpdatePolicyBody> for UpdatePolicyBody {
        fn from(value: &UpdatePolicyBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdatePolicyBody {
        fn default() -> Self {
            Self {
                name: Default::default(),
                owner: Default::default(),
                owner_id: Default::default(),
                rules: Default::default(),
            }
        }
    }

    ///Name to assign to policy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Name to assign to policy.",
    ///  "type": "string",
    ///  "maxLength": 50,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyBodyName(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyBodyName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePolicyBodyName> for ::std::string::String {
        fn from(value: UpdatePolicyBodyName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePolicyBodyName> for UpdatePolicyBodyName {
        fn from(value: &UpdatePolicyBodyName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePolicyBodyName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePolicyBodyName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyBodyName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyBodyName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdatePolicyPolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyPolicyId(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyPolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePolicyPolicyId> for ::std::string::String {
        fn from(value: UpdatePolicyPolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePolicyPolicyId> for UpdatePolicyPolicyId {
        fn from(value: &UpdatePolicyPolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePolicyPolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyPolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyPolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdatePolicyRulePolicyId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyRulePolicyId(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyRulePolicyId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePolicyRulePolicyId> for ::std::string::String {
        fn from(value: UpdatePolicyRulePolicyId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePolicyRulePolicyId> for UpdatePolicyRulePolicyId {
        fn from(value: &UpdatePolicyRulePolicyId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePolicyRulePolicyId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyRulePolicyId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyRulePolicyId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdatePolicyRuleResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PolicyRuleResponse"
    ///    },
    ///    {
    ///      "examples": [
    ///        {
    ///          "action": "ALLOW",
    ///          "conditions": [
    ///            {
    ///              "field": "to",
    ///              "field_source": "ethereum_transaction",
    ///              "operator": "eq",
    ///              "value": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
    ///            }
    ///          ],
    ///          "id": "allowlist-usdc-contract-on-base-14351345",
    ///          "method": "eth_sendTransaction",
    ///          "name": "Allowlist USDC contract on Base"
    ///        }
    ///      ]
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdatePolicyRuleResponse {
        pub action: PolicyAction,
        pub conditions: ::std::vec::Vec<PolicyCondition>,
        pub id: ::std::string::String,
        pub method: PolicyMethod,
        pub name: UpdatePolicyRuleResponseName,
    }

    impl ::std::convert::From<&UpdatePolicyRuleResponse> for UpdatePolicyRuleResponse {
        fn from(value: &UpdatePolicyRuleResponse) -> Self {
            value.clone()
        }
    }

    ///`UpdatePolicyRuleResponseName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 50
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyRuleResponseName(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyRuleResponseName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePolicyRuleResponseName> for ::std::string::String {
        fn from(value: UpdatePolicyRuleResponseName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePolicyRuleResponseName> for UpdatePolicyRuleResponseName {
        fn from(value: &UpdatePolicyRuleResponseName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePolicyRuleResponseName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 50usize {
                return Err("longer than 50 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePolicyRuleResponseName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyRuleResponseName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyRuleResponseName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyRuleResponseName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdatePolicyRuleRuleId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdatePolicyRuleRuleId(::std::string::String);
    impl ::std::ops::Deref for UpdatePolicyRuleRuleId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdatePolicyRuleRuleId> for ::std::string::String {
        fn from(value: UpdatePolicyRuleRuleId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdatePolicyRuleRuleId> for UpdatePolicyRuleRuleId {
        fn from(value: &UpdatePolicyRuleRuleId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdatePolicyRuleRuleId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdatePolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdatePolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdatePolicyRuleRuleId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdatePolicyRuleRuleId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserCustomMetadataBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "custom_metadata": {
    ///        "key": "value"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "custom_metadata"
    ///  ],
    ///  "properties": {
    ///    "custom_metadata": {
    ///      "$ref": "#/components/schemas/CustomMetadata"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserCustomMetadataBody {
        pub custom_metadata: CustomMetadata,
    }

    impl ::std::convert::From<&UpdateUserCustomMetadataBody> for UpdateUserCustomMetadataBody {
        fn from(value: &UpdateUserCustomMetadataBody) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "data": {
    ///        "birth_date": "1989-09-09",
    ///        "email": "john@doe.com",
    ///        "first_name": "John",
    ///        "identifying_information": [
    ///          {
    ///            "image_back": "data:image/jpeg;base64,/9j/4AAQSkZJRg...",
    ///            "image_front": "data:image/jpeg;base64,/9j/4AAQSkZJRg...",
    ///            "issuing_country": "USA",
    ///            "number": "111-11-1111",
    ///            "type": "ssn"
    ///          }
    ///        ],
    ///        "last_name": "Doe",
    ///        "phone": "+59898222122",
    ///        "residential_address": {
    ///          "city": "San Francisco",
    ///          "country": "USA",
    ///          "postal_code": "94109",
    ///          "street_line_1": "1234 Lombard Street",
    ///          "street_line_2": "Apt 2F",
    ///          "subdivision": "CA"
    ///        },
    ///        "signed_agreement_id": "123",
    ///        "type": "individual"
    ///      },
    ///      "provider": "bridge-sandbox"
    ///    }
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "provider"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "object",
    ///          "required": [
    ///            "birth_date",
    ///            "email",
    ///            "first_name",
    ///            "identifying_information",
    ///            "last_name",
    ///            "residential_address",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "account_purpose": {
    ///              "type": "string"
    ///            },
    ///            "account_purpose_other": {
    ///              "type": "string"
    ///            },
    ///            "acting_as_intermediary": {
    ///              "type": "string"
    ///            },
    ///            "birth_date": {
    ///              "type": "string",
    ///              "maxLength": 10,
    ///              "minLength": 10
    ///            },
    ///            "completed_customer_safety_check_at": {
    ///              "type": "string"
    ///            },
    ///            "documents": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "file",
    ///                  "purposes"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "file": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "purposes": {
    ///                    "type": "array",
    ///                    "items": {
    ///                      "type": "string",
    ///                      "minLength": 1
    ///                    },
    ///                    "minItems": 1
    ///                  }
    ///                }
    ///              }
    ///            },
    ///            "email": {
    ///              "type": "string",
    ///              "format": "email",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "employment_status": {
    ///              "type": "string"
    ///            },
    ///            "endorsements": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "string"
    ///              }
    ///            },
    ///            "expected_monthly_payments_usd": {
    ///              "type": "string"
    ///            },
    ///            "first_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "has_signed_terms_of_service": {
    ///              "type": "boolean"
    ///            },
    ///            "identifying_information": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "issuing_country",
    ///                  "type"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string"
    ///                  },
    ///                  "expiration": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_back": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_front": {
    ///                    "type": "string"
    ///                  },
    ///                  "issuing_country": {
    ///                    "type": "string",
    ///                    "maxLength": 3,
    ///                    "minLength": 3
    ///                  },
    ///                  "number": {
    ///                    "type": "string"
    ///                  },
    ///                  "type": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "minItems": 1
    ///            },
    ///            "kyc_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "last_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "middle_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "most_recent_occupation": {
    ///              "type": "string"
    ///            },
    ///            "nationality": {
    ///              "type": "string",
    ///              "maxLength": 3,
    ///              "minLength": 3
    ///            },
    ///            "ofac_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "phone": {
    ///              "type": "string",
    ///              "maxLength": 18,
    ///              "minLength": 2
    ///            },
    ///            "residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "signed_agreement_id": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "source_of_funds": {
    ///              "type": "string"
    ///            },
    ///            "transliterated_first_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_last_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_middle_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "individual"
    ///              ]
    ///            },
    ///            "verified_selfie_at": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "provider": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bridge"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "provider"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "object",
    ///          "required": [
    ///            "birth_date",
    ///            "email",
    ///            "first_name",
    ///            "identifying_information",
    ///            "last_name",
    ///            "residential_address",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "account_purpose": {
    ///              "type": "string"
    ///            },
    ///            "account_purpose_other": {
    ///              "type": "string"
    ///            },
    ///            "acting_as_intermediary": {
    ///              "type": "string"
    ///            },
    ///            "birth_date": {
    ///              "type": "string",
    ///              "maxLength": 10,
    ///              "minLength": 10
    ///            },
    ///            "completed_customer_safety_check_at": {
    ///              "type": "string"
    ///            },
    ///            "documents": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "file",
    ///                  "purposes"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "file": {
    ///                    "type": "string",
    ///                    "minLength": 1
    ///                  },
    ///                  "purposes": {
    ///                    "type": "array",
    ///                    "items": {
    ///                      "type": "string",
    ///                      "minLength": 1
    ///                    },
    ///                    "minItems": 1
    ///                  }
    ///                }
    ///              }
    ///            },
    ///            "email": {
    ///              "type": "string",
    ///              "format": "email",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "employment_status": {
    ///              "type": "string"
    ///            },
    ///            "endorsements": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "string"
    ///              }
    ///            },
    ///            "expected_monthly_payments_usd": {
    ///              "type": "string"
    ///            },
    ///            "first_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "has_signed_terms_of_service": {
    ///              "type": "boolean"
    ///            },
    ///            "identifying_information": {
    ///              "type": "array",
    ///              "items": {
    ///                "type": "object",
    ///                "required": [
    ///                  "issuing_country",
    ///                  "type"
    ///                ],
    ///                "properties": {
    ///                  "description": {
    ///                    "type": "string"
    ///                  },
    ///                  "expiration": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_back": {
    ///                    "type": "string"
    ///                  },
    ///                  "image_front": {
    ///                    "type": "string"
    ///                  },
    ///                  "issuing_country": {
    ///                    "type": "string",
    ///                    "maxLength": 3,
    ///                    "minLength": 3
    ///                  },
    ///                  "number": {
    ///                    "type": "string"
    ///                  },
    ///                  "type": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "minItems": 1
    ///            },
    ///            "kyc_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "last_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "middle_name": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "most_recent_occupation": {
    ///              "type": "string"
    ///            },
    ///            "nationality": {
    ///              "type": "string",
    ///              "maxLength": 3,
    ///              "minLength": 3
    ///            },
    ///            "ofac_screen": {
    ///              "type": "object",
    ///              "required": [
    ///                "result",
    ///                "screened_at"
    ///              ],
    ///              "properties": {
    ///                "result": {
    ///                  "type": "string",
    ///                  "enum": [
    ///                    "passed"
    ///                  ]
    ///                },
    ///                "screened_at": {
    ///                  "type": "string",
    ///                  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///                }
    ///              }
    ///            },
    ///            "phone": {
    ///              "type": "string",
    ///              "maxLength": 18,
    ///              "minLength": 2
    ///            },
    ///            "residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "signed_agreement_id": {
    ///              "type": "string",
    ///              "maxLength": 1024,
    ///              "minLength": 1
    ///            },
    ///            "source_of_funds": {
    ///              "type": "string"
    ///            },
    ///            "transliterated_first_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_last_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_middle_name": {
    ///              "type": "string",
    ///              "maxLength": 256,
    ///              "minLength": 1
    ///            },
    ///            "transliterated_residential_address": {
    ///              "type": "object",
    ///              "required": [
    ///                "city",
    ///                "country",
    ///                "street_line_1",
    ///                "subdivision"
    ///              ],
    ///              "properties": {
    ///                "city": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "country": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 3
    ///                },
    ///                "postal_code": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_1": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "street_line_2": {
    ///                  "type": "string",
    ///                  "minLength": 1
    ///                },
    ///                "subdivision": {
    ///                  "type": "string",
    ///                  "maxLength": 3,
    ///                  "minLength": 1
    ///                }
    ///              }
    ///            },
    ///            "type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "individual"
    ///              ]
    ///            },
    ///            "verified_selfie_at": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "provider": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bridge-sandbox"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "provider", content = "data")]
    pub enum UpdateUserFiatKycStatusBody {
        #[serde(rename = "bridge")]
        Bridge {
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose_other: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            acting_as_intermediary: ::std::option::Option<::std::string::String>,
            birth_date: UpdateUserFiatKycStatusBodyBridgeBirthDate,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            completed_customer_safety_check_at: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            documents: ::std::vec::Vec<UpdateUserFiatKycStatusBodyBridgeDocumentsItem>,
            email: ::std::string::String,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            employment_status: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            endorsements: ::std::vec::Vec<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            expected_monthly_payments_usd: ::std::option::Option<::std::string::String>,
            first_name: UpdateUserFiatKycStatusBodyBridgeFirstName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            has_signed_terms_of_service: ::std::option::Option<bool>,
            identifying_information:
                ::std::vec::Vec<UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItem>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            kyc_screen: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeKycScreen>,
            last_name: UpdateUserFiatKycStatusBodyBridgeLastName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            middle_name: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeMiddleName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            most_recent_occupation: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            nationality: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeNationality>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            ofac_screen: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeOfacScreen>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            phone: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgePhone>,
            residential_address: UpdateUserFiatKycStatusBodyBridgeResidentialAddress,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            signed_agreement_id:
                ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSignedAgreementId>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            source_of_funds: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_first_name:
                ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_last_name:
                ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_middle_name:
                ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_residential_address: ::std::option::Option<
                UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddress,
            >,
            #[serde(rename = "type")]
            type_: UpdateUserFiatKycStatusBodyBridgeType,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            verified_selfie_at: ::std::option::Option<::std::string::String>,
        },
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox {
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            account_purpose_other: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            acting_as_intermediary: ::std::option::Option<::std::string::String>,
            birth_date: UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            completed_customer_safety_check_at: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            documents: ::std::vec::Vec<UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItem>,
            email: ::std::string::String,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            employment_status: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
            endorsements: ::std::vec::Vec<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            expected_monthly_payments_usd: ::std::option::Option<::std::string::String>,
            first_name: UpdateUserFiatKycStatusBodyBridgeSandboxFirstName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            has_signed_terms_of_service: ::std::option::Option<bool>,
            identifying_information:
                ::std::vec::Vec<UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItem>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            kyc_screen: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSandboxKycScreen>,
            last_name: UpdateUserFiatKycStatusBodyBridgeSandboxLastName,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            middle_name: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            most_recent_occupation: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            nationality: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSandboxNationality>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            ofac_screen: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreen>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            phone: ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSandboxPhone>,
            residential_address: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddress,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            signed_agreement_id:
                ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            source_of_funds: ::std::option::Option<::std::string::String>,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_first_name: ::std::option::Option<
                UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName,
            >,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_last_name: ::std::option::Option<
                UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName,
            >,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_middle_name: ::std::option::Option<
                UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName,
            >,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            transliterated_residential_address: ::std::option::Option<
                UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddress,
            >,
            #[serde(rename = "type")]
            type_: UpdateUserFiatKycStatusBodyBridgeSandboxType,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            verified_selfie_at: ::std::option::Option<::std::string::String>,
        },
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusBody {
        fn from(value: &UpdateUserFiatKycStatusBody) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeBirthDate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 10,
    ///  "minLength": 10
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeBirthDate(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeBirthDate {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeBirthDate> for ::std::string::String {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeBirthDate) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeBirthDate>
        for UpdateUserFiatKycStatusBodyBridgeBirthDate
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeBirthDate) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeBirthDate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 10usize {
                return Err("longer than 10 characters".into());
            }
            if value.chars().count() < 10usize {
                return Err("shorter than 10 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeBirthDate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeBirthDate
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateUserFiatKycStatusBodyBridgeBirthDate {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeBirthDate {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeDocumentsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "file",
    ///    "purposes"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "file": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "purposes": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "minLength": 1
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeDocumentsItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description:
            ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription>,
        pub file: UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile,
        pub purposes: ::std::vec::Vec<UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem>,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeDocumentsItem>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItem
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeDocumentsItem) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeDocumentsItemDescription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeDocumentsItemFile {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeDocumentsItemPurposesItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeFirstName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeFirstName> for ::std::string::String {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeFirstName>
        for UpdateUserFiatKycStatusBodyBridgeFirstName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateUserFiatKycStatusBodyBridgeFirstName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "issuing_country",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "expiration": {
    ///      "type": "string"
    ///    },
    ///    "image_back": {
    ///      "type": "string"
    ///    },
    ///    "image_front": {
    ///      "type": "string"
    ///    },
    ///    "issuing_country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "number": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expiration: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_back: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_front: ::std::option::Option<::std::string::String>,
        pub issuing_country:
            UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub number: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItem>
        for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItem
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItem) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry,
        > for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeIdentifyingInformationItemIssuingCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeKycScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeKycScreen {
        pub result: UpdateUserFiatKycStatusBodyBridgeKycScreenResult,
        pub screened_at: UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeKycScreen>
        for UpdateUserFiatKycStatusBodyBridgeKycScreen
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeKycScreen) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeKycScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateUserFiatKycStatusBodyBridgeKycScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusBodyBridgeKycScreenResult {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeKycScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateUserFiatKycStatusBodyBridgeKycScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeKycScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeKycScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt>
        for UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeKycScreenScreenedAt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeLastName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeLastName> for ::std::string::String {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeLastName>
        for UpdateUserFiatKycStatusBodyBridgeLastName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateUserFiatKycStatusBodyBridgeLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateUserFiatKycStatusBodyBridgeLastName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeMiddleName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeMiddleName> for ::std::string::String {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeMiddleName>
        for UpdateUserFiatKycStatusBodyBridgeMiddleName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeMiddleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeNationality`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeNationality(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeNationality {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeNationality> for ::std::string::String {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeNationality) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeNationality>
        for UpdateUserFiatKycStatusBodyBridgeNationality
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeNationality) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeNationality {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeNationality {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeNationality
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeNationality
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeNationality {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeOfacScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeOfacScreen {
        pub result: UpdateUserFiatKycStatusBodyBridgeOfacScreenResult,
        pub screened_at: UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeOfacScreen>
        for UpdateUserFiatKycStatusBodyBridgeOfacScreen
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeOfacScreen) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeOfacScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateUserFiatKycStatusBodyBridgeOfacScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusBodyBridgeOfacScreenResult {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeOfacScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateUserFiatKycStatusBodyBridgeOfacScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeOfacScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeOfacScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt>
        for UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeOfacScreenScreenedAt {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgePhone`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 18,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgePhone(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgePhone {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgePhone> for ::std::string::String {
        fn from(value: UpdateUserFiatKycStatusBodyBridgePhone) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgePhone>
        for UpdateUserFiatKycStatusBodyBridgePhone
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgePhone) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgePhone {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 18usize {
                return Err("longer than 18 characters".into());
            }
            if value.chars().count() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgePhone {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateUserFiatKycStatusBodyBridgePhone {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateUserFiatKycStatusBodyBridgePhone {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgePhone {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeResidentialAddress {
        pub city: UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity,
        pub country: UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code:
            ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode>,
        pub street_line_1: UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2:
            ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2>,
        pub subdivision: UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeResidentialAddress>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddress
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeResidentialAddress) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCity {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeResidentialAddressCountry {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressPostalCode
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressStreetLine2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeResidentialAddressSubdivision
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 10,
    ///  "minLength": 10
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate>
        for UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 10usize {
                return Err("longer than 10 characters".into());
            }
            if value.chars().count() < 10usize {
                return Err("shorter than 10 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxBirthDate {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "file",
    ///    "purposes"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "file": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "purposes": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "minLength": 1
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description:
            ::std::option::Option<UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription>,
        pub file: UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile,
        pub purposes:
            ::std::vec::Vec<UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem>,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItem>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItem
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItem) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemDescription
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemFile {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxDocumentsItemPurposesItem
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxFirstName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxFirstName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxFirstName>
        for UpdateUserFiatKycStatusBodyBridgeSandboxFirstName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "issuing_country",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "expiration": {
    ///      "type": "string"
    ///    },
    ///    "image_back": {
    ///      "type": "string"
    ///    },
    ///    "image_front": {
    ///      "type": "string"
    ///    },
    ///    "issuing_country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "number": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItem {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub expiration: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_back: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_front: ::std::option::Option<::std::string::String>,
        pub issuing_country:
            UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub number: ::std::option::Option<::std::string::String>,
        #[serde(rename = "type")]
        pub type_: ::std::string::String,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItem>
        for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItem
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItem,
        ) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        fn from(
            value : & UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxIdentifyingInformationItemIssuingCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxKycScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxKycScreen {
        pub result: UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult,
        pub screened_at: UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxKycScreen>
        for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreen
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxKycScreen) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt>
        for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxKycScreenScreenedAt
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxLastName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxLastName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxLastName>
        for UpdateUserFiatKycStatusBodyBridgeSandboxLastName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName>
        for UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxMiddleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxNationality`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxNationality(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxNationality {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxNationality>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxNationality) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxNationality>
        for UpdateUserFiatKycStatusBodyBridgeSandboxNationality
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxNationality) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxNationality {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxNationality {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxNationality
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxNationality
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxNationality {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreen`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "result",
    ///    "screened_at"
    ///  ],
    ///  "properties": {
    ///    "result": {
    ///      "type": "string",
    ///      "enum": [
    ///        "passed"
    ///      ]
    ///    },
    ///    "screened_at": {
    ///      "type": "string",
    ///      "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreen {
        pub result: UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult,
        pub screened_at: UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreen>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreen
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreen) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "passed"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult {
        #[serde(rename = "passed")]
        Passed,
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Passed => f.write_str("passed"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "passed" => Ok(Self::Passed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenResult
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
                ::std::sync::LazyLock::new(|| {
                    ::regress::Regex::new("^\\d{4}-\\d{2}-\\d{2}$").unwrap()
                });
            if PATTERN.find(value).is_none() {
                return Err("doesn't match pattern \"^\\d{4}-\\d{2}-\\d{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxOfacScreenScreenedAt
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxPhone`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 18,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxPhone(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxPhone {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxPhone> for ::std::string::String {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxPhone) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxPhone>
        for UpdateUserFiatKycStatusBodyBridgeSandboxPhone
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxPhone) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxPhone {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 18usize {
                return Err("longer than 18 characters".into());
            }
            if value.chars().count() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxPhone {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxPhone
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxPhone
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxPhone {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddress {
        pub city: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity,
        pub country: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<
            UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode,
        >,
        pub street_line_1: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<
            UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2,
        >,
        pub subdivision: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddress>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddress
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddress) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCity
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode>
        for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode,
        ) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressPostalCode
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1>
        for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2 {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2>
        for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressStreetLine2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision>
        for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxResidentialAddressSubdivision
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId>
        for UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSandboxSignedAgreementId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedFirstName
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedLastName
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedMiddleName
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddress {
        pub city: UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity,
        pub country:
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        >,
        pub street_line_1:
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        >,
        pub subdivision:
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddress,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddress
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddress,
        ) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCity
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        > for ::std::string::String
    {
        fn from(
            value : UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        fn from(
            value : & UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressPostalCode
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        > for ::std::string::String
    {
        fn from(
            value : UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        fn from(
            value : & UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        > for ::std::string::String
    {
        fn from(
            value : UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        fn from(
            value : & UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressStreetLine2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        > for ::std::string::String
    {
        fn from(
            value : UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        > for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        fn from(
            value : & UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeSandboxTransliteratedResidentialAddressSubdivision
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSandboxType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "individual"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateUserFiatKycStatusBodyBridgeSandboxType {
        #[serde(rename = "individual")]
        Individual,
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusBodyBridgeSandboxType {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSandboxType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateUserFiatKycStatusBodyBridgeSandboxType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Individual => f.write_str("individual"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSandboxType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "individual" => Ok(Self::Individual),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSandboxType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSandboxType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeSignedAgreementId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 1024,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeSignedAgreementId(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeSignedAgreementId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeSignedAgreementId>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeSignedAgreementId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeSignedAgreementId>
        for UpdateUserFiatKycStatusBodyBridgeSignedAgreementId
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeSignedAgreementId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeSignedAgreementId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 1024usize {
                return Err("longer than 1024 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeSignedAgreementId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeSignedAgreementId
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeSignedAgreementId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeTransliteratedFirstName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeTransliteratedLastName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 256,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName(::std::string::String);
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName>
        for ::std::string::String
    {
        fn from(value: UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 256usize {
                return Err("longer than 256 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateUserFiatKycStatusBodyBridgeTransliteratedMiddleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "city",
    ///    "country",
    ///    "street_line_1",
    ///    "subdivision"
    ///  ],
    ///  "properties": {
    ///    "city": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "country": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 3
    ///    },
    ///    "postal_code": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_1": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "street_line_2": {
    ///      "type": "string",
    ///      "minLength": 1
    ///    },
    ///    "subdivision": {
    ///      "type": "string",
    ///      "maxLength": 3,
    ///      "minLength": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddress {
        pub city: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity,
        pub country: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub postal_code: ::std::option::Option<
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode,
        >,
        pub street_line_1:
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub street_line_2: ::std::option::Option<
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2,
        >,
        pub subdivision:
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddress>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddress
    {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddress) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity(
        ::std::string::String,
    );
    impl ::std::ops::Deref for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity>
        for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<&UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCity
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry,
        > for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 3usize {
                return Err("shorter than 3 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressCountry
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode,
        > for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressPostalCode
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1,
        > for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine1
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2,
        > for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressStreetLine2
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 3,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision(
        ::std::string::String,
    );
    impl ::std::ops::Deref
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl
        ::std::convert::From<
            UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision,
        > for ::std::string::String
    {
        fn from(
            value: UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.0
        }
    }

    impl
        ::std::convert::From<
            &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision,
        > for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        fn from(
            value: &UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 3usize {
                return Err("longer than 3 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de>
        for UpdateUserFiatKycStatusBodyBridgeTransliteratedResidentialAddressSubdivision
    {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`UpdateUserFiatKycStatusBodyBridgeType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "individual"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateUserFiatKycStatusBodyBridgeType {
        #[serde(rename = "individual")]
        Individual,
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusBodyBridgeType {
        fn from(value: &UpdateUserFiatKycStatusBodyBridgeType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateUserFiatKycStatusBodyBridgeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Individual => f.write_str("individual"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusBodyBridgeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "individual" => Ok(Self::Individual),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusBodyBridgeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateUserFiatKycStatusBodyBridgeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateUserFiatKycStatusBodyBridgeType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateUserFiatKycStatusResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "provider_user_id": "303912cc-74fa-4f7a-9c51-2945b40ac09a",
    ///      "status": "under_review",
    ///      "user_id": "cmaftdj280001ww1ihwhy57s3"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "status",
    ///    "user_id"
    ///  ],
    ///  "properties": {
    ///    "provider_user_id": {
    ///      "type": "string"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "not_found",
    ///        "active",
    ///        "awaiting_questionnaire",
    ///        "awaiting_ubo",
    ///        "incomplete",
    ///        "not_started",
    ///        "offboarded",
    ///        "paused",
    ///        "rejected",
    ///        "under_review"
    ///      ]
    ///    },
    ///    "user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateUserFiatKycStatusResponse {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub provider_user_id: ::std::option::Option<::std::string::String>,
        pub status: UpdateUserFiatKycStatusResponseStatus,
        pub user_id: ::std::string::String,
    }

    impl ::std::convert::From<&UpdateUserFiatKycStatusResponse> for UpdateUserFiatKycStatusResponse {
        fn from(value: &UpdateUserFiatKycStatusResponse) -> Self {
            value.clone()
        }
    }

    ///`UpdateUserFiatKycStatusResponseStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "not_found",
    ///    "active",
    ///    "awaiting_questionnaire",
    ///    "awaiting_ubo",
    ///    "incomplete",
    ///    "not_started",
    ///    "offboarded",
    ///    "paused",
    ///    "rejected",
    ///    "under_review"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UpdateUserFiatKycStatusResponseStatus {
        #[serde(rename = "not_found")]
        NotFound,
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "awaiting_questionnaire")]
        AwaitingQuestionnaire,
        #[serde(rename = "awaiting_ubo")]
        AwaitingUbo,
        #[serde(rename = "incomplete")]
        Incomplete,
        #[serde(rename = "not_started")]
        NotStarted,
        #[serde(rename = "offboarded")]
        Offboarded,
        #[serde(rename = "paused")]
        Paused,
        #[serde(rename = "rejected")]
        Rejected,
        #[serde(rename = "under_review")]
        UnderReview,
    }

    impl ::std::convert::From<&Self> for UpdateUserFiatKycStatusResponseStatus {
        fn from(value: &UpdateUserFiatKycStatusResponseStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UpdateUserFiatKycStatusResponseStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NotFound => f.write_str("not_found"),
                Self::Active => f.write_str("active"),
                Self::AwaitingQuestionnaire => f.write_str("awaiting_questionnaire"),
                Self::AwaitingUbo => f.write_str("awaiting_ubo"),
                Self::Incomplete => f.write_str("incomplete"),
                Self::NotStarted => f.write_str("not_started"),
                Self::Offboarded => f.write_str("offboarded"),
                Self::Paused => f.write_str("paused"),
                Self::Rejected => f.write_str("rejected"),
                Self::UnderReview => f.write_str("under_review"),
            }
        }
    }

    impl ::std::str::FromStr for UpdateUserFiatKycStatusResponseStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "not_found" => Ok(Self::NotFound),
                "active" => Ok(Self::Active),
                "awaiting_questionnaire" => Ok(Self::AwaitingQuestionnaire),
                "awaiting_ubo" => Ok(Self::AwaitingUbo),
                "incomplete" => Ok(Self::Incomplete),
                "not_started" => Ok(Self::NotStarted),
                "offboarded" => Ok(Self::Offboarded),
                "paused" => Ok(Self::Paused),
                "rejected" => Ok(Self::Rejected),
                "under_review" => Ok(Self::UnderReview),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateUserFiatKycStatusResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateUserFiatKycStatusResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateUserFiatKycStatusResponseStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UpdateWalletBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "policy_ids": [
    ///        "tb54eps4z44ed0jepousxi4n"
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "properties": {
    ///    "additional_signers": {
    ///      "$ref": "#/components/schemas/WalletAdditionalSigner"
    ///    },
    ///    "owner": {
    ///      "$ref": "#/components/schemas/OwnerInput"
    ///    },
    ///    "owner_id": {
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/OwnerIdInput"
    ///        },
    ///        {}
    ///      ]
    ///    },
    ///    "policy_ids": {
    ///      "description": "New policy IDs to enforce on the wallet. Currently,
    /// only one policy is supported per wallet.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "maxLength": 24,
    ///        "minLength": 24
    ///      },
    ///      "maxItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdateWalletBody {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub additional_signers: ::std::option::Option<WalletAdditionalSigner>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<OwnerInput>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<OwnerIdInput>,
        ///New policy IDs to enforce on the wallet. Currently, only one policy
        /// is supported per wallet.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<UpdateWalletBodyPolicyIdsItem>,
    }

    impl ::std::convert::From<&UpdateWalletBody> for UpdateWalletBody {
        fn from(value: &UpdateWalletBody) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for UpdateWalletBody {
        fn default() -> Self {
            Self {
                additional_signers: Default::default(),
                owner: Default::default(),
                owner_id: Default::default(),
                policy_ids: Default::default(),
            }
        }
    }

    ///`UpdateWalletBodyPolicyIdsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "maxLength": 24,
    ///  "minLength": 24
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct UpdateWalletBodyPolicyIdsItem(::std::string::String);
    impl ::std::ops::Deref for UpdateWalletBodyPolicyIdsItem {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UpdateWalletBodyPolicyIdsItem> for ::std::string::String {
        fn from(value: UpdateWalletBodyPolicyIdsItem) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UpdateWalletBodyPolicyIdsItem> for UpdateWalletBodyPolicyIdsItem {
        fn from(value: &UpdateWalletBodyPolicyIdsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UpdateWalletBodyPolicyIdsItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 24usize {
                return Err("longer than 24 characters".into());
            }
            if value.chars().count() < 24usize {
                return Err("shorter than 24 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UpdateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UpdateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UpdateWalletBodyPolicyIdsItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UpdateWalletBodyPolicyIdsItem {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`User`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "created_at": 1731974895,
    ///      "has_accepted_terms": true,
    ///      "id": "did:privy:cm3np4u9j001rc8b73seqmqqk",
    ///      "is_guest": false,
    ///      "linked_accounts": [
    ///        {
    ///          "address": "tom.bombadill@privy.io",
    ///          "first_verified_at": 1674788927,
    ///          "latest_verified_at": 1674788927,
    ///          "type": "email",
    ///          "verified_at": 1674788927
    ///        },
    ///        {
    ///          "bio": "engineering at /privy. building pixelpool.xyz, the
    /// first Farcaster video client. nyc. 👨‍💻🍎🏳️‍🌈  nf.td/payton",
    ///          "display_name": "payton ↑",
    ///          "fid": 4423,
    ///          "first_verified_at": 1740678402,
    ///          "latest_verified_at": 1741194370,
    ///          "owner_address": "0xE6bFb4137F3A8C069F98cc775f324A84FE45FdFF",
    ///          "profile_picture": "https://supercast.mypinata.cloud/ipfs/QmNexfCxdnFzWdJqKVgrjd27UGLMexNaw5FXu1XKR3cQF7?filename=IMG_2799.png",
    ///          "profile_picture_url": "https://supercast.mypinata.cloud/ipfs/QmNexfCxdnFzWdJqKVgrjd27UGLMexNaw5FXu1XKR3cQF7?filename=IMG_2799.png",
    ///          "type": "farcaster",
    ///          "username": "payton",
    ///          "verified_at": 1740678402
    ///        },
    ///        {
    ///          "authenticator_name": "1Password",
    ///          "created_with_browser": "Chrome",
    ///          "created_with_device": "Macintosh",
    ///          "created_with_os": "Mac OS",
    ///          "credential_id":
    /// "Il5vP-3Tm3hNmDVBmDlREgXzIOJnZEaiVnT-XMliXe-BufP9GL1-d3qhozk9IkZwQ_",
    ///          "enrolled_in_mfa": true,
    ///          "first_verified_at": 1741194420,
    ///          "latest_verified_at": 1741194420,
    ///          "public_key":
    /// "pQECAyYgASFYIKdGwx5XxZ/7CJJzT8d5L6jyLNQdTH7X+rSZdPJ9Ux/
    /// QIlggRm4OcJ8F3aB5zYz3T9LxLdDfGpWvYkHgS4A8tPz9CqE=",
    ///          "type": "passkey",
    ///          "verified_at": 1741194420
    ///        }
    ///      ],
    ///      "mfa_methods": [
    ///        {
    ///          "type": "passkey",
    ///          "verified_at": 1741194420
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "created_at",
    ///    "has_accepted_terms",
    ///    "id",
    ///    "is_guest",
    ///    "linked_accounts",
    ///    "mfa_methods"
    ///  ],
    ///  "properties": {
    ///    "created_at": {
    ///      "description": "Unix timestamp of when the user was created in
    /// milliseconds.",
    ///      "type": "number"
    ///    },
    ///    "custom_metadata": {
    ///      "$ref": "#/components/schemas/CustomMetadata"
    ///    },
    ///    "has_accepted_terms": {
    ///      "description": "Indicates if the user has accepted the terms of
    /// service.",
    ///      "type": "boolean"
    ///    },
    ///    "id": {
    ///      "type": "string"
    ///    },
    ///    "is_guest": {
    ///      "description": "Indicates if the user is a guest account user.",
    ///      "type": "boolean"
    ///    },
    ///    "linked_accounts": {
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountEmail"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountPhone"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountCrossApp"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountAuthorizationKey"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountCustomJwt"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountAppleOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountDiscordOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountGithubOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountGoogleOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountInstagramOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountLinkedInOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountSpotifyOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountTiktokOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountLineOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountTwitterOauth"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountSmartWallet"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountPasskey"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountFarcaster"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountTelegram"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountEthereum"
    ///          },
    ///          {
    ///            "$ref":
    /// "#/components/schemas/LinkedAccountEthereumEmbeddedWallet"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/LinkedAccountSolana"
    ///          },
    ///          {
    ///            "$ref":
    /// "#/components/schemas/LinkedAccountSolanaEmbeddedWallet"
    ///          },
    ///          {
    ///            "$ref":
    /// "#/components/schemas/LinkedAccountBitcoinSegwitEmbeddedWallet"
    ///          },
    ///          {
    ///            "$ref":
    /// "#/components/schemas/LinkedAccountBitcoinTaprootEmbeddedWallet"
    ///          }
    ///        ]
    ///      }
    ///    },
    ///    "mfa_methods": {
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "$ref": "#/components/schemas/PasskeyMfaMethod"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/SmsMfaMethod"
    ///          },
    ///          {
    ///            "$ref": "#/components/schemas/TotpMfaMethod"
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct User {
        pub created_at: f64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub custom_metadata: ::std::option::Option<CustomMetadata>,
        ///Indicates if the user has accepted the terms of service.
        pub has_accepted_terms: bool,
        pub id: ::std::string::String,
        ///Indicates if the user is a guest account user.
        pub is_guest: bool,
        pub linked_accounts: ::std::vec::Vec<UserLinkedAccountsItem>,
        pub mfa_methods: ::std::vec::Vec<UserMfaMethodsItem>,
    }

    impl ::std::convert::From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    ///`UserFiatStatusesBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "provider"
    ///  ],
    ///  "properties": {
    ///    "provider": {
    ///      "type": "string",
    ///      "enum": [
    ///        "bridge",
    ///        "bridge-sandbox"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserFiatStatusesBody {
        pub provider: UserFiatStatusesBodyProvider,
    }

    impl ::std::convert::From<&UserFiatStatusesBody> for UserFiatStatusesBody {
        fn from(value: &UserFiatStatusesBody) -> Self {
            value.clone()
        }
    }

    ///`UserFiatStatusesBodyProvider`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "bridge",
    ///    "bridge-sandbox"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UserFiatStatusesBodyProvider {
        #[serde(rename = "bridge")]
        Bridge,
        #[serde(rename = "bridge-sandbox")]
        BridgeSandbox,
    }

    impl ::std::convert::From<&Self> for UserFiatStatusesBodyProvider {
        fn from(value: &UserFiatStatusesBodyProvider) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UserFiatStatusesBodyProvider {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bridge => f.write_str("bridge"),
                Self::BridgeSandbox => f.write_str("bridge-sandbox"),
            }
        }
    }

    impl ::std::str::FromStr for UserFiatStatusesBodyProvider {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bridge" => Ok(Self::Bridge),
                "bridge-sandbox" => Ok(Self::BridgeSandbox),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UserFiatStatusesBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UserFiatStatusesBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UserFiatStatusesBodyProvider {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UserFiatStatusesResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "transactions"
    ///  ],
    ///  "properties": {
    ///    "transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "type": "object",
    ///            "required": [
    ///              "created_at",
    ///              "deposit_instructions",
    ///              "destination",
    ///              "id",
    ///              "is_sandbox",
    ///              "status",
    ///              "type"
    ///            ],
    ///            "properties": {
    ///              "created_at": {
    ///                "type": "string"
    ///              },
    ///              "deposit_instructions": {
    ///                "type": "object",
    ///                "required": [
    ///                  "amount",
    ///                  "currency",
    ///                  "payment_rail"
    ///                ],
    ///                "properties": {
    ///                  "account_holder_name": {
    ///                    "type": "string"
    ///                  },
    ///                  "amount": {
    ///                    "type": "string"
    ///                  },
    ///                  "bank_account_number": {
    ///                    "type": "string"
    ///                  },
    ///                  "bank_address": {
    ///                    "type": "string"
    ///                  },
    ///                  "bank_beneficiary_address": {
    ///                    "type": "string"
    ///                  },
    ///                  "bank_beneficiary_name": {
    ///                    "type": "string"
    ///                  },
    ///                  "bank_name": {
    ///                    "type": "string"
    ///                  },
    ///                  "bank_routing_number": {
    ///                    "type": "string"
    ///                  },
    ///                  "bic": {
    ///                    "type": "string"
    ///                  },
    ///                  "currency": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "usd",
    ///                      "eur"
    ///                    ]
    ///                  },
    ///                  "deposit_message": {
    ///                    "type": "string"
    ///                  },
    ///                  "iban": {
    ///                    "type": "string"
    ///                  },
    ///                  "payment_rail": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "sepa",
    ///                      "ach_push",
    ///                      "wire"
    ///                    ]
    ///                  }
    ///                }
    ///              },
    ///              "destination": {
    ///                "type": "object",
    ///                "required": [
    ///                  "address",
    ///                  "chain",
    ///                  "currency"
    ///                ],
    ///                "properties": {
    ///                  "address": {
    ///                    "type": "string"
    ///                  },
    ///                  "chain": {
    ///                    "type": "string"
    ///                  },
    ///                  "currency": {
    ///                    "type": "string"
    ///                  },
    ///                  "privy_user_id": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "id": {
    ///                "type": "string"
    ///              },
    ///              "is_sandbox": {
    ///                "type": "boolean"
    ///              },
    ///              "receipt": {
    ///                "type": "object",
    ///                "required": [
    ///                  "final_amount"
    ///                ],
    ///                "properties": {
    ///                  "final_amount": {
    ///                    "type": "string"
    ///                  },
    ///                  "transaction_hash": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "status": {
    ///                "type": "string",
    ///                "enum": [
    ///                  "awaiting_funds",
    ///                  "in_review",
    ///                  "funds_received",
    ///                  "payment_submitted",
    ///                  "payment_processed",
    ///                  "canceled",
    ///                  "error",
    ///                  "undeliverable",
    ///                  "returned",
    ///                  "refunded"
    ///                ]
    ///              },
    ///              "type": {
    ///                "type": "string",
    ///                "enum": [
    ///                  "onramp"
    ///                ]
    ///              }
    ///            }
    ///          },
    ///          {
    ///            "type": "object",
    ///            "required": [
    ///              "created_at",
    ///              "deposit_instructions",
    ///              "destination",
    ///              "id",
    ///              "is_sandbox",
    ///              "status",
    ///              "type"
    ///            ],
    ///            "properties": {
    ///              "created_at": {
    ///                "type": "string"
    ///              },
    ///              "deposit_instructions": {
    ///                "type": "object",
    ///                "required": [
    ///                  "amount",
    ///                  "chain",
    ///                  "currency",
    ///                  "from_address",
    ///                  "to_address"
    ///                ],
    ///                "properties": {
    ///                  "amount": {
    ///                    "type": "string"
    ///                  },
    ///                  "chain": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "ethereum",
    ///                      "base",
    ///                      "arbitrum",
    ///                      "polygon",
    ///                      "optimism"
    ///                    ]
    ///                  },
    ///                  "currency": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "usdc"
    ///                    ]
    ///                  },
    ///                  "from_address": {
    ///                    "type": "string"
    ///                  },
    ///                  "to_address": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "destination": {
    ///                "type": "object",
    ///                "required": [
    ///                  "currency",
    ///                  "external_account_id",
    ///                  "payment_rail"
    ///                ],
    ///                "properties": {
    ///                  "currency": {
    ///                    "type": "string"
    ///                  },
    ///                  "external_account_id": {
    ///                    "type": "string"
    ///                  },
    ///                  "payment_rail": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "id": {
    ///                "type": "string"
    ///              },
    ///              "is_sandbox": {
    ///                "type": "boolean"
    ///              },
    ///              "receipt": {
    ///                "type": "object",
    ///                "required": [
    ///                  "final_amount"
    ///                ],
    ///                "properties": {
    ///                  "final_amount": {
    ///                    "type": "string"
    ///                  },
    ///                  "transaction_hash": {
    ///                    "type": "string"
    ///                  }
    ///                }
    ///              },
    ///              "status": {
    ///                "type": "string",
    ///                "enum": [
    ///                  "awaiting_funds",
    ///                  "in_review",
    ///                  "funds_received",
    ///                  "payment_submitted",
    ///                  "payment_processed",
    ///                  "canceled",
    ///                  "error",
    ///                  "undeliverable",
    ///                  "returned",
    ///                  "refunded"
    ///                ]
    ///              },
    ///              "type": {
    ///                "type": "string",
    ///                "enum": [
    ///                  "offramp"
    ///                ]
    ///              }
    ///            }
    ///          }
    ///        ]
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserFiatStatusesResponse {
        pub transactions: ::std::vec::Vec<UserFiatStatusesResponseTransactionsItem>,
    }

    impl ::std::convert::From<&UserFiatStatusesResponse> for UserFiatStatusesResponse {
        fn from(value: &UserFiatStatusesResponse) -> Self {
            value.clone()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "created_at",
    ///        "deposit_instructions",
    ///        "destination",
    ///        "id",
    ///        "is_sandbox",
    ///        "status",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "created_at": {
    ///          "type": "string"
    ///        },
    ///        "deposit_instructions": {
    ///          "type": "object",
    ///          "required": [
    ///            "amount",
    ///            "currency",
    ///            "payment_rail"
    ///          ],
    ///          "properties": {
    ///            "account_holder_name": {
    ///              "type": "string"
    ///            },
    ///            "amount": {
    ///              "type": "string"
    ///            },
    ///            "bank_account_number": {
    ///              "type": "string"
    ///            },
    ///            "bank_address": {
    ///              "type": "string"
    ///            },
    ///            "bank_beneficiary_address": {
    ///              "type": "string"
    ///            },
    ///            "bank_beneficiary_name": {
    ///              "type": "string"
    ///            },
    ///            "bank_name": {
    ///              "type": "string"
    ///            },
    ///            "bank_routing_number": {
    ///              "type": "string"
    ///            },
    ///            "bic": {
    ///              "type": "string"
    ///            },
    ///            "currency": {
    ///              "type": "string",
    ///              "enum": [
    ///                "usd",
    ///                "eur"
    ///              ]
    ///            },
    ///            "deposit_message": {
    ///              "type": "string"
    ///            },
    ///            "iban": {
    ///              "type": "string"
    ///            },
    ///            "payment_rail": {
    ///              "type": "string",
    ///              "enum": [
    ///                "sepa",
    ///                "ach_push",
    ///                "wire"
    ///              ]
    ///            }
    ///          }
    ///        },
    ///        "destination": {
    ///          "type": "object",
    ///          "required": [
    ///            "address",
    ///            "chain",
    ///            "currency"
    ///          ],
    ///          "properties": {
    ///            "address": {
    ///              "type": "string"
    ///            },
    ///            "chain": {
    ///              "type": "string"
    ///            },
    ///            "currency": {
    ///              "type": "string"
    ///            },
    ///            "privy_user_id": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "id": {
    ///          "type": "string"
    ///        },
    ///        "is_sandbox": {
    ///          "type": "boolean"
    ///        },
    ///        "receipt": {
    ///          "type": "object",
    ///          "required": [
    ///            "final_amount"
    ///          ],
    ///          "properties": {
    ///            "final_amount": {
    ///              "type": "string"
    ///            },
    ///            "transaction_hash": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "awaiting_funds",
    ///            "in_review",
    ///            "funds_received",
    ///            "payment_submitted",
    ///            "payment_processed",
    ///            "canceled",
    ///            "error",
    ///            "undeliverable",
    ///            "returned",
    ///            "refunded"
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "onramp"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "created_at",
    ///        "deposit_instructions",
    ///        "destination",
    ///        "id",
    ///        "is_sandbox",
    ///        "status",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "created_at": {
    ///          "type": "string"
    ///        },
    ///        "deposit_instructions": {
    ///          "type": "object",
    ///          "required": [
    ///            "amount",
    ///            "chain",
    ///            "currency",
    ///            "from_address",
    ///            "to_address"
    ///          ],
    ///          "properties": {
    ///            "amount": {
    ///              "type": "string"
    ///            },
    ///            "chain": {
    ///              "type": "string",
    ///              "enum": [
    ///                "ethereum",
    ///                "base",
    ///                "arbitrum",
    ///                "polygon",
    ///                "optimism"
    ///              ]
    ///            },
    ///            "currency": {
    ///              "type": "string",
    ///              "enum": [
    ///                "usdc"
    ///              ]
    ///            },
    ///            "from_address": {
    ///              "type": "string"
    ///            },
    ///            "to_address": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "destination": {
    ///          "type": "object",
    ///          "required": [
    ///            "currency",
    ///            "external_account_id",
    ///            "payment_rail"
    ///          ],
    ///          "properties": {
    ///            "currency": {
    ///              "type": "string"
    ///            },
    ///            "external_account_id": {
    ///              "type": "string"
    ///            },
    ///            "payment_rail": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "id": {
    ///          "type": "string"
    ///        },
    ///        "is_sandbox": {
    ///          "type": "boolean"
    ///        },
    ///        "receipt": {
    ///          "type": "object",
    ///          "required": [
    ///            "final_amount"
    ///          ],
    ///          "properties": {
    ///            "final_amount": {
    ///              "type": "string"
    ///            },
    ///            "transaction_hash": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        "status": {
    ///          "type": "string",
    ///          "enum": [
    ///            "awaiting_funds",
    ///            "in_review",
    ///            "funds_received",
    ///            "payment_submitted",
    ///            "payment_processed",
    ///            "canceled",
    ///            "error",
    ///            "undeliverable",
    ///            "returned",
    ///            "refunded"
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "offramp"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(tag = "type")]
    pub enum UserFiatStatusesResponseTransactionsItem {
        #[serde(rename = "onramp")]
        Onramp {
            created_at: ::std::string::String,
            deposit_instructions: UserFiatStatusesResponseTransactionsItemDepositInstructions,
            destination: UserFiatStatusesResponseTransactionsItemDestination,
            id: ::std::string::String,
            is_sandbox: bool,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            receipt: ::std::option::Option<UserFiatStatusesResponseTransactionsItemReceipt>,
            status: UserFiatStatusesResponseTransactionsItemStatus,
        },
        #[serde(rename = "offramp")]
        Offramp {
            created_at: ::std::string::String,
            deposit_instructions: UserFiatStatusesResponseTransactionsItemDepositInstructions,
            destination: UserFiatStatusesResponseTransactionsItemDestination,
            id: ::std::string::String,
            is_sandbox: bool,
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            receipt: ::std::option::Option<UserFiatStatusesResponseTransactionsItemReceipt>,
            status: UserFiatStatusesResponseTransactionsItemStatus,
        },
    }

    impl ::std::convert::From<&Self> for UserFiatStatusesResponseTransactionsItem {
        fn from(value: &UserFiatStatusesResponseTransactionsItem) -> Self {
            value.clone()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItemDepositInstructions`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "amount",
    ///    "currency",
    ///    "payment_rail"
    ///  ],
    ///  "properties": {
    ///    "account_holder_name": {
    ///      "type": "string"
    ///    },
    ///    "amount": {
    ///      "type": "string"
    ///    },
    ///    "bank_account_number": {
    ///      "type": "string"
    ///    },
    ///    "bank_address": {
    ///      "type": "string"
    ///    },
    ///    "bank_beneficiary_address": {
    ///      "type": "string"
    ///    },
    ///    "bank_beneficiary_name": {
    ///      "type": "string"
    ///    },
    ///    "bank_name": {
    ///      "type": "string"
    ///    },
    ///    "bank_routing_number": {
    ///      "type": "string"
    ///    },
    ///    "bic": {
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "type": "string",
    ///      "enum": [
    ///        "usd",
    ///        "eur"
    ///      ]
    ///    },
    ///    "deposit_message": {
    ///      "type": "string"
    ///    },
    ///    "iban": {
    ///      "type": "string"
    ///    },
    ///    "payment_rail": {
    ///      "type": "string",
    ///      "enum": [
    ///        "sepa",
    ///        "ach_push",
    ///        "wire"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserFiatStatusesResponseTransactionsItemDepositInstructions {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub account_holder_name: ::std::option::Option<::std::string::String>,
        pub amount: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_account_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_address: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_beneficiary_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bank_routing_number: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub bic: ::std::option::Option<::std::string::String>,
        pub currency: UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub deposit_message: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub iban: ::std::option::Option<::std::string::String>,
        pub payment_rail: UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail,
    }

    impl ::std::convert::From<&UserFiatStatusesResponseTransactionsItemDepositInstructions>
        for UserFiatStatusesResponseTransactionsItemDepositInstructions
    {
        fn from(value: &UserFiatStatusesResponseTransactionsItemDepositInstructions) -> Self {
            value.clone()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItemDepositInstructionsChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "base",
    ///    "arbitrum",
    ///    "polygon",
    ///    "optimism"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UserFiatStatusesResponseTransactionsItemDepositInstructionsChain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "optimism")]
        Optimism,
    }

    impl ::std::convert::From<&Self>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsChain
    {
        fn from(value: &UserFiatStatusesResponseTransactionsItemDepositInstructionsChain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UserFiatStatusesResponseTransactionsItemDepositInstructionsChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Base => f.write_str("base"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Polygon => f.write_str("polygon"),
                Self::Optimism => f.write_str("optimism"),
            }
        }
    }

    impl ::std::str::FromStr for UserFiatStatusesResponseTransactionsItemDepositInstructionsChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "base" => Ok(Self::Base),
                "arbitrum" => Ok(Self::Arbitrum),
                "polygon" => Ok(Self::Polygon),
                "optimism" => Ok(Self::Optimism),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsChain
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsChain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsChain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usd",
    ///    "eur"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency {
        #[serde(rename = "usd")]
        Usd,
        #[serde(rename = "eur")]
        Eur,
    }

    impl ::std::convert::From<&Self>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency
    {
        fn from(
            value: &UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usd => f.write_str("usd"),
                Self::Eur => f.write_str("eur"),
            }
        }
    }

    impl ::std::str::FromStr for UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usd" => Ok(Self::Usd),
                "eur" => Ok(Self::Eur),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsCurrency
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "sepa",
    ///    "ach_push",
    ///    "wire"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail {
        #[serde(rename = "sepa")]
        Sepa,
        #[serde(rename = "ach_push")]
        AchPush,
        #[serde(rename = "wire")]
        Wire,
    }

    impl ::std::convert::From<&Self>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail
    {
        fn from(
            value: &UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail,
        ) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sepa => f.write_str("sepa"),
                Self::AchPush => f.write_str("ach_push"),
                Self::Wire => f.write_str("wire"),
            }
        }
    }

    impl ::std::str::FromStr
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail
    {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sepa" => Ok(Self::Sepa),
                "ach_push" => Ok(Self::AchPush),
                "wire" => Ok(Self::Wire),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UserFiatStatusesResponseTransactionsItemDepositInstructionsPaymentRail
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItemDestination`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "chain",
    ///    "currency"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string"
    ///    },
    ///    "chain": {
    ///      "type": "string"
    ///    },
    ///    "currency": {
    ///      "type": "string"
    ///    },
    ///    "privy_user_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserFiatStatusesResponseTransactionsItemDestination {
        pub address: ::std::string::String,
        pub chain: ::std::string::String,
        pub currency: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub privy_user_id: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserFiatStatusesResponseTransactionsItemDestination>
        for UserFiatStatusesResponseTransactionsItemDestination
    {
        fn from(value: &UserFiatStatusesResponseTransactionsItemDestination) -> Self {
            value.clone()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItemReceipt`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "final_amount"
    ///  ],
    ///  "properties": {
    ///    "final_amount": {
    ///      "type": "string"
    ///    },
    ///    "transaction_hash": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserFiatStatusesResponseTransactionsItemReceipt {
        pub final_amount: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub transaction_hash: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserFiatStatusesResponseTransactionsItemReceipt>
        for UserFiatStatusesResponseTransactionsItemReceipt
    {
        fn from(value: &UserFiatStatusesResponseTransactionsItemReceipt) -> Self {
            value.clone()
        }
    }

    ///`UserFiatStatusesResponseTransactionsItemStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "awaiting_funds",
    ///    "in_review",
    ///    "funds_received",
    ///    "payment_submitted",
    ///    "payment_processed",
    ///    "canceled",
    ///    "error",
    ///    "undeliverable",
    ///    "returned",
    ///    "refunded"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UserFiatStatusesResponseTransactionsItemStatus {
        #[serde(rename = "awaiting_funds")]
        AwaitingFunds,
        #[serde(rename = "in_review")]
        InReview,
        #[serde(rename = "funds_received")]
        FundsReceived,
        #[serde(rename = "payment_submitted")]
        PaymentSubmitted,
        #[serde(rename = "payment_processed")]
        PaymentProcessed,
        #[serde(rename = "canceled")]
        Canceled,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "undeliverable")]
        Undeliverable,
        #[serde(rename = "returned")]
        Returned,
        #[serde(rename = "refunded")]
        Refunded,
    }

    impl ::std::convert::From<&Self> for UserFiatStatusesResponseTransactionsItemStatus {
        fn from(value: &UserFiatStatusesResponseTransactionsItemStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for UserFiatStatusesResponseTransactionsItemStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AwaitingFunds => f.write_str("awaiting_funds"),
                Self::InReview => f.write_str("in_review"),
                Self::FundsReceived => f.write_str("funds_received"),
                Self::PaymentSubmitted => f.write_str("payment_submitted"),
                Self::PaymentProcessed => f.write_str("payment_processed"),
                Self::Canceled => f.write_str("canceled"),
                Self::Error => f.write_str("error"),
                Self::Undeliverable => f.write_str("undeliverable"),
                Self::Returned => f.write_str("returned"),
                Self::Refunded => f.write_str("refunded"),
            }
        }
    }

    impl ::std::str::FromStr for UserFiatStatusesResponseTransactionsItemStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "awaiting_funds" => Ok(Self::AwaitingFunds),
                "in_review" => Ok(Self::InReview),
                "funds_received" => Ok(Self::FundsReceived),
                "payment_submitted" => Ok(Self::PaymentSubmitted),
                "payment_processed" => Ok(Self::PaymentProcessed),
                "canceled" => Ok(Self::Canceled),
                "error" => Ok(Self::Error),
                "undeliverable" => Ok(Self::Undeliverable),
                "returned" => Ok(Self::Returned),
                "refunded" => Ok(Self::Refunded),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for UserFiatStatusesResponseTransactionsItemStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for UserFiatStatusesResponseTransactionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for UserFiatStatusesResponseTransactionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`UserLinkedAccountsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountEmail"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountPhone"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountCrossApp"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountAuthorizationKey"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountCustomJwt"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountAppleOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountDiscordOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountGithubOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountGoogleOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountInstagramOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountLinkedInOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountSpotifyOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountTiktokOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountLineOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountTwitterOauth"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountSmartWallet"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountPasskey"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountFarcaster"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountTelegram"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountEthereum"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountEthereumEmbeddedWallet"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountSolana"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/LinkedAccountSolanaEmbeddedWallet"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/LinkedAccountBitcoinSegwitEmbeddedWallet"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/LinkedAccountBitcoinTaprootEmbeddedWallet"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UserLinkedAccountsItem {
        Email(LinkedAccountEmail),
        Phone(LinkedAccountPhone),
        CrossApp(LinkedAccountCrossApp),
        AuthorizationKey(LinkedAccountAuthorizationKey),
        CustomJwt(LinkedAccountCustomJwt),
        AppleOauth(LinkedAccountAppleOauth),
        DiscordOauth(LinkedAccountDiscordOauth),
        GithubOauth(LinkedAccountGithubOauth),
        GoogleOauth(LinkedAccountGoogleOauth),
        InstagramOauth(LinkedAccountInstagramOauth),
        LinkedInOauth(LinkedAccountLinkedInOauth),
        SpotifyOauth(LinkedAccountSpotifyOauth),
        TiktokOauth(LinkedAccountTiktokOauth),
        LineOauth(LinkedAccountLineOauth),
        TwitterOauth(LinkedAccountTwitterOauth),
        SmartWallet(LinkedAccountSmartWallet),
        Passkey(LinkedAccountPasskey),
        Farcaster(LinkedAccountFarcaster),
        Telegram(LinkedAccountTelegram),
        Ethereum(LinkedAccountEthereum),
        EthereumEmbeddedWallet(LinkedAccountEthereumEmbeddedWallet),
        Solana(LinkedAccountSolana),
        SolanaEmbeddedWallet(LinkedAccountSolanaEmbeddedWallet),
        BitcoinSegwitEmbeddedWallet(LinkedAccountBitcoinSegwitEmbeddedWallet),
        BitcoinTaprootEmbeddedWallet(LinkedAccountBitcoinTaprootEmbeddedWallet),
    }

    impl ::std::convert::From<&Self> for UserLinkedAccountsItem {
        fn from(value: &UserLinkedAccountsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<LinkedAccountEmail> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountEmail) -> Self {
            Self::Email(value)
        }
    }

    impl ::std::convert::From<LinkedAccountPhone> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountPhone) -> Self {
            Self::Phone(value)
        }
    }

    impl ::std::convert::From<LinkedAccountCrossApp> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountCrossApp) -> Self {
            Self::CrossApp(value)
        }
    }

    impl ::std::convert::From<LinkedAccountAuthorizationKey> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountAuthorizationKey) -> Self {
            Self::AuthorizationKey(value)
        }
    }

    impl ::std::convert::From<LinkedAccountCustomJwt> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountCustomJwt) -> Self {
            Self::CustomJwt(value)
        }
    }

    impl ::std::convert::From<LinkedAccountAppleOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountAppleOauth) -> Self {
            Self::AppleOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountDiscordOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountDiscordOauth) -> Self {
            Self::DiscordOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountGithubOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountGithubOauth) -> Self {
            Self::GithubOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountGoogleOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountGoogleOauth) -> Self {
            Self::GoogleOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountInstagramOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountInstagramOauth) -> Self {
            Self::InstagramOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountLinkedInOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountLinkedInOauth) -> Self {
            Self::LinkedInOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountSpotifyOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSpotifyOauth) -> Self {
            Self::SpotifyOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountTiktokOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountTiktokOauth) -> Self {
            Self::TiktokOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountLineOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountLineOauth) -> Self {
            Self::LineOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountTwitterOauth> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountTwitterOauth) -> Self {
            Self::TwitterOauth(value)
        }
    }

    impl ::std::convert::From<LinkedAccountSmartWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSmartWallet) -> Self {
            Self::SmartWallet(value)
        }
    }

    impl ::std::convert::From<LinkedAccountPasskey> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountPasskey) -> Self {
            Self::Passkey(value)
        }
    }

    impl ::std::convert::From<LinkedAccountFarcaster> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountFarcaster) -> Self {
            Self::Farcaster(value)
        }
    }

    impl ::std::convert::From<LinkedAccountTelegram> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountTelegram) -> Self {
            Self::Telegram(value)
        }
    }

    impl ::std::convert::From<LinkedAccountEthereum> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountEthereum) -> Self {
            Self::Ethereum(value)
        }
    }

    impl ::std::convert::From<LinkedAccountEthereumEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountEthereumEmbeddedWallet) -> Self {
            Self::EthereumEmbeddedWallet(value)
        }
    }

    impl ::std::convert::From<LinkedAccountSolana> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSolana) -> Self {
            Self::Solana(value)
        }
    }

    impl ::std::convert::From<LinkedAccountSolanaEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountSolanaEmbeddedWallet) -> Self {
            Self::SolanaEmbeddedWallet(value)
        }
    }

    impl ::std::convert::From<LinkedAccountBitcoinSegwitEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountBitcoinSegwitEmbeddedWallet) -> Self {
            Self::BitcoinSegwitEmbeddedWallet(value)
        }
    }

    impl ::std::convert::From<LinkedAccountBitcoinTaprootEmbeddedWallet> for UserLinkedAccountsItem {
        fn from(value: LinkedAccountBitcoinTaprootEmbeddedWallet) -> Self {
            Self::BitcoinTaprootEmbeddedWallet(value)
        }
    }

    ///`UserMfaMethodsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/PasskeyMfaMethod"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SmsMfaMethod"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/TotpMfaMethod"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UserMfaMethodsItem {
        PasskeyMfaMethod(PasskeyMfaMethod),
        SmsMfaMethod(SmsMfaMethod),
        TotpMfaMethod(TotpMfaMethod),
    }

    impl ::std::convert::From<&Self> for UserMfaMethodsItem {
        fn from(value: &UserMfaMethodsItem) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<PasskeyMfaMethod> for UserMfaMethodsItem {
        fn from(value: PasskeyMfaMethod) -> Self {
            Self::PasskeyMfaMethod(value)
        }
    }

    impl ::std::convert::From<SmsMfaMethod> for UserMfaMethodsItem {
        fn from(value: SmsMfaMethod) -> Self {
            Self::SmsMfaMethod(value)
        }
    }

    impl ::std::convert::From<TotpMfaMethod> for UserMfaMethodsItem {
        fn from(value: TotpMfaMethod) -> Self {
            Self::TotpMfaMethod(value)
        }
    }

    ///`Wallet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "additional_signers": [],
    ///      "address": "0xF1DBff66C993EE895C8cb176c30b07A559d76496",
    ///      "chain_type": "ethereum",
    ///      "created_at": 1741834854578,
    ///      "exported_at": null,
    ///      "id": "id2tptkqrxd39qo9j423etij",
    ///      "imported_at": null,
    ///      "owner_id": "rkiz0ivz254drv1xw982v3jq",
    ///      "policy_ids": []
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "additional_signers",
    ///    "address",
    ///    "chain_type",
    ///    "created_at",
    ///    "exported_at",
    ///    "id",
    ///    "imported_at",
    ///    "policy_ids"
    ///  ],
    ///  "properties": {
    ///    "additional_signers": {
    ///      "$ref": "#/components/schemas/WalletAdditionalSigner"
    ///    },
    ///    "address": {
    ///      "description": "Address of the wallet.",
    ///      "type": "string"
    ///    },
    ///    "chain_type": {
    ///      "$ref": "#/components/schemas/WalletChainType"
    ///    },
    ///    "created_at": {
    ///      "description": "Unix timestamp of when the wallet was created in
    /// milliseconds.",
    ///      "type": "number"
    ///    },
    ///    "exported_at": {
    ///      "description": "Unix timestamp of when the wallet was exported in
    /// milliseconds, if the wallet was exported.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "Unique ID of the wallet. This will be the primary
    /// identifier when using the wallet in the future.",
    ///      "type": "string"
    ///    },
    ///    "imported_at": {
    ///      "description": "Unix timestamp of when the wallet was imported in
    /// milliseconds, if the wallet was imported.",
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ]
    ///    },
    ///    "owner_id": {
    ///      "description": "The key quorum ID of the owner of the wallet.",
    ///      "type": "string"
    ///    },
    ///    "policy_ids": {
    ///      "description": "List of policy IDs for policies that are enforced
    /// on the wallet.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "public_key": {
    ///      "description": "The compressed, raw public key for the wallet along
    /// the chain cryptographic curve.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Wallet {
        pub additional_signers: WalletAdditionalSigner,
        ///Address of the wallet.
        pub address: ::std::string::String,
        pub chain_type: WalletChainType,
        pub created_at: f64,
        ///Unix timestamp of when the wallet was exported in milliseconds, if
        /// the wallet was exported.
        pub exported_at: ::std::option::Option<f64>,
        ///Unique ID of the wallet. This will be the primary identifier when
        /// using the wallet in the future.
        pub id: ::std::string::String,
        ///Unix timestamp of when the wallet was imported in milliseconds, if
        /// the wallet was imported.
        pub imported_at: ::std::option::Option<f64>,
        ///The key quorum ID of the owner of the wallet.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<::std::string::String>,
        ///List of policy IDs for policies that are enforced on the wallet.
        pub policy_ids: ::std::vec::Vec<::std::string::String>,
        ///The compressed, raw public key for the wallet along the chain
        /// cryptographic curve.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_key: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&Wallet> for Wallet {
        fn from(value: &Wallet) -> Self {
            value.clone()
        }
    }

    ///Additional signers for the wallet.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Additional signers for the wallet.",
    ///  "type": "array",
    ///  "items": {
    ///    "type": "object",
    ///    "required": [
    ///      "override_policy_ids",
    ///      "signer_id"
    ///    ],
    ///    "properties": {
    ///      "override_policy_ids": {
    ///        "type": "array",
    ///        "items": {
    ///          "description": "The array of policy IDs that will be applied to
    /// wallet requests. If specified, this will override the base policy IDs
    /// set on the wallet.",
    ///          "type": "string"
    ///        }
    ///      },
    ///      "signer_id": {
    ///        "type": "string"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(transparent)]
    pub struct WalletAdditionalSigner(pub ::std::vec::Vec<WalletAdditionalSignerItem>);
    impl ::std::ops::Deref for WalletAdditionalSigner {
        type Target = ::std::vec::Vec<WalletAdditionalSignerItem>;
        fn deref(&self) -> &::std::vec::Vec<WalletAdditionalSignerItem> {
            &self.0
        }
    }

    impl ::std::convert::From<WalletAdditionalSigner> for ::std::vec::Vec<WalletAdditionalSignerItem> {
        fn from(value: WalletAdditionalSigner) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&WalletAdditionalSigner> for WalletAdditionalSigner {
        fn from(value: &WalletAdditionalSigner) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<WalletAdditionalSignerItem>> for WalletAdditionalSigner {
        fn from(value: ::std::vec::Vec<WalletAdditionalSignerItem>) -> Self {
            Self(value)
        }
    }

    ///`WalletAdditionalSignerItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "override_policy_ids",
    ///    "signer_id"
    ///  ],
    ///  "properties": {
    ///    "override_policy_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "description": "The array of policy IDs that will be applied to
    /// wallet requests. If specified, this will override the base policy IDs
    /// set on the wallet.",
    ///        "type": "string"
    ///      }
    ///    },
    ///    "signer_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletAdditionalSignerItem {
        pub override_policy_ids: ::std::vec::Vec<::std::string::String>,
        pub signer_id: ::std::string::String,
    }

    impl ::std::convert::From<&WalletAdditionalSignerItem> for WalletAdditionalSignerItem {
        fn from(value: &WalletAdditionalSignerItem) -> Self {
            value.clone()
        }
    }

    ///Chain type of the wallet
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Chain type of the wallet",
    ///  "type": "string",
    ///  "enum": [
    ///    "solana",
    ///    "ethereum",
    ///    "cosmos",
    ///    "stellar",
    ///    "sui",
    ///    "tron",
    ///    "bitcoin-segwit",
    ///    "near",
    ///    "spark",
    ///    "ton",
    ///    "starknet",
    ///    "movement"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletChainType {
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "cosmos")]
        Cosmos,
        #[serde(rename = "stellar")]
        Stellar,
        #[serde(rename = "sui")]
        Sui,
        #[serde(rename = "tron")]
        Tron,
        #[serde(rename = "bitcoin-segwit")]
        BitcoinSegwit,
        #[serde(rename = "near")]
        Near,
        #[serde(rename = "spark")]
        Spark,
        #[serde(rename = "ton")]
        Ton,
        #[serde(rename = "starknet")]
        Starknet,
        #[serde(rename = "movement")]
        Movement,
    }

    impl ::std::convert::From<&Self> for WalletChainType {
        fn from(value: &WalletChainType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletChainType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Solana => f.write_str("solana"),
                Self::Ethereum => f.write_str("ethereum"),
                Self::Cosmos => f.write_str("cosmos"),
                Self::Stellar => f.write_str("stellar"),
                Self::Sui => f.write_str("sui"),
                Self::Tron => f.write_str("tron"),
                Self::BitcoinSegwit => f.write_str("bitcoin-segwit"),
                Self::Near => f.write_str("near"),
                Self::Spark => f.write_str("spark"),
                Self::Ton => f.write_str("ton"),
                Self::Starknet => f.write_str("starknet"),
                Self::Movement => f.write_str("movement"),
            }
        }
    }

    impl ::std::str::FromStr for WalletChainType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "solana" => Ok(Self::Solana),
                "ethereum" => Ok(Self::Ethereum),
                "cosmos" => Ok(Self::Cosmos),
                "stellar" => Ok(Self::Stellar),
                "sui" => Ok(Self::Sui),
                "tron" => Ok(Self::Tron),
                "bitcoin-segwit" => Ok(Self::BitcoinSegwit),
                "near" => Ok(Self::Near),
                "spark" => Ok(Self::Spark),
                "ton" => Ok(Self::Ton),
                "starknet" => Ok(Self::Starknet),
                "movement" => Ok(Self::Movement),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WalletChainType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletExportRequestBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Wallet export request",
    ///  "examples": [
    ///    {
    ///      "encryption_type": "HPKE",
    ///      "recipient_public_key":
    /// "BDAZLOIdTaPycEYkgG0MvCzbIKJLli/yWkAV5yCa9yOsZ4JsrLweA5MnP8YIiY4k/
    /// RRzC+APhhO+P+Hoz/rt7Go="
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "encryption_type",
    ///    "recipient_public_key"
    ///  ],
    ///  "properties": {
    ///    "encryption_type": {
    ///      "$ref": "#/components/schemas/HPKEEncryption"
    ///    },
    ///    "recipient_public_key": {
    ///      "description": "The base64-encoded encryption public key to encrypt
    /// the wallet private key with.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletExportRequestBody {
        pub encryption_type: HpkeEncryption,
        ///The base64-encoded encryption public key to encrypt the wallet
        /// private key with.
        pub recipient_public_key: ::std::string::String,
    }

    impl ::std::convert::From<&WalletExportRequestBody> for WalletExportRequestBody {
        fn from(value: &WalletExportRequestBody) -> Self {
            value.clone()
        }
    }

    ///`WalletExportResponseBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Wallet export response",
    ///  "examples": [
    ///    {
    ///      "ciphertext":
    /// "PRoRXygG+YYSDBXjCopNYZmx8Z6nvdl1D0lpePTYZdZI2VGfK+LkFt+GlEJqdoi9",
    ///      "encapsulated_key":
    /// "BOhR6xITDt5THJawHHJKrKdI9CBr2M/
    /// SDWzZZAaOW4gCMsSpC65U007WyKiwuuOVAo1BNm4YgcBBROuMmyIZXZk=",
    ///      "encryption_type": "HPKE"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "ciphertext",
    ///    "encapsulated_key",
    ///    "encryption_type"
    ///  ],
    ///  "properties": {
    ///    "ciphertext": {
    ///      "description": "The encrypted private key.",
    ///      "type": "string"
    ///    },
    ///    "encapsulated_key": {
    ///      "description": "The base64-encoded encapsulated key that was
    /// generated during encryption, for use during decryption.",
    ///      "type": "string"
    ///    },
    ///    "encryption_type": {
    ///      "$ref": "#/components/schemas/HPKEEncryption"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletExportResponseBody {
        ///The encrypted private key.
        pub ciphertext: ::std::string::String,
        ///The base64-encoded encapsulated key that was generated during
        /// encryption, for use during decryption.
        pub encapsulated_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
    }

    impl ::std::convert::From<&WalletExportResponseBody> for WalletExportResponseBody {
        fn from(value: &WalletExportResponseBody) -> Self {
            value.clone()
        }
    }

    ///`WalletImportInitializationRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Wallet import initialization request",
    ///  "examples": [
    ///    {
    ///      "address": "0xF1DBff66C993EE895C8cb176c30b07A559d76496",
    ///      "chain_type": "ethereum",
    ///      "encryption_type": "HPKE",
    ///      "entropy_type": "private-key"
    ///    }
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/HDInitInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PrivateKeyInitInput"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletImportInitializationRequest {
        HdInitInput(HdInitInput),
        PrivateKeyInitInput(PrivateKeyInitInput),
    }

    impl ::std::convert::From<&Self> for WalletImportInitializationRequest {
        fn from(value: &WalletImportInitializationRequest) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<HdInitInput> for WalletImportInitializationRequest {
        fn from(value: HdInitInput) -> Self {
            Self::HdInitInput(value)
        }
    }

    impl ::std::convert::From<PrivateKeyInitInput> for WalletImportInitializationRequest {
        fn from(value: PrivateKeyInitInput) -> Self {
            Self::PrivateKeyInitInput(value)
        }
    }

    ///`WalletImportInitializationResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Wallet import initialization response",
    ///  "examples": [
    ///    {
    ///      "encryption_public_key":
    /// "BDAZLOIdTaPycEYkgG0MvCzbIKJLli/yWkAV5yCa9yOsZ4JsrLweA5MnP8YIiY4k/
    /// RRzC+APhhO+P+Hoz/rt7Go=",
    ///      "encryption_type": "HPKE"
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "encryption_public_key",
    ///    "encryption_type"
    ///  ],
    ///  "properties": {
    ///    "encryption_public_key": {
    ///      "description": "The base64-encoded encryption public key to encrypt
    /// the wallet entropy with.",
    ///      "type": "string"
    ///    },
    ///    "encryption_type": {
    ///      "$ref": "#/components/schemas/HPKEEncryption"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletImportInitializationResponse {
        ///The base64-encoded encryption public key to encrypt the wallet
        /// entropy with.
        pub encryption_public_key: ::std::string::String,
        pub encryption_type: HpkeEncryption,
    }

    impl ::std::convert::From<&WalletImportInitializationResponse>
        for WalletImportInitializationResponse
    {
        fn from(value: &WalletImportInitializationResponse) -> Self {
            value.clone()
        }
    }

    ///`WalletImportSubmissionRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "title": "Wallet import submission request",
    ///  "examples": [
    ///    {
    ///      "owner_id": "rkiz0ivz254drv1xw982v3jq",
    ///      "wallet": {
    ///        "address": "0xF1DBff66C993EE895C8cb176c30b07A559d76496",
    ///        "chain_type": "ethereum",
    ///        "ciphertext":
    /// "PRoRXygG+YYSDBXjCopNYZmx8Z6nvdl1D0lpePTYZdZI2VGfK+LkFt+GlEJqdoi9",
    ///        "encapsulated_key":
    /// "BOhR6xITDt5THJawHHJKrKdI9CBr2M/
    /// SDWzZZAaOW4gCMsSpC65U007WyKiwuuOVAo1BNm4YgcBBROuMmyIZXZk=",
    ///        "encryption_type": "HPKE",
    ///        "entropy_type": "private-key"
    ///      }
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "wallet"
    ///  ],
    ///  "properties": {
    ///    "additional_signers": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "signer_id"
    ///        ],
    ///        "properties": {
    ///          "override_policy_ids": {
    ///            "type": "array",
    ///            "items": {
    ///              "type": "string"
    ///            },
    ///            "maxItems": 1
    ///          },
    ///          "signer_id": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    "owner": {
    ///      "oneOf": [
    ///        {
    ///          "type": "object",
    ///          "required": [
    ///            "user_id"
    ///          ],
    ///          "properties": {
    ///            "user_id": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        {
    ///          "type": "object",
    ///          "required": [
    ///            "public_key"
    ///          ],
    ///          "properties": {
    ///            "public_key": {
    ///              "type": "string"
    ///            }
    ///          }
    ///        },
    ///        {},
    ///        {}
    ///      ]
    ///    },
    ///    "owner_id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "policy_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 1
    ///    },
    ///    "wallet": {
    ///      "oneOf": [
    ///        {
    ///          "$ref": "#/components/schemas/HDSubmitInput"
    ///        },
    ///        {
    ///          "$ref": "#/components/schemas/PrivateKeySubmitInput"
    ///        }
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletImportSubmissionRequest {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub additional_signers: ::std::vec::Vec<WalletImportSubmissionRequestAdditionalSignersItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner: ::std::option::Option<WalletImportSubmissionRequestOwner>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub owner_id: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub policy_ids: ::std::vec::Vec<::std::string::String>,
        pub wallet: WalletImportSubmissionRequestWallet,
    }

    impl ::std::convert::From<&WalletImportSubmissionRequest> for WalletImportSubmissionRequest {
        fn from(value: &WalletImportSubmissionRequest) -> Self {
            value.clone()
        }
    }

    ///`WalletImportSubmissionRequestAdditionalSignersItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "signer_id"
    ///  ],
    ///  "properties": {
    ///    "override_policy_ids": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 1
    ///    },
    ///    "signer_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletImportSubmissionRequestAdditionalSignersItem {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub override_policy_ids: ::std::vec::Vec<::std::string::String>,
        pub signer_id: ::std::string::String,
    }

    impl ::std::convert::From<&WalletImportSubmissionRequestAdditionalSignersItem>
        for WalletImportSubmissionRequestAdditionalSignersItem
    {
        fn from(value: &WalletImportSubmissionRequestAdditionalSignersItem) -> Self {
            value.clone()
        }
    }

    ///`WalletImportSubmissionRequestOwner`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "user_id"
    ///      ],
    ///      "properties": {
    ///        "user_id": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "public_key"
    ///      ],
    ///      "properties": {
    ///        "public_key": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {},
    ///    {}
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletImportSubmissionRequestOwner {
        Variant0 { user_id: ::std::string::String },
        Variant1 { public_key: ::std::string::String },
        Variant2(::serde_json::Value),
        Variant3(::serde_json::Value),
    }

    impl ::std::convert::From<&Self> for WalletImportSubmissionRequestOwner {
        fn from(value: &WalletImportSubmissionRequestOwner) -> Self {
            value.clone()
        }
    }

    ///`WalletImportSubmissionRequestWallet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/HDSubmitInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PrivateKeySubmitInput"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletImportSubmissionRequestWallet {
        HdSubmitInput(HdSubmitInput),
        PrivateKeySubmitInput(PrivateKeySubmitInput),
    }

    impl ::std::convert::From<&Self> for WalletImportSubmissionRequestWallet {
        fn from(value: &WalletImportSubmissionRequestWallet) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<HdSubmitInput> for WalletImportSubmissionRequestWallet {
        fn from(value: HdSubmitInput) -> Self {
            Self::HdSubmitInput(value)
        }
    }

    impl ::std::convert::From<PrivateKeySubmitInput> for WalletImportSubmissionRequestWallet {
        fn from(value: PrivateKeySubmitInput) -> Self {
            Self::PrivateKeySubmitInput(value)
        }
    }

    ///The chain type of the wallet to import. Currently supports `ethereum`
    /// and `solana`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The chain type of the wallet to import. Currently
    /// supports `ethereum` and `solana`.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "solana"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletImportSupportedChains {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "solana")]
        Solana,
    }

    impl ::std::convert::From<&Self> for WalletImportSupportedChains {
        fn from(value: &WalletImportSupportedChains) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletImportSupportedChains {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Solana => f.write_str("solana"),
            }
        }
    }

    impl ::std::str::FromStr for WalletImportSupportedChains {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "solana" => Ok(Self::Solana),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WalletImportSupportedChains {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WalletImportSupportedChains {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WalletImportSupportedChains {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletRpcBody`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "caip2": "eip155:8453",
    ///      "chain_type": "ethereum",
    ///      "method": "eth_sendTransaction",
    ///      "params": {
    ///        "transaction": {
    ///          "to": "0x0000000000000000000000000000000000000000",
    ///          "value": 1
    ///        }
    ///      }
    ///    }
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSignTransactionRpcInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSendTransactionRpcInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumPersonalSignRpcInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSignTypedDataRpcInput"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/EthereumSign7702AuthorizationRpcInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSecp256k1SignRpcInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolanaSignTransactionRpcInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolanaSignAndSendTransactionRpcInput"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolanaSignMessageRpcInput"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletRpcBody {
        EthereumSignTransactionRpcInput(EthereumSignTransactionRpcInput),
        EthereumSendTransactionRpcInput(EthereumSendTransactionRpcInput),
        EthereumPersonalSignRpcInput(EthereumPersonalSignRpcInput),
        EthereumSignTypedDataRpcInput(EthereumSignTypedDataRpcInput),
        EthereumSign7702AuthorizationRpcInput(EthereumSign7702AuthorizationRpcInput),
        EthereumSecp256k1SignRpcInput(EthereumSecp256k1SignRpcInput),
        SolanaSignTransactionRpcInput(SolanaSignTransactionRpcInput),
        SolanaSignAndSendTransactionRpcInput(SolanaSignAndSendTransactionRpcInput),
        SolanaSignMessageRpcInput(SolanaSignMessageRpcInput),
    }

    impl ::std::convert::From<&Self> for WalletRpcBody {
        fn from(value: &WalletRpcBody) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcInput> for WalletRpcBody {
        fn from(value: EthereumSignTransactionRpcInput) -> Self {
            Self::EthereumSignTransactionRpcInput(value)
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcInput> for WalletRpcBody {
        fn from(value: EthereumSendTransactionRpcInput) -> Self {
            Self::EthereumSendTransactionRpcInput(value)
        }
    }

    impl ::std::convert::From<EthereumPersonalSignRpcInput> for WalletRpcBody {
        fn from(value: EthereumPersonalSignRpcInput) -> Self {
            Self::EthereumPersonalSignRpcInput(value)
        }
    }

    impl ::std::convert::From<EthereumSignTypedDataRpcInput> for WalletRpcBody {
        fn from(value: EthereumSignTypedDataRpcInput) -> Self {
            Self::EthereumSignTypedDataRpcInput(value)
        }
    }

    impl ::std::convert::From<EthereumSign7702AuthorizationRpcInput> for WalletRpcBody {
        fn from(value: EthereumSign7702AuthorizationRpcInput) -> Self {
            Self::EthereumSign7702AuthorizationRpcInput(value)
        }
    }

    impl ::std::convert::From<EthereumSecp256k1SignRpcInput> for WalletRpcBody {
        fn from(value: EthereumSecp256k1SignRpcInput) -> Self {
            Self::EthereumSecp256k1SignRpcInput(value)
        }
    }

    impl ::std::convert::From<SolanaSignTransactionRpcInput> for WalletRpcBody {
        fn from(value: SolanaSignTransactionRpcInput) -> Self {
            Self::SolanaSignTransactionRpcInput(value)
        }
    }

    impl ::std::convert::From<SolanaSignAndSendTransactionRpcInput> for WalletRpcBody {
        fn from(value: SolanaSignAndSendTransactionRpcInput) -> Self {
            Self::SolanaSignAndSendTransactionRpcInput(value)
        }
    }

    impl ::std::convert::From<SolanaSignMessageRpcInput> for WalletRpcBody {
        fn from(value: SolanaSignMessageRpcInput) -> Self {
            Self::SolanaSignMessageRpcInput(value)
        }
    }

    ///`WalletRpcResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "data": {
    ///        "caip2": "eip155:8453",
    ///        "hash":
    /// "0x0775aeed9c9ce6e0fbc4db25c5e4e6368029651c905c286f813126a09025a21e",
    ///        "transaction_request": {
    ///          "chain_id": "1",
    ///          "from": "0x38Bc05d7b69F63D05337829fA5Dc4896F179B5fA",
    ///          "gas_limit": "0x5208",
    ///          "max_fee_per_gas": "0xfc328",
    ///          "max_priority_fee_per_gas": "0xf4240",
    ///          "nonce": 1,
    ///          "to": "0xF1DBff66C993EE895C8cb176c30b07A559d76496",
    ///          "type": 2,
    ///          "value": "0x1"
    ///        }
    ///      },
    ///      "method": "eth_sendTransaction"
    ///    }
    ///  ],
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/SolanaSignTransactionRpcResponse"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/SolanaSignAndSendTransactionRpcResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SolanaSignMessageRpcResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSignTransactionRpcResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSendTransactionRpcResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumPersonalSignRpcResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSignTypedDataRpcResponse"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/EthereumSign7702AuthorizationRpcResponse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EthereumSecp256k1SignRpcResponse"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletRpcResponse {
        SolanaSignTransactionRpcResponse(SolanaSignTransactionRpcResponse),
        SolanaSignAndSendTransactionRpcResponse(SolanaSignAndSendTransactionRpcResponse),
        SolanaSignMessageRpcResponse(SolanaSignMessageRpcResponse),
        EthereumSignTransactionRpcResponse(EthereumSignTransactionRpcResponse),
        EthereumSendTransactionRpcResponse(EthereumSendTransactionRpcResponse),
        EthereumPersonalSignRpcResponse(EthereumPersonalSignRpcResponse),
        EthereumSignTypedDataRpcResponse(EthereumSignTypedDataRpcResponse),
        EthereumSign7702AuthorizationRpcResponse(EthereumSign7702AuthorizationRpcResponse),
        EthereumSecp256k1SignRpcResponse(EthereumSecp256k1SignRpcResponse),
    }

    impl ::std::convert::From<&Self> for WalletRpcResponse {
        fn from(value: &WalletRpcResponse) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<SolanaSignTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: SolanaSignTransactionRpcResponse) -> Self {
            Self::SolanaSignTransactionRpcResponse(value)
        }
    }

    impl ::std::convert::From<SolanaSignAndSendTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: SolanaSignAndSendTransactionRpcResponse) -> Self {
            Self::SolanaSignAndSendTransactionRpcResponse(value)
        }
    }

    impl ::std::convert::From<SolanaSignMessageRpcResponse> for WalletRpcResponse {
        fn from(value: SolanaSignMessageRpcResponse) -> Self {
            Self::SolanaSignMessageRpcResponse(value)
        }
    }

    impl ::std::convert::From<EthereumSignTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSignTransactionRpcResponse) -> Self {
            Self::EthereumSignTransactionRpcResponse(value)
        }
    }

    impl ::std::convert::From<EthereumSendTransactionRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSendTransactionRpcResponse) -> Self {
            Self::EthereumSendTransactionRpcResponse(value)
        }
    }

    impl ::std::convert::From<EthereumPersonalSignRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumPersonalSignRpcResponse) -> Self {
            Self::EthereumPersonalSignRpcResponse(value)
        }
    }

    impl ::std::convert::From<EthereumSignTypedDataRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSignTypedDataRpcResponse) -> Self {
            Self::EthereumSignTypedDataRpcResponse(value)
        }
    }

    impl ::std::convert::From<EthereumSign7702AuthorizationRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSign7702AuthorizationRpcResponse) -> Self {
            Self::EthereumSign7702AuthorizationRpcResponse(value)
        }
    }

    impl ::std::convert::From<EthereumSecp256k1SignRpcResponse> for WalletRpcResponse {
        fn from(value: EthereumSecp256k1SignRpcResponse) -> Self {
            Self::EthereumSecp256k1SignRpcResponse(value)
        }
    }

    ///`WalletTransactionsAsset`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "usdc",
    ///        "eth",
    ///        "pol",
    ///        "usdt",
    ///        "sol"
    ///      ]
    ///    },
    ///    {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "enum": [
    ///          "usdc",
    ///          "eth",
    ///          "pol",
    ///          "usdt",
    ///          "sol"
    ///        ]
    ///      },
    ///      "maxItems": 2
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletTransactionsAsset {
        String(WalletTransactionsAssetString),
        Array(::std::vec::Vec<WalletTransactionsAssetArrayItem>),
    }

    impl ::std::convert::From<&Self> for WalletTransactionsAsset {
        fn from(value: &WalletTransactionsAsset) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<WalletTransactionsAssetString> for WalletTransactionsAsset {
        fn from(value: WalletTransactionsAssetString) -> Self {
            Self::String(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<WalletTransactionsAssetArrayItem>>
        for WalletTransactionsAsset
    {
        fn from(value: ::std::vec::Vec<WalletTransactionsAssetArrayItem>) -> Self {
            Self::Array(value)
        }
    }

    ///`WalletTransactionsAssetArrayItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc",
    ///    "eth",
    ///    "pol",
    ///    "usdt",
    ///    "sol"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsAssetArrayItem {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "usdt")]
        Usdt,
        #[serde(rename = "sol")]
        Sol,
    }

    impl ::std::convert::From<&Self> for WalletTransactionsAssetArrayItem {
        fn from(value: &WalletTransactionsAssetArrayItem) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsAssetArrayItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Usdt => f.write_str("usdt"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsAssetArrayItem {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "usdt" => Ok(Self::Usdt),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WalletTransactionsAssetArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsAssetArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsAssetArrayItem {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsAssetString`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc",
    ///    "eth",
    ///    "pol",
    ///    "usdt",
    ///    "sol"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsAssetString {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "usdt")]
        Usdt,
        #[serde(rename = "sol")]
        Sol,
    }

    impl ::std::convert::From<&Self> for WalletTransactionsAssetString {
        fn from(value: &WalletTransactionsAssetString) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsAssetString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Usdt => f.write_str("usdt"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsAssetString {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "usdt" => Ok(Self::Usdt),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WalletTransactionsAssetString {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsAssetString {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsAssetString {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsChain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "base"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsChain {
        #[serde(rename = "base")]
        Base,
    }

    impl ::std::convert::From<&Self> for WalletTransactionsChain {
        fn from(value: &WalletTransactionsChain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsChain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Base => f.write_str("base"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsChain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "base" => Ok(Self::Base),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WalletTransactionsChain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsChain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsCursor`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    #[serde(transparent)]
    pub struct WalletTransactionsCursor(::std::string::String);
    impl ::std::ops::Deref for WalletTransactionsCursor {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<WalletTransactionsCursor> for ::std::string::String {
        fn from(value: WalletTransactionsCursor) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&WalletTransactionsCursor> for WalletTransactionsCursor {
        fn from(value: &WalletTransactionsCursor) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for WalletTransactionsCursor {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for WalletTransactionsCursor {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WalletTransactionsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WalletTransactionsCursor {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for WalletTransactionsCursor {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///`WalletTransactionsResponse`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "examples": [
    ///    {
    ///      "next_cursor": null,
    ///      "transactions": [
    ///        {
    ///          "caip2": "eip155:8453",
    ///          "created_at": 1746920539240,
    ///          "details": {
    ///            "asset": "eth",
    ///            "chain": "base",
    ///            "display_values": {
    ///              "eth": "0.000000000000000001"
    ///            },
    ///            "raw_value": "1",
    ///            "raw_value_decimals": 18,
    ///            "recipient": "0x38bc05d7b69f63d05337829fa5dc4896f179b5fa",
    ///            "recipient_privy_user_id": "cmakymbpt000te63uaj85d9r6",
    ///            "sender": "0xa24c8d74c913e5dba36e45236c478f37c8bba20e",
    ///            "sender_privy_user_id": "rkiz0ivz254drv1xw982v3jq",
    ///            "type": "transfer_sent"
    ///          },
    ///          "privy_transaction_id": "au6wxoyhbw4yhwbn1s5v9gs9",
    ///          "status": "confirmed",
    ///          "transaction_hash":
    /// "0x03fe1b0fd11a74d277a5b7a68b762de906503b82cbce2fc791250fd2b77cf137",
    ///          "wallet_id": "xs76o3pi0v5syd62ui1wmijw"
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "type": "object",
    ///  "required": [
    ///    "next_cursor",
    ///    "transactions"
    ///  ],
    ///  "properties": {
    ///    "next_cursor": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "transactions": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "object",
    ///        "required": [
    ///          "caip2",
    ///          "created_at",
    ///          "details",
    ///          "privy_transaction_id",
    ///          "status",
    ///          "transaction_hash",
    ///          "wallet_id"
    ///        ],
    ///        "properties": {
    ///          "caip2": {
    ///            "type": "string"
    ///          },
    ///          "created_at": {
    ///            "type": "number"
    ///          },
    ///          "details": {
    ///            "oneOf": [
    ///              {
    ///                "type": "object",
    ///                "required": [
    ///                  "asset",
    ///                  "chain",
    ///                  "display_values",
    ///                  "raw_value",
    ///                  "raw_value_decimals",
    ///                  "recipient",
    ///                  "recipient_privy_user_id",
    ///                  "sender",
    ///                  "sender_privy_user_id",
    ///                  "type"
    ///                ],
    ///                "properties": {
    ///                  "asset": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "usdc",
    ///                      "eth",
    ///                      "pol",
    ///                      "usdt",
    ///                      "sol"
    ///                    ]
    ///                  },
    ///                  "chain": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "ethereum",
    ///                      "arbitrum",
    ///                      "base",
    ///                      "linea",
    ///                      "optimism",
    ///                      "polygon",
    ///                      "solana",
    ///                      "zksync_era"
    ///                    ]
    ///                  },
    ///                  "display_values": {
    ///                    "type": "object",
    ///                    "additionalProperties": {
    ///                      "type": "string"
    ///                    }
    ///                  },
    ///                  "raw_value": {
    ///                    "type": "string"
    ///                  },
    ///                  "raw_value_decimals": {
    ///                    "type": "number"
    ///                  },
    ///                  "recipient": {
    ///                    "type": "string"
    ///                  },
    ///                  "recipient_privy_user_id": {
    ///                    "type": [
    ///                      "string",
    ///                      "null"
    ///                    ]
    ///                  },
    ///                  "sender": {
    ///                    "type": "string"
    ///                  },
    ///                  "sender_privy_user_id": {
    ///                    "type": [
    ///                      "string",
    ///                      "null"
    ///                    ]
    ///                  },
    ///                  "type": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "transfer_sent"
    ///                    ]
    ///                  }
    ///                }
    ///              },
    ///              {
    ///                "type": "object",
    ///                "required": [
    ///                  "asset",
    ///                  "chain",
    ///                  "display_values",
    ///                  "raw_value",
    ///                  "raw_value_decimals",
    ///                  "recipient",
    ///                  "recipient_privy_user_id",
    ///                  "sender",
    ///                  "sender_privy_user_id",
    ///                  "type"
    ///                ],
    ///                "properties": {
    ///                  "asset": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "usdc",
    ///                      "eth",
    ///                      "pol",
    ///                      "usdt",
    ///                      "sol"
    ///                    ]
    ///                  },
    ///                  "chain": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "ethereum",
    ///                      "arbitrum",
    ///                      "base",
    ///                      "linea",
    ///                      "optimism",
    ///                      "polygon",
    ///                      "solana",
    ///                      "zksync_era"
    ///                    ]
    ///                  },
    ///                  "display_values": {
    ///                    "type": "object",
    ///                    "additionalProperties": {
    ///                      "type": "string"
    ///                    }
    ///                  },
    ///                  "raw_value": {
    ///                    "type": "string"
    ///                  },
    ///                  "raw_value_decimals": {
    ///                    "type": "number"
    ///                  },
    ///                  "recipient": {
    ///                    "type": "string"
    ///                  },
    ///                  "recipient_privy_user_id": {
    ///                    "type": [
    ///                      "string",
    ///                      "null"
    ///                    ]
    ///                  },
    ///                  "sender": {
    ///                    "type": "string"
    ///                  },
    ///                  "sender_privy_user_id": {
    ///                    "type": [
    ///                      "string",
    ///                      "null"
    ///                    ]
    ///                  },
    ///                  "type": {
    ///                    "type": "string",
    ///                    "enum": [
    ///                      "transfer_received"
    ///                    ]
    ///                  }
    ///                }
    ///              },
    ///              {}
    ///            ]
    ///          },
    ///          "privy_transaction_id": {
    ///            "type": "string"
    ///          },
    ///          "sponsored": {
    ///            "type": "boolean"
    ///          },
    ///          "status": {
    ///            "type": "string",
    ///            "enum": [
    ///              "broadcasted",
    ///              "confirmed",
    ///              "execution_reverted",
    ///              "failed",
    ///              "replaced",
    ///              "finalized"
    ///            ]
    ///          },
    ///          "transaction_hash": {
    ///            "type": [
    ///              "string",
    ///              "null"
    ///            ]
    ///          },
    ///          "wallet_id": {
    ///            "type": "string"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletTransactionsResponse {
        pub next_cursor: ::std::option::Option<::std::string::String>,
        pub transactions: ::std::vec::Vec<WalletTransactionsResponseTransactionsItem>,
    }

    impl ::std::convert::From<&WalletTransactionsResponse> for WalletTransactionsResponse {
        fn from(value: &WalletTransactionsResponse) -> Self {
            value.clone()
        }
    }

    ///`WalletTransactionsResponseTransactionsItem`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "caip2",
    ///    "created_at",
    ///    "details",
    ///    "privy_transaction_id",
    ///    "status",
    ///    "transaction_hash",
    ///    "wallet_id"
    ///  ],
    ///  "properties": {
    ///    "caip2": {
    ///      "type": "string"
    ///    },
    ///    "created_at": {
    ///      "type": "number"
    ///    },
    ///    "details": {
    ///      "oneOf": [
    ///        {
    ///          "type": "object",
    ///          "required": [
    ///            "asset",
    ///            "chain",
    ///            "display_values",
    ///            "raw_value",
    ///            "raw_value_decimals",
    ///            "recipient",
    ///            "recipient_privy_user_id",
    ///            "sender",
    ///            "sender_privy_user_id",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "asset": {
    ///              "type": "string",
    ///              "enum": [
    ///                "usdc",
    ///                "eth",
    ///                "pol",
    ///                "usdt",
    ///                "sol"
    ///              ]
    ///            },
    ///            "chain": {
    ///              "type": "string",
    ///              "enum": [
    ///                "ethereum",
    ///                "arbitrum",
    ///                "base",
    ///                "linea",
    ///                "optimism",
    ///                "polygon",
    ///                "solana",
    ///                "zksync_era"
    ///              ]
    ///            },
    ///            "display_values": {
    ///              "type": "object",
    ///              "additionalProperties": {
    ///                "type": "string"
    ///              }
    ///            },
    ///            "raw_value": {
    ///              "type": "string"
    ///            },
    ///            "raw_value_decimals": {
    ///              "type": "number"
    ///            },
    ///            "recipient": {
    ///              "type": "string"
    ///            },
    ///            "recipient_privy_user_id": {
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "sender": {
    ///              "type": "string"
    ///            },
    ///            "sender_privy_user_id": {
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "transfer_sent"
    ///              ]
    ///            }
    ///          }
    ///        },
    ///        {
    ///          "type": "object",
    ///          "required": [
    ///            "asset",
    ///            "chain",
    ///            "display_values",
    ///            "raw_value",
    ///            "raw_value_decimals",
    ///            "recipient",
    ///            "recipient_privy_user_id",
    ///            "sender",
    ///            "sender_privy_user_id",
    ///            "type"
    ///          ],
    ///          "properties": {
    ///            "asset": {
    ///              "type": "string",
    ///              "enum": [
    ///                "usdc",
    ///                "eth",
    ///                "pol",
    ///                "usdt",
    ///                "sol"
    ///              ]
    ///            },
    ///            "chain": {
    ///              "type": "string",
    ///              "enum": [
    ///                "ethereum",
    ///                "arbitrum",
    ///                "base",
    ///                "linea",
    ///                "optimism",
    ///                "polygon",
    ///                "solana",
    ///                "zksync_era"
    ///              ]
    ///            },
    ///            "display_values": {
    ///              "type": "object",
    ///              "additionalProperties": {
    ///                "type": "string"
    ///              }
    ///            },
    ///            "raw_value": {
    ///              "type": "string"
    ///            },
    ///            "raw_value_decimals": {
    ///              "type": "number"
    ///            },
    ///            "recipient": {
    ///              "type": "string"
    ///            },
    ///            "recipient_privy_user_id": {
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "sender": {
    ///              "type": "string"
    ///            },
    ///            "sender_privy_user_id": {
    ///              "type": [
    ///                "string",
    ///                "null"
    ///              ]
    ///            },
    ///            "type": {
    ///              "type": "string",
    ///              "enum": [
    ///                "transfer_received"
    ///              ]
    ///            }
    ///          }
    ///        },
    ///        {}
    ///      ]
    ///    },
    ///    "privy_transaction_id": {
    ///      "type": "string"
    ///    },
    ///    "sponsored": {
    ///      "type": "boolean"
    ///    },
    ///    "status": {
    ///      "type": "string",
    ///      "enum": [
    ///        "broadcasted",
    ///        "confirmed",
    ///        "execution_reverted",
    ///        "failed",
    ///        "replaced",
    ///        "finalized"
    ///      ]
    ///    },
    ///    "transaction_hash": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "wallet_id": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WalletTransactionsResponseTransactionsItem {
        pub caip2: ::std::string::String,
        pub created_at: f64,
        pub details: WalletTransactionsResponseTransactionsItemDetails,
        pub privy_transaction_id: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sponsored: ::std::option::Option<bool>,
        pub status: WalletTransactionsResponseTransactionsItemStatus,
        pub transaction_hash: ::std::option::Option<::std::string::String>,
        pub wallet_id: ::std::string::String,
    }

    impl ::std::convert::From<&WalletTransactionsResponseTransactionsItem>
        for WalletTransactionsResponseTransactionsItem
    {
        fn from(value: &WalletTransactionsResponseTransactionsItem) -> Self {
            value.clone()
        }
    }

    ///`WalletTransactionsResponseTransactionsItemDetails`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "asset",
    ///        "chain",
    ///        "display_values",
    ///        "raw_value",
    ///        "raw_value_decimals",
    ///        "recipient",
    ///        "recipient_privy_user_id",
    ///        "sender",
    ///        "sender_privy_user_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "asset": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usdc",
    ///            "eth",
    ///            "pol",
    ///            "usdt",
    ///            "sol"
    ///          ]
    ///        },
    ///        "chain": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ethereum",
    ///            "arbitrum",
    ///            "base",
    ///            "linea",
    ///            "optimism",
    ///            "polygon",
    ///            "solana",
    ///            "zksync_era"
    ///          ]
    ///        },
    ///        "display_values": {
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "raw_value": {
    ///          "type": "string"
    ///        },
    ///        "raw_value_decimals": {
    ///          "type": "number"
    ///        },
    ///        "recipient": {
    ///          "type": "string"
    ///        },
    ///        "recipient_privy_user_id": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "sender": {
    ///          "type": "string"
    ///        },
    ///        "sender_privy_user_id": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "transfer_sent"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "asset",
    ///        "chain",
    ///        "display_values",
    ///        "raw_value",
    ///        "raw_value_decimals",
    ///        "recipient",
    ///        "recipient_privy_user_id",
    ///        "sender",
    ///        "sender_privy_user_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "asset": {
    ///          "type": "string",
    ///          "enum": [
    ///            "usdc",
    ///            "eth",
    ///            "pol",
    ///            "usdt",
    ///            "sol"
    ///          ]
    ///        },
    ///        "chain": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ethereum",
    ///            "arbitrum",
    ///            "base",
    ///            "linea",
    ///            "optimism",
    ///            "polygon",
    ///            "solana",
    ///            "zksync_era"
    ///          ]
    ///        },
    ///        "display_values": {
    ///          "type": "object",
    ///          "additionalProperties": {
    ///            "type": "string"
    ///          }
    ///        },
    ///        "raw_value": {
    ///          "type": "string"
    ///        },
    ///        "raw_value_decimals": {
    ///          "type": "number"
    ///        },
    ///        "recipient": {
    ///          "type": "string"
    ///        },
    ///        "recipient_privy_user_id": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "sender": {
    ///          "type": "string"
    ///        },
    ///        "sender_privy_user_id": {
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "transfer_received"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {}
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WalletTransactionsResponseTransactionsItemDetails {
        Variant0 {
            asset: WalletTransactionsResponseTransactionsItemDetailsVariant0Asset,
            chain: WalletTransactionsResponseTransactionsItemDetailsVariant0Chain,
            display_values:
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            raw_value: ::std::string::String,
            raw_value_decimals: f64,
            recipient: ::std::string::String,
            recipient_privy_user_id: ::std::option::Option<::std::string::String>,
            sender: ::std::string::String,
            sender_privy_user_id: ::std::option::Option<::std::string::String>,
            #[serde(rename = "type")]
            type_: WalletTransactionsResponseTransactionsItemDetailsVariant0Type,
        },
        Variant1 {
            asset: WalletTransactionsResponseTransactionsItemDetailsVariant1Asset,
            chain: WalletTransactionsResponseTransactionsItemDetailsVariant1Chain,
            display_values:
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            raw_value: ::std::string::String,
            raw_value_decimals: f64,
            recipient: ::std::string::String,
            recipient_privy_user_id: ::std::option::Option<::std::string::String>,
            sender: ::std::string::String,
            sender_privy_user_id: ::std::option::Option<::std::string::String>,
            #[serde(rename = "type")]
            type_: WalletTransactionsResponseTransactionsItemDetailsVariant1Type,
        },
        Variant2(::serde_json::Value),
    }

    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemDetails {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetails) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::serde_json::Value>
        for WalletTransactionsResponseTransactionsItemDetails
    {
        fn from(value: ::serde_json::Value) -> Self {
            Self::Variant2(value)
        }
    }

    ///`WalletTransactionsResponseTransactionsItemDetailsVariant0Asset`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc",
    ///    "eth",
    ///    "pol",
    ///    "usdt",
    ///    "sol"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant0Asset {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "usdt")]
        Usdt,
        #[serde(rename = "sol")]
        Sol,
    }

    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant0Asset) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Usdt => f.write_str("usdt"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "usdt" => Ok(Self::Usdt),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsResponseTransactionsItemDetailsVariant0Chain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "arbitrum",
    ///    "base",
    ///    "linea",
    ///    "optimism",
    ///    "polygon",
    ///    "solana",
    ///    "zksync_era"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant0Chain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }

    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant0Chain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsResponseTransactionsItemDetailsVariant0Type`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "transfer_sent"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        #[serde(rename = "transfer_sent")]
        TransferSent,
    }

    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant0Type) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TransferSent => f.write_str("transfer_sent"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant0Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "transfer_sent" => Ok(Self::TransferSent),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Type
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant0Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsResponseTransactionsItemDetailsVariant1Asset`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "usdc",
    ///    "eth",
    ///    "pol",
    ///    "usdt",
    ///    "sol"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant1Asset {
        #[serde(rename = "usdc")]
        Usdc,
        #[serde(rename = "eth")]
        Eth,
        #[serde(rename = "pol")]
        Pol,
        #[serde(rename = "usdt")]
        Usdt,
        #[serde(rename = "sol")]
        Sol,
    }

    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant1Asset) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Usdc => f.write_str("usdc"),
                Self::Eth => f.write_str("eth"),
                Self::Pol => f.write_str("pol"),
                Self::Usdt => f.write_str("usdt"),
                Self::Sol => f.write_str("sol"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "usdc" => Ok(Self::Usdc),
                "eth" => Ok(Self::Eth),
                "pol" => Ok(Self::Pol),
                "usdt" => Ok(Self::Usdt),
                "sol" => Ok(Self::Sol),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Asset
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsResponseTransactionsItemDetailsVariant1Chain`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "ethereum",
    ///    "arbitrum",
    ///    "base",
    ///    "linea",
    ///    "optimism",
    ///    "polygon",
    ///    "solana",
    ///    "zksync_era"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant1Chain {
        #[serde(rename = "ethereum")]
        Ethereum,
        #[serde(rename = "arbitrum")]
        Arbitrum,
        #[serde(rename = "base")]
        Base,
        #[serde(rename = "linea")]
        Linea,
        #[serde(rename = "optimism")]
        Optimism,
        #[serde(rename = "polygon")]
        Polygon,
        #[serde(rename = "solana")]
        Solana,
        #[serde(rename = "zksync_era")]
        ZksyncEra,
    }

    impl ::std::convert::From<&Self>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant1Chain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ethereum => f.write_str("ethereum"),
                Self::Arbitrum => f.write_str("arbitrum"),
                Self::Base => f.write_str("base"),
                Self::Linea => f.write_str("linea"),
                Self::Optimism => f.write_str("optimism"),
                Self::Polygon => f.write_str("polygon"),
                Self::Solana => f.write_str("solana"),
                Self::ZksyncEra => f.write_str("zksync_era"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ethereum" => Ok(Self::Ethereum),
                "arbitrum" => Ok(Self::Arbitrum),
                "base" => Ok(Self::Base),
                "linea" => Ok(Self::Linea),
                "optimism" => Ok(Self::Optimism),
                "polygon" => Ok(Self::Polygon),
                "solana" => Ok(Self::Solana),
                "zksync_era" => Ok(Self::ZksyncEra),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Chain
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsResponseTransactionsItemDetailsVariant1Type`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "transfer_received"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        #[serde(rename = "transfer_received")]
        TransferReceived,
    }

    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        fn from(value: &WalletTransactionsResponseTransactionsItemDetailsVariant1Type) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::TransferReceived => f.write_str("transfer_received"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemDetailsVariant1Type {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "transfer_received" => Ok(Self::TransferReceived),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Type
    {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemDetailsVariant1Type
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///`WalletTransactionsResponseTransactionsItemStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "broadcasted",
    ///    "confirmed",
    ///    "execution_reverted",
    ///    "failed",
    ///    "replaced",
    ///    "finalized"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WalletTransactionsResponseTransactionsItemStatus {
        #[serde(rename = "broadcasted")]
        Broadcasted,
        #[serde(rename = "confirmed")]
        Confirmed,
        #[serde(rename = "execution_reverted")]
        ExecutionReverted,
        #[serde(rename = "failed")]
        Failed,
        #[serde(rename = "replaced")]
        Replaced,
        #[serde(rename = "finalized")]
        Finalized,
    }

    impl ::std::convert::From<&Self> for WalletTransactionsResponseTransactionsItemStatus {
        fn from(value: &WalletTransactionsResponseTransactionsItemStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WalletTransactionsResponseTransactionsItemStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Broadcasted => f.write_str("broadcasted"),
                Self::Confirmed => f.write_str("confirmed"),
                Self::ExecutionReverted => f.write_str("execution_reverted"),
                Self::Failed => f.write_str("failed"),
                Self::Replaced => f.write_str("replaced"),
                Self::Finalized => f.write_str("finalized"),
            }
        }
    }

    impl ::std::str::FromStr for WalletTransactionsResponseTransactionsItemStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "broadcasted" => Ok(Self::Broadcasted),
                "confirmed" => Ok(Self::Confirmed),
                "execution_reverted" => Ok(Self::ExecutionReverted),
                "failed" => Ok(Self::Failed),
                "replaced" => Ok(Self::Replaced),
                "finalized" => Ok(Self::Finalized),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WalletTransactionsResponseTransactionsItemStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WalletTransactionsResponseTransactionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WalletTransactionsResponseTransactionsItemStatus
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The encrypted authorization key data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The encrypted authorization key data.",
    ///  "type": "object",
    ///  "required": [
    ///    "ciphertext",
    ///    "encapsulated_key",
    ///    "encryption_type"
    ///  ],
    ///  "properties": {
    ///    "ciphertext": {
    ///      "description": "The encrypted authorization key corresponding to
    /// the user's current authentication session.",
    ///      "type": "string"
    ///    },
    ///    "encapsulated_key": {
    ///      "description": "Base64-encoded ephemeral public key used in the
    /// HPKE encryption process. Required for decryption.",
    ///      "type": "string"
    ///    },
    ///    "encryption_type": {
    ///      "description": "The encryption type used. Currently only supports
    /// HPKE.",
    ///      "type": "string",
    ///      "enum": [
    ///        "HPKE"
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WithEncryptionEncryptedAuthorizationKey {
        ///The encrypted authorization key corresponding to the user's current
        /// authentication session.
        pub ciphertext: ::std::string::String,
        ///Base64-encoded ephemeral public key used in the HPKE encryption
        /// process. Required for decryption.
        pub encapsulated_key: ::std::string::String,
        ///The encryption type used. Currently only supports HPKE.
        pub encryption_type: WithEncryptionEncryptedAuthorizationKeyEncryptionType,
    }

    impl ::std::convert::From<&WithEncryptionEncryptedAuthorizationKey>
        for WithEncryptionEncryptedAuthorizationKey
    {
        fn from(value: &WithEncryptionEncryptedAuthorizationKey) -> Self {
            value.clone()
        }
    }

    ///The encryption type used. Currently only supports HPKE.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The encryption type used. Currently only supports
    /// HPKE.",
    ///  "type": "string",
    ///  "enum": [
    ///    "HPKE"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        #[serde(rename = "HPKE")]
        Hpke,
    }

    impl ::std::convert::From<&Self> for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        fn from(value: &WithEncryptionEncryptedAuthorizationKeyEncryptionType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Hpke => f.write_str("HPKE"),
            }
        }
    }

    impl ::std::str::FromStr for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "HPKE" => Ok(Self::Hpke),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WithEncryptionEncryptedAuthorizationKeyEncryptionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String>
        for WithEncryptionEncryptedAuthorizationKeyEncryptionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String>
        for WithEncryptionEncryptedAuthorizationKeyEncryptionType
    {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }
}

#[derive(Clone, Debug)]
///Client for Privy API
///
///Version: 0.0.1
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = ::std::time::Duration::from_secs(15u64);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}

impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "0.0.1"
    }

    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }

    fn client(&self) -> &reqwest::Client {
        &self.client
    }

    fn inner(&self) -> &() {
        &()
    }
}

impl ClientHooks<()> for &Client {}
#[allow(clippy::all)]
impl Client {
    ///Get all wallets
    ///
    ///Get all wallets in your app.
    ///
    ///Sends a `GET` request to `/v1/wallets`
    pub async fn get_wallets<'a>(
        &'a self,
        chain_type: Option<types::GetWalletsChainType>,
        cursor: Option<&'a types::GetWalletsCursor>,
        limit: Option<f64>,
        user_id: Option<&'a str>,
    ) -> Result<ResponseValue<types::GetWalletsResponse>, Error<()>> {
        let url = format!("{}/v1/wallets", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new(
                "chain_type",
                &chain_type,
            ))
            .query(&progenitor_client::QueryParam::new("cursor", &cursor))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .query(&progenitor_client::QueryParam::new("user_id", &user_id))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_wallets",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create wallet
    ///
    ///Create a new wallet.
    ///
    ///Sends a `POST` request to `/v1/wallets`
    pub async fn create_wallet<'a>(
        &'a self,
        privy_idempotency_key: Option<&'a str>,
        body: &'a types::CreateWalletBody,
    ) -> Result<ResponseValue<types::Wallet>, Error<()>> {
        let url = format!("{}/v1/wallets", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_idempotency_key {
            header_map.append("privy-idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_wallet",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a signature or transaction
    ///
    ///Sign a message or transaction with a wallet by wallet ID.
    ///
    ///Sends a `POST` request to `/v1/wallets/{wallet_id}/rpc`
    pub async fn wallet_rpc<'a>(
        &'a self,
        wallet_id: &'a str,
        privy_authorization_signature: Option<&'a str>,
        privy_idempotency_key: Option<&'a str>,
        body: &'a types::WalletRpcBody,
    ) -> Result<ResponseValue<types::WalletRpcResponse>, Error<()>> {
        let url = format!(
            "{}/v1/wallets/{}/rpc",
            self.baseurl,
            encode_path(&wallet_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        if let Some(value) = privy_idempotency_key {
            header_map.append("privy-idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "wallet_rpc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get wallet
    ///
    ///Get a wallet by wallet ID.
    ///
    ///Sends a `GET` request to `/v1/wallets/{wallet_id}`
    pub async fn get_wallet<'a>(
        &'a self,
        wallet_id: &'a str,
    ) -> Result<ResponseValue<types::Wallet>, Error<()>> {
        let url = format!(
            "{}/v1/wallets/{}",
            self.baseurl,
            encode_path(&wallet_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_wallet",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update wallet
    ///
    ///Update a wallet's policies or authorization key configuration.
    ///
    ///Sends a `PATCH` request to `/v1/wallets/{wallet_id}`
    pub async fn update_wallet<'a>(
        &'a self,
        wallet_id: &'a str,
        privy_authorization_signature: Option<&'a str>,
        body: &'a types::UpdateWalletBody,
    ) -> Result<ResponseValue<types::Wallet>, Error<()>> {
        let url = format!(
            "{}/v1/wallets/{}",
            self.baseurl,
            encode_path(&wallet_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_wallet",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Raw sign
    ///
    ///Sign a message with a wallet by wallet ID.
    ///
    ///Sends a `POST` request to `/v1/wallets/{wallet_id}/raw_sign`
    pub async fn raw_sign<'a>(
        &'a self,
        wallet_id: &'a str,
        privy_authorization_signature: Option<&'a str>,
        privy_idempotency_key: Option<&'a str>,
        body: &'a types::RawSign,
    ) -> Result<ResponseValue<types::RawSignResponse>, Error<()>> {
        let url = format!(
            "{}/v1/wallets/{}/raw_sign",
            self.baseurl,
            encode_path(&wallet_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(3usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        if let Some(value) = privy_idempotency_key {
            header_map.append("privy-idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "raw_sign",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get balance
    ///
    ///Get the balance of a wallet by wallet ID.
    ///
    ///Sends a `GET` request to `/v1/wallets/{wallet_id}/balance`
    pub async fn get_wallet_balance<'a>(
        &'a self,
        wallet_id: &'a str,
        asset: &'a types::GetWalletBalanceAsset,
        chain: &'a types::GetWalletBalanceChain,
        include_currency: Option<types::GetWalletBalanceIncludeCurrency>,
    ) -> Result<ResponseValue<types::GetWalletBalanceResponse>, Error<()>> {
        let url = format!(
            "{}/v1/wallets/{}/balance",
            self.baseurl,
            encode_path(&wallet_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("asset", &asset))
            .query(&progenitor_client::QueryParam::new("chain", &chain))
            .query(&progenitor_client::QueryParam::new(
                "include_currency",
                &include_currency,
            ))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_wallet_balance",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get transactions
    ///
    ///Get incoming and outgoing transactions of a wallet by wallet ID.
    ///
    ///Sends a `GET` request to `/v1/wallets/{wallet_id}/transactions`
    pub async fn wallet_transactions<'a>(
        &'a self,
        wallet_id: &'a str,
        asset: &'a types::WalletTransactionsAsset,
        chain: types::WalletTransactionsChain,
        cursor: Option<&'a types::WalletTransactionsCursor>,
        limit: Option<f64>,
    ) -> Result<ResponseValue<types::WalletTransactionsResponse>, Error<()>> {
        let url = format!(
            "{}/v1/wallets/{}/transactions",
            self.baseurl,
            encode_path(&wallet_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("asset", &asset))
            .query(&progenitor_client::QueryParam::new("chain", &chain))
            .query(&progenitor_client::QueryParam::new("cursor", &cursor))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "wallet_transactions",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Obtain a session key to enable wallet access
    ///
    ///Obtain a session key to enable wallet access.
    ///
    ///Sends a `POST` request to `/v1/wallets/authenticate`
    pub async fn authenticate<'a>(
        &'a self,
        body: &'a types::AuthenticateBody,
    ) -> Result<ResponseValue<types::AuthenticateResponse>, Error<()>> {
        let url = format!("{}/v1/wallets/authenticate", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "authenticate",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initialize import
    ///
    ///Initialize a wallet import. Complete by submitting the import.
    ///
    ///Sends a `POST` request to `/v1/wallets/import/init`
    pub async fn wallet_import_init<'a>(
        &'a self,
        body: &'a types::WalletImportInitializationRequest,
    ) -> Result<ResponseValue<types::WalletImportInitializationResponse>, Error<()>> {
        let url = format!("{}/v1/wallets/import/init", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "wallet_import_init",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Submit import
    ///
    ///Submit a wallet import request.
    ///
    ///Sends a `POST` request to `/v1/wallets/import/submit`
    pub async fn wallet_import_submit<'a>(
        &'a self,
        body: &'a types::WalletImportSubmissionRequest,
    ) -> Result<ResponseValue<types::Wallet>, Error<()>> {
        let url = format!("{}/v1/wallets/import/submit", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "wallet_import_submit",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Export wallet
    ///
    ///Export a wallet's private key
    ///
    ///Sends a `POST` request to `/v1/wallets/{wallet_id}/export`
    pub async fn wallet_export<'a>(
        &'a self,
        wallet_id: &'a str,
        privy_authorization_signature: Option<&'a str>,
        body: &'a types::WalletExportRequestBody,
    ) -> Result<ResponseValue<types::WalletExportResponseBody>, Error<()>> {
        let url = format!(
            "{}/v1/wallets/{}/export",
            self.baseurl,
            encode_path(&wallet_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "wallet_export",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Gets Users
    ///
    ///Get all users in your app.
    ///
    ///Sends a `GET` request to `/v1/users`
    pub async fn get_users<'a>(
        &'a self,
        cursor: Option<&'a types::GetUsersCursor>,
        limit: Option<f64>,
    ) -> Result<ResponseValue<types::GetUsersResponse>, Error<()>> {
        let url = format!("{}/v1/users", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("cursor", &cursor))
            .query(&progenitor_client::QueryParam::new("limit", &limit))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_users",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create User
    ///
    ///Create a new user with linked accounts. Optionally pre-generate embedded
    /// wallets for the user.
    ///
    ///Sends a `POST` request to `/v1/users`
    pub async fn create_user<'a>(
        &'a self,
        body: &'a types::CreateUserBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get User
    ///
    ///Get a user by user ID.
    ///
    ///Sends a `GET` request to `/v1/users/{user_id}`
    pub async fn get_user<'a>(
        &'a self,
        user_id: &'a str,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete User
    ///
    ///Delete a user by user ID.
    ///
    ///Sends a `DELETE` request to `/v1/users/{user_id}`
    pub async fn delete_user<'a>(
        &'a self,
        user_id: &'a str,
    ) -> Result<ResponseValue<()>, Error<ByteStream>> {
        let url = format!(
            "{}/v1/users/{}",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self.client.delete(url).headers(header_map).build()?;
        let info = OperationInfo {
            operation_id: "delete_user",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            204u16 => Ok(ResponseValue::empty(response)),
            404u16 => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create Custom Metadata
    ///
    ///Adds custom metadata to a user by user ID.
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/custom_metadata`
    pub async fn update_user_custom_metadata<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::UpdateUserCustomMetadataBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/custom_metadata",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_user_custom_metadata",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Email Address
    ///
    ///Looks up a user by their email address.
    ///
    ///Sends a `POST` request to `/v1/users/email/address`
    pub async fn look_up_user_by_email<'a>(
        &'a self,
        body: &'a types::LookUpUserByEmailBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/email/address", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_email",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Custom Auth ID
    ///
    ///Looks up a user by their custom auth ID.
    ///
    ///Sends a `POST` request to `/v1/users/custom_auth/id`
    pub async fn look_up_user_by_custom_auth_id<'a>(
        &'a self,
        body: &'a types::LookUpUserByCustomAuthIdBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/custom_auth/id", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_custom_auth_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by wallet address
    ///
    ///Looks up a user by their wallet address.
    ///
    ///Sends a `POST` request to `/v1/users/wallet/address`
    pub async fn look_up_user_by_wallet_address<'a>(
        &'a self,
        body: &'a types::LookUpUserByWalletAddressBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/wallet/address", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_wallet_address",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Farcaster ID
    ///
    ///Looks up a user by their Farcaster ID.
    ///
    ///Sends a `POST` request to `/v1/users/farcaster/fid`
    pub async fn look_up_user_by_farcaster_id<'a>(
        &'a self,
        body: &'a types::LookUpUserByFarcasterIdBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/farcaster/fid", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_farcaster_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Phone Number
    ///
    ///Looks up a user by their phone number.
    ///
    ///Sends a `POST` request to `/v1/users/phone/number`
    pub async fn look_up_user_by_phone_number<'a>(
        &'a self,
        body: &'a types::LookUpUserByPhoneNumberBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/phone/number", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_phone_number",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Smart Wallet Address
    ///
    ///Looks up a user by their smart wallet address.
    ///
    ///Sends a `POST` request to `/v1/users/smart_wallet/address`
    pub async fn look_up_user_by_smart_wallet_address<'a>(
        &'a self,
        body: &'a types::LookUpUserBySmartWalletAddressBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/smart_wallet/address", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_smart_wallet_address",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Discord Username
    ///
    ///Looks up a user by their Discord username.
    ///
    ///Sends a `POST` request to `/v1/users/discord/username`
    pub async fn look_up_user_by_discord_username<'a>(
        &'a self,
        body: &'a types::LookUpUserByDiscordUsernameBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/discord/username", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_discord_username",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Github Username
    ///
    ///Looks up a user by their Github username.
    ///
    ///Sends a `POST` request to `/v1/users/github/username`
    pub async fn look_up_user_by_github_username<'a>(
        &'a self,
        body: &'a types::LookUpUserByGithubUsernameBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/github/username", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_github_username",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Twitter Username
    ///
    ///Looks up a user by their Twitter username.
    ///
    ///Sends a `POST` request to `/v1/users/twitter/username`
    pub async fn look_up_user_by_twitter_username<'a>(
        &'a self,
        body: &'a types::LookUpUserByTwitterUsernameBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/twitter/username", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_twitter_username",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Twitter Subject
    ///
    ///Looks up a user by their Twitter subject.
    ///
    ///Sends a `POST` request to `/v1/users/twitter/subject`
    pub async fn look_up_user_by_twitter_subject<'a>(
        &'a self,
        body: &'a types::LookUpUserByTwitterSubjectBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/twitter/subject", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_twitter_subject",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Telegram User ID
    ///
    ///Looks up a user by their Telegram user ID.
    ///
    ///Sends a `POST` request to `/v1/users/telegram/telegram_user_id`
    pub async fn look_up_user_by_telegram_user_id<'a>(
        &'a self,
        body: &'a types::LookUpUserByTelegramUserIdBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/telegram/telegram_user_id", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_telegram_user_id",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Lookup User by Telegram Username
    ///
    ///Looks up a user by their Telegram username.
    ///
    ///Sends a `POST` request to `/v1/users/telegram/username`
    pub async fn look_up_user_by_telegram_username<'a>(
        &'a self,
        body: &'a types::LookUpUserByTelegramUsernameBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/telegram/username", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "look_up_user_by_telegram_username",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Search Users by Search Term
    ///
    ///Search users by search term, emails, phone numbers, or wallet addresses.
    ///
    ///Sends a `POST` request to `/v1/users/search`
    pub async fn search_users<'a>(
        &'a self,
        body: &'a types::SearchUsersBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/users/search", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "search_users",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create Embedded Wallet
    ///
    ///Creates an embedded wallet for an existing user.
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/wallets`
    pub async fn create_user_wallet<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::CreateUserWalletBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/wallets",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_user_wallet",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Add or update a user linked account
    ///
    ///Adds or updates a linked account for a user. This endpoint is not yet
    /// available to all users.
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/accounts`
    pub async fn add_or_update_user_linked_account<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::LinkedAccountInput,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/accounts",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "add_or_update_user_linked_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Unlink a user linked account
    ///
    ///Unlinks a user linked account.
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/accounts/unlink`
    pub async fn unlink_user_linked_account<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::UnlinkUserLinkedAccountBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/accounts/unlink",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "unlink_user_linked_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create Policy
    ///
    ///Create a new policy.
    ///
    ///Sends a `POST` request to `/v1/policies`
    pub async fn create_policy<'a>(
        &'a self,
        privy_idempotency_key: Option<&'a str>,
        body: &'a types::CreatePolicyBody,
    ) -> Result<ResponseValue<types::Policy>, Error<()>> {
        let url = format!("{}/v1/policies", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_idempotency_key {
            header_map.append("privy-idempotency-key", value.to_string().try_into()?);
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_policy",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get Policy
    ///
    ///Get a policy by policy ID.
    ///
    ///Sends a `GET` request to `/v1/policies/{policy_id}`
    pub async fn get_policy<'a>(
        &'a self,
        policy_id: &'a types::GetPolicyPolicyId,
    ) -> Result<ResponseValue<types::Policy>, Error<()>> {
        let url = format!(
            "{}/v1/policies/{}",
            self.baseurl,
            encode_path(&policy_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_policy",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete Policy
    ///
    ///Delete a policy by policy ID.
    ///
    ///Sends a `DELETE` request to `/v1/policies/{policy_id}`
    pub async fn delete_policy<'a>(
        &'a self,
        policy_id: &'a types::DeletePolicyPolicyId,
        privy_authorization_signature: Option<&'a str>,
    ) -> Result<ResponseValue<types::DeletePolicyResponse>, Error<()>> {
        let url = format!(
            "{}/v1/policies/{}",
            self.baseurl,
            encode_path(&policy_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_policy",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update Policy
    ///
    ///Update a policy by policy ID.
    ///
    ///Sends a `PATCH` request to `/v1/policies/{policy_id}`
    pub async fn update_policy<'a>(
        &'a self,
        policy_id: &'a types::UpdatePolicyPolicyId,
        privy_authorization_signature: Option<&'a str>,
        body: &'a types::UpdatePolicyBody,
    ) -> Result<ResponseValue<types::Policy>, Error<()>> {
        let url = format!(
            "{}/v1/policies/{}",
            self.baseurl,
            encode_path(&policy_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_policy",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create Policy Rule
    ///
    ///Create a new rule for a policy.
    ///
    ///Sends a `POST` request to `/v1/policies/{policy_id}/rules`
    pub async fn create_policy_rule<'a>(
        &'a self,
        policy_id: &'a types::CreatePolicyRulePolicyId,
        privy_authorization_signature: Option<&'a str>,
        body: &'a types::PolicyRuleRequestBody,
    ) -> Result<ResponseValue<types::PolicyRuleResponse>, Error<()>> {
        let url = format!(
            "{}/v1/policies/{}/rules",
            self.baseurl,
            encode_path(&policy_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_policy_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get Policy Rule
    ///
    ///Get a rule by policy ID and rule ID.
    ///
    ///Sends a `GET` request to `/v1/policies/{policy_id}/rules/{rule_id}`
    pub async fn get_policy_rule<'a>(
        &'a self,
        policy_id: &'a types::GetPolicyRulePolicyId,
        rule_id: &'a types::GetPolicyRuleRuleId,
    ) -> Result<ResponseValue<types::PolicyRuleResponse>, Error<()>> {
        let url = format!(
            "{}/v1/policies/{}/rules/{}",
            self.baseurl,
            encode_path(&policy_id.to_string()),
            encode_path(&rule_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_policy_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete Policy Rule
    ///
    ///Delete a rule by policy ID and rule ID.
    ///
    ///Sends a `DELETE` request to `/v1/policies/{policy_id}/rules/{rule_id}`
    pub async fn delete_policy_rule<'a>(
        &'a self,
        policy_id: &'a types::DeletePolicyRulePolicyId,
        rule_id: &'a types::DeletePolicyRuleRuleId,
        privy_authorization_signature: Option<&'a str>,
    ) -> Result<ResponseValue<types::DeletePolicyRuleResponse>, Error<()>> {
        let url = format!(
            "{}/v1/policies/{}/rules/{}",
            self.baseurl,
            encode_path(&policy_id.to_string()),
            encode_path(&rule_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_policy_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update Policy Rule
    ///
    ///Update a rule by policy ID and rule ID.
    ///
    ///Sends a `PATCH` request to `/v1/policies/{policy_id}/rules/{rule_id}`
    pub async fn update_policy_rule<'a>(
        &'a self,
        policy_id: &'a types::UpdatePolicyRulePolicyId,
        rule_id: &'a types::UpdatePolicyRuleRuleId,
        privy_authorization_signature: Option<&'a str>,
        body: &'a types::PolicyRuleRequestBody,
    ) -> Result<ResponseValue<types::UpdatePolicyRuleResponse>, Error<()>> {
        let url = format!(
            "{}/v1/policies/{}/rules/{}",
            self.baseurl,
            encode_path(&policy_id.to_string()),
            encode_path(&rule_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_policy_rule",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initiate Passkey Authentication
    ///
    ///Request a passkey authentication challenge.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passkeys/authenticate/init`
    pub async fn init_passkey_authentication<'a>(
        &'a self,
        body: &'a types::AuthPasskeyInitRequestBody,
    ) -> Result<ResponseValue<types::AuthPasskeyAuthenticationInitResponseBody>, Error<()>> {
        let url = format!(
            "{}/v1/user-accounts/passkeys/authenticate/init",
            self.baseurl,
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "init_passkey_authentication",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Authenticate With Passkey
    ///
    ///Authenticate a user account with a passkey.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passkeys/authenticate`
    pub async fn authenticate_with_passkey<'a>(
        &'a self,
        body: &'a types::AuthPasskeyAuthenticationRequestBody,
    ) -> Result<ResponseValue<types::AuthenticatedUser>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passkeys/authenticate", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "authenticate_with_passkey",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initiate Passkey Registration
    ///
    ///Request a passkey registration challenge
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passkeys/register/init`
    pub async fn init_passkey_registration<'a>(
        &'a self,
        body: &'a types::AuthPasskeyInitRequestBody,
    ) -> Result<ResponseValue<types::AuthPasskeyRegistrationInitResponseBody>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passkeys/register/init", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "init_passkey_registration",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Register With Passkey
    ///
    ///Register a new user account with a passkey.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passkeys/register`
    pub async fn register_with_passkey<'a>(
        &'a self,
        body: &'a types::AuthPasskeyRegistrationRequestBody,
    ) -> Result<ResponseValue<types::AuthenticatedUser>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passkeys/register", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "register_with_passkey",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initiate Passkey Link
    ///
    ///Request a passkey registration challenge linked to a user account.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passkeys/link/init`
    pub async fn init_passkey_link<'a>(
        &'a self,
        body: &'a types::AuthPasskeyLinkInitRequestBody,
    ) -> Result<ResponseValue<types::AuthPasskeyRegistrationInitResponseBody>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passkeys/link/init", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "init_passkey_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Link Passkey
    ///
    ///Link a passkey to an existing user account.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passkeys/link`
    pub async fn link_passkey<'a>(
        &'a self,
        body: &'a types::AuthPasskeyLinkedRegistrationRequestBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passkeys/link", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "link_passkey",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Unlink Passkey
    ///
    ///Unlink a passkey from a user account.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passkeys/unlink`
    pub async fn unlink_passkey<'a>(
        &'a self,
        body: &'a types::AuthPasskeyUnlinkRequestBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passkeys/unlink", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "unlink_passkey",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initiate Passwordless Authentication
    ///
    ///Request a one time code to be sent to the user's email.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passwordless/init`
    pub async fn send_code_to_email<'a>(
        &'a self,
        body: &'a types::SendCodeToEmailRequestBody,
    ) -> Result<ResponseValue<types::SendCodeToEmailResponseBody>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passwordless/init", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "send_code_to_email",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Authenticate With Passwordless
    ///
    ///Authenticate a user account with an email and code.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passwordless/authenticate`
    pub async fn authenticate_with_email<'a>(
        &'a self,
        body: &'a types::AuthenticateWithEmailRequestBody,
    ) -> Result<ResponseValue<types::AuthenticatedUser>, Error<()>> {
        let url = format!(
            "{}/v1/user-accounts/passwordless/authenticate",
            self.baseurl,
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "authenticate_with_email",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Link Passwordless
    ///
    ///Link an email to an existing user account.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passwordless/link`
    pub async fn link_email<'a>(
        &'a self,
        body: &'a types::LinkEmailRequestBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passwordless/link", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "link_email",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Unlink Passwordless
    ///
    ///Unlink an email from a user account.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passwordless/unlink`
    pub async fn unlink_email<'a>(
        &'a self,
        body: &'a types::UnlinkEmailRequestBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passwordless/unlink", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "unlink_email",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update Passwordless
    ///
    ///Update a user's linked email account.
    ///
    ///Sends a `POST` request to `/v1/user-accounts/passwordless/update`
    pub async fn update_email<'a>(
        &'a self,
        body: &'a types::UpdateEmailRequestBody,
    ) -> Result<ResponseValue<types::User>, Error<()>> {
        let url = format!("{}/v1/user-accounts/passwordless/update", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_email",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get Transaction
    ///
    ///Get a transaction by transaction ID.
    ///
    ///Sends a `GET` request to `/v1/transactions/{transaction_id}`
    pub async fn get_transaction<'a>(
        &'a self,
        transaction_id: &'a str,
    ) -> Result<ResponseValue<types::Transaction>, Error<()>> {
        let url = format!(
            "{}/v1/transactions/{}",
            self.baseurl,
            encode_path(&transaction_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_transaction",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get key quorum
    ///
    ///Get a key quorum by ID.
    ///
    ///Sends a `GET` request to `/v1/key_quorums/{key_quorum_id}`
    pub async fn get_key_quorum<'a>(
        &'a self,
        key_quorum_id: &'a str,
    ) -> Result<ResponseValue<types::KeyQuorum>, Error<()>> {
        let url = format!(
            "{}/v1/key_quorums/{}",
            self.baseurl,
            encode_path(&key_quorum_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_key_quorum",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Delete key quorum
    ///
    ///Delete a key quorum by key quorum ID.
    ///
    ///Sends a `DELETE` request to `/v1/key_quorums/{key_quorum_id}`
    pub async fn delete_key_quorum<'a>(
        &'a self,
        key_quorum_id: &'a str,
        privy_authorization_signature: Option<&'a str>,
    ) -> Result<ResponseValue<types::DeleteKeyQuorumResponse>, Error<()>> {
        let url = format!(
            "{}/v1/key_quorums/{}",
            self.baseurl,
            encode_path(&key_quorum_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .delete(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "delete_key_quorum",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update key quorum
    ///
    ///Update a key quorum by key quorum ID.
    ///
    ///Sends a `PATCH` request to `/v1/key_quorums/{key_quorum_id}`
    pub async fn update_key_quorum<'a>(
        &'a self,
        key_quorum_id: &'a str,
        privy_authorization_signature: Option<&'a str>,
        body: &'a types::UpdateKeyQuorumBody,
    ) -> Result<ResponseValue<types::KeyQuorum>, Error<()>> {
        let url = format!(
            "{}/v1/key_quorums/{}",
            self.baseurl,
            encode_path(&key_quorum_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(2usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        if let Some(value) = privy_authorization_signature {
            header_map.append(
                "privy-authorization-signature",
                value.to_string().try_into()?,
            );
        }

        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_key_quorum",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create key quorum
    ///
    ///Create a new key quorum.
    ///
    ///Sends a `POST` request to `/v1/key_quorums`
    pub async fn create_key_quorum<'a>(
        &'a self,
        body: &'a types::CreateKeyQuorumBody,
    ) -> Result<ResponseValue<types::KeyQuorum>, Error<()>> {
        let url = format!("{}/v1/key_quorums", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_key_quorum",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a list of fiat transactions and their statuses
    ///
    ///Returns a list of fiat transactions and their statuses
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/fiat/status`
    pub async fn user_fiat_statuses<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::UserFiatStatusesBody,
    ) -> Result<ResponseValue<types::UserFiatStatusesResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/status",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "user_fiat_statuses",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a terms of service agreement for a user
    ///
    ///Creates a terms of service agreement for a user
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/fiat/tos`
    pub async fn create_user_fiat_tos<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::CreateUserFiatTosBody,
    ) -> Result<ResponseValue<types::CreateUserFiatTosResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/tos",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_user_fiat_tos",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get KYC status for a user
    ///
    ///Get the current KYC verification status for a user from the configured
    /// provider
    ///
    ///Sends a `GET` request to `/v1/users/{user_id}/fiat/kyc`
    pub async fn get_user_fiat_kyc_status<'a>(
        &'a self,
        user_id: &'a str,
        provider: types::GetUserFiatKycStatusProvider,
    ) -> Result<ResponseValue<types::GetUserFiatKycStatusResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/kyc",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("provider", &provider))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_user_fiat_kyc_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initiate KYC verification for a user
    ///
    ///Initiates KYC verification process for a user with the configured
    /// provider
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/fiat/kyc`
    pub async fn initiate_user_fiat_kyc<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::InitiateUserFiatKycBody,
    ) -> Result<ResponseValue<types::InitiateUserFiatKycResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/kyc",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "initiate_user_fiat_kyc",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Update KYC status for a user
    ///
    ///Update the KYC verification status for a user from the configured
    /// provider
    ///
    ///Sends a `PATCH` request to `/v1/users/{user_id}/fiat/kyc`
    pub async fn update_user_fiat_kyc_status<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::UpdateUserFiatKycStatusBody,
    ) -> Result<ResponseValue<types::UpdateUserFiatKycStatusResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/kyc",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .patch(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "update_user_fiat_kyc_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get a KYC link for a user
    ///
    ///Returns a KYC link for a user
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/fiat/kyc_link`
    pub async fn get_user_fiat_kyc_link<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::GetUserFiatKycLinkBody,
    ) -> Result<ResponseValue<types::GetUserFiatKycLinkResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/kyc_link",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_user_fiat_kyc_link",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Get user's fiat accounts
    ///
    ///Returns the IDs of all external fiat accounts (used for offramping) for
    /// the user
    ///
    ///Sends a `GET` request to `/v1/users/{user_id}/fiat/accounts`
    pub async fn get_user_fiat_accounts<'a>(
        &'a self,
        user_id: &'a str,
        provider: types::GetUserFiatAccountsProvider,
    ) -> Result<ResponseValue<types::GetUserFiatAccountsResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/accounts",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .get(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .query(&progenitor_client::QueryParam::new("provider", &provider))
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "get_user_fiat_accounts",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Create a fiat account
    ///
    ///Sets up external bank account object for the user through the configured
    /// default provider. Requires the user to already be KYC'ed.
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/fiat/accounts`
    pub async fn create_user_fiat_account<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::CreateUserFiatAccountBody,
    ) -> Result<ResponseValue<types::CreateUserFiatAccountResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/accounts",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "create_user_fiat_account",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initiate an offramp transaction
    ///
    ///Triggers the offramp flow and gets the on-chain address to send funds to
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/fiat/offramp`
    pub async fn initiate_user_fiat_offramp<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::InitiateUserFiatOfframpBody,
    ) -> Result<ResponseValue<types::InitiateUserFiatOfframpResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/offramp",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "initiate_user_fiat_offramp",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Initiate an onramp transaction
    ///
    ///Triggers an onramp to the specified recipient blockchain address,
    /// returns the bank deposit instructions
    ///
    ///Sends a `POST` request to `/v1/users/{user_id}/fiat/onramp`
    pub async fn initiate_user_fiat_onramp<'a>(
        &'a self,
        user_id: &'a str,
        body: &'a types::InitiateUserFiatOnrampBody,
    ) -> Result<ResponseValue<types::InitiateUserFiatOnrampResponse>, Error<()>> {
        let url = format!(
            "{}/v1/users/{}/fiat/onramp",
            self.baseurl,
            encode_path(&user_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "initiate_user_fiat_onramp",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }

    ///Configure app for fiat onramping and offramping
    ///
    ///Updates the app configuration for the specified onramp provider. This is
    /// used to set up the app for fiat onramping and offramping.
    ///
    ///Sends a `POST` request to `/v1/apps/{app_id}/fiat`
    pub async fn configure_app_for_fiat_on_off_ramping<'a>(
        &'a self,
        app_id: &'a str,
        body: &'a types::ConfigureAppForFiatOnOffRampingBody,
    ) -> Result<ResponseValue<types::ConfigureAppForFiatOnOffRampingResponse>, Error<()>> {
        let url = format!(
            "{}/v1/apps/{}/fiat",
            self.baseurl,
            encode_path(&app_id.to_string()),
        );
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "configure_app_for_fiat_on_off_ramping",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}

/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
